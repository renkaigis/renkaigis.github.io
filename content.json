{"meta":{"title":"秋月春风等闲度","subtitle":"要有最朴素的生活，与最遥远的梦想。即使明日天寒地冻，路远马亡。","description":"一枚想成为技术控的菜鸟","author":"RenKai","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-08-29T15:52:30.575Z","updated":"2017-06-07T11:38:16.652Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"","date":"2017-08-24T06:40:14.215Z","updated":"2017-08-22T13:51:55.781Z","comments":true,"path":"baidu_verify_r1mSIrNf8h.html","permalink":"http://yoursite.com/baidu_verify_r1mSIrNf8h.html","excerpt":"","text":"r1mSIrNf8h"},{"title":"","date":"2017-08-22T13:49:31.106Z","updated":"2017-08-22T13:46:36.912Z","comments":true,"path":"google9d855e13918129b9.html","permalink":"http://yoursite.com/google9d855e13918129b9.html","excerpt":"","text":"google-site-verification: google9d855e13918129b9.html"},{"title":"Categories","date":"2017-06-07T05:18:02.000Z","updated":"2017-07-28T11:19:42.665Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-07T13:05:24.000Z","updated":"2017-07-28T11:19:50.249Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-06-07T05:18:23.000Z","updated":"2017-12-28T08:38:49.760Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"要有最朴素的生活，与最遥远的梦想。即使明日天寒地冻，路远马亡。 var NexT = window.NexT || {}; var CONFIG = { root: '/', scheme: 'Mist', sidebar: {\"position\":\"left\",\"display\":\"hide\",\"offset\":12,\"offset_float\":0,\"b2t\":false,\"scrollpercent\":false}, fancybox: true, motion: true, duoshuo: { userId: '0', author: 'Author' }, algolia: { applicationID: '', apiKey: '', indexName: '', hits: {\"per_page\":10}, labels: {\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"} } }; About me Name：RenKai 现居：江苏南京 爱好：跑步、乒乓球、旅游、爬山 学历： 本科 / 西北农林科技大学资源环境学院（地理信息系统 2012/09～2016/06）硕士研究生 / 南京师范大学虚拟地理环境教育部重点实验室（地图学与地理信息系统 2016/09～2019/06） 进行中的计划： &nbsp;&nbsp;KeepCoding&nbsp;&nbsp;KeepEveryDay Contact me &nbsp;&nbsp;Github &nbsp;&nbsp;Weibo &nbsp;&nbsp;CSDN &nbsp;&nbsp;Email About future .div1{ text-indent: 2em; } 现在还太菜，想要继续提升自己，不断学习新知识，同时捡起以前学过又忘掉的知识。用 Blog 来做笔记，分享经验。借助 Blog 这个平台，督促自己！"}],"posts":[{"title":"JavaWeb 之 idea 新建部署 JavaWeb 项目","slug":"JavaWeb-idea-new-web-project","date":"2018-05-28T14:08:32.000Z","updated":"2018-05-28T14:15:54.397Z","comments":true,"path":"posts/JavaWeb/2018-05-28-JavaWeb-idea-new-web-project.html","link":"","permalink":"http://yoursite.com/posts/JavaWeb/2018-05-28-JavaWeb-idea-new-web-project.html","excerpt":"习惯了 Eclipse ，想用用逼格高点的 idea 发现处处碰壁，终于搞好了，记录一下！","text":"习惯了 Eclipse ，想用用逼格高点的 idea 发现处处碰壁，终于搞好了，记录一下！ 新建项目新建项目 –&gt; Java EE –&gt; Web Application(勾选 Create web.xml)，点击 next，输入项目名和路径。 建 classes 和 lib 文件夹在 WEB-INF 目录下创建两个文件夹 classes、lib： classes：用来存放编译后输出的 class 文件 lib：用来存放项目所需的 jar 包 配置路径和 jar 包配置路径，File –&gt; Project Structure –&gt; Modules –&gt; Paths，选择 “Use module compile output path” -&gt; 将 Output path 和 Test output path 都选择刚刚创建的 classes 文件夹。 接着选择 Dependencies –&gt; 将 Module SDK 选择为自己电脑上的 jdk –&gt; 点击右边的“+”号 –&gt; 选择 “1 Jars or Directories” –&gt; 选择刚刚创建的 lib 文件夹 –&gt; 选择 jar directory，OK 就可以了。 配置 Tomcat 服务器菜单 Run –&gt; Edit Configurations… –&gt; 点击 “+” 号 –&gt; 选择 “Tomcat Server” –&gt; 选择 “Local”，在如下界面输入自己的服务器名。 点击 “Application server” 后面的 “Configure…”，弹出 Application Servers 窗口，选择本地安装的 Tomcat 目录 –&gt; OK； HTTP port 默认端口号是 8080，可以自己修改，也可以使用默认的。例如，我设为 9090，那么项目的访问路径就为：http://localhost:9090 左下角显示警告，是因为没有部署项目，点击右边的 Fix ，弹出下图，部署自己的项目，点击 ➕ 号，选择自己的 web 项目。右边可以输入项目的访问路径，可以默认，也可以自己定义。 若默认，则项目访问路径为：http://localhost:9090(我的9090端口) 若自己定义名称 test，则项目访问路径为：http://localhost:9090/test(我的9090端口) 部署并运行项目点击主界面上的 run 按钮，就可以启动服务器并运行自己的项目了。默认打开的是项目路径下的 index.jsp，可对他进行自定义编辑，看看自己的成果吧。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"MySQL 重新启动出错：MySQL is not running, but lock file (/var/lock/subsys/mysql) exists.","slug":"mysqlerror00","date":"2018-05-16T02:56:28.000Z","updated":"2018-05-16T03:06:08.891Z","comments":true,"path":"posts/uncategorized/2018-05-16-mysqlerror00.html","link":"","permalink":"http://yoursite.com/posts/uncategorized/2018-05-16-mysqlerror00.html","excerpt":"Linux 下： 运行 service mysql status 时出错： 1MySQL is not running, but lock file (/var/lock/subsys/mysql) exists","text":"Linux 下： 运行 service mysql status 时出错： 1MySQL is not running, but lock file (/var/lock/subsys/mysql) exists 解决方案： rm -f /var/lock/subsys/mysql 1[root@centos65 /]# rm -f /var/lock/subsys/mysql 重新检查 mysql 状态： 1[root@centos65 /]# service mysql status 若没有启动，可以重新启动 mysql 服务： 12[root@centos65 /]# service mysql startStarting MySQL..","categories":[],"tags":[]},{"title":"JavaWeb 学习笔记（三）—— JSP","slug":"JavaWeb03-jsp","date":"2018-05-01T14:08:57.000Z","updated":"2018-05-01T15:18:51.807Z","comments":true,"path":"posts/JavaWeb/2018-05-01-JavaWeb03-jsp.html","link":"","permalink":"http://yoursite.com/posts/JavaWeb/2018-05-01-JavaWeb03-jsp.html","excerpt":"","text":"JSP 简介JSP 概念JSP（Java Server Pages），java 服务器页面，其根本是一个简化的 Servlet 设计，是一种动态网页技术标准。JSP 是在传统的网页 HTML（标准通用标记语言的子集）文件(*.htm,*.html)中插入 Java 程序段(Scriptlet)和 JSP 标记(tag)，从而形成 JSP 文件，后缀名为(*.jsp)。 用 JSP 开发的 Web 应用是跨平台的，既能在 Linux 下运行，也能在其他操作系统上运行。 JSP 运行在服务器端，处理请求，生成动态的内容。对应的 java 和 class 文件在 tomcat 目录下的 work 目录下。 JSP 执行流程 浏览器发送请求，访问 jsp 页面； 服务器接受请求，jspSerlvet 会帮我们查找对应的 jsp 文件； 服务器将 jsp 页面翻译成 java 文件； jvm 会将 java 编译成 .class 文件； 服务器运行 class 文件，生成动态的内容； 将内容发送给服务器； 服务器组成响应信息，发送给浏览器； 浏览器接受数据，解析展示。 JSP 脚本 &lt;% %&gt;：java 程序片段，生成在 jsp 的 service 方法中 &lt;%= %&gt;：输出表达式，生成在 jsp 的 service 方法中，相当于 java 中调用 out.print(..) &lt;%! %&gt;：声明成员，翻译成 servlet 内部的内容。 JSP 注释JSP 支持三种注释：HTML 注释、Java 注释、JSP 注释: JSP 指令EL 表达式JSP 标注标签库（JSTL）","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JavaWeb 学习笔记（二）—— Request 与 Response","slug":"JavaWeb02-request-response","date":"2018-04-30T13:24:06.000Z","updated":"2018-05-01T10:42:20.863Z","comments":true,"path":"posts/JavaWeb/2018-04-30-JavaWeb02-request-response.html","link":"","permalink":"http://yoursite.com/posts/JavaWeb/2018-04-30-JavaWeb02-request-response.html","excerpt":"","text":"Response响应 的作用是往浏览器写东西。包括响应行、响应头、响应体。 操作 Response 对象操作响应行响应行的格式：协议/版本 状态码 状态码说明 状态码 说明 1xx 已发送请求 2xx 已完成响应200：正常响应 3xx 还需浏览器进一步操作302：重定向，配合响应头location304：读缓存 4xx 用户操作错误404：用户操作错误访问的方法不存在 5xx 服务器错误500：内部异常 设置状态码：12345//仅针对于上表的 1xx、2xx、3xxvoid setStatus(int 状态码):Sets the status code for this response. //针对于 4xx 和 5xx【了解】void sendError(int 状态码):Sends an error response to the client using the specified status code and clearing the buffer. 操作响应头格式：key/value（value 可以是多个值） 常用方法1234567setHeader(String key,String value):设置字符串形式的响应头【了解】setIntHeader(String key,int value):设值整型的响应头【了解】setDateHeader(String key,long value):设值时间的响应头addHeader(String key,String value):添加字符串形式的响应头，之前设置过则追加，若没有设置过则设置【了解】addIntHeader(String key,int value):添加整型的响应头【了解】addDateHeader(String key,long value):添加时间的响应头 常用的响应头 location：重定向 refresh：定时刷新 content-type：设置文件的 mime 类型，设置响应流的编码及告诉浏览器用什么编码打开 content-disposition：文件下载 重定向与定时刷新重定向 方式1：★★ 1response.sendRedirect(\"/javaweb/test1\"); 方式2： 12response.setStatus(302);respooen.setHeader(\"location\",\"/day10/loc2\"); 定时刷新 方式1： 12//设置头 refreshresponse.setHeader(\"refresh\",\"秒数;url=跳转的路径\"); 方式2： 12&lt;--! 设置html的meta标签 --&gt;&lt;meta http-equiv=\"refresh\" content=\"3;url=/javaweb/test1.html\"&gt; 操作响应体响应体即页面上要展示的内容。 常用方法12Writer getWriter():字符流ServletOutputStream getOutputStream():字节流 注：自己写的东西用字符流,其他一概用字节流. 处理响应中文乱码 方式1：★ 1response.setContentType(\"text/html;charset=utf-8\"); 方式2：理解 1response.setHeader(\"content-type\", \"text/html;charset=utf-8\"); 详细的介绍如下： 处理字节流12345//设置浏览器默认打开编码response.setHeader(\"Content-Type\", \"text/html;charset=UTF-8\");//中文转成字节数组编码response.getOutputStream().write(\"上山打老虎\".getBytes(\"UTF-8\")); 处理字符流123456//设置response的缓冲区的编码response.setCharacterEncoding(\"UTF-8\");//设置浏览器默认打开的编码.response.setHeader(\"Content-Type\", \"text/html;charset=UTF-8\");response.setContentType(\"text/html;charset=UTF-8\");//相当于上面两句 注意: 两个流互斥 当响应完成之后，服务器会判断一下流是否已经关闭，若没有关闭，服务器会帮我们关闭。（底层使用的缓冲流） 扩展-文件下载超链接方式1&lt;a href=\"/javaweb/download/Notes.txt\"&gt;下载 Notes.txt&lt;/a&gt; 若浏览器能解析该资源的mime类型，则打开；若不能解析，则下载。 手动编码方式通过 servlet 完成。 a.设置文件的 mime 类型12String mimeType=context.getMimeType(文件名);response.setContentType(mimeType); b.设置下载头信息1response.setHeader(\"content-disposition\", \"attachment;filename=\"+文件名称); c.提供流1response.getOutputStream(); 扩展-使用commons-io工具类，对拷流： 1IOUtils.copy(is,os); 案例-文件下载1.在页面中提供一组下载的链接123response.getWriter().println(\"&lt;h2&gt;手动编码方式下载&lt;/h2&gt;\");response.getWriter().println(\"&lt;a href='/WEB10/downloadServlet?filename=a.bmp'&gt;a.bmp&lt;/a&gt;&lt;br/&gt;\");response.getWriter().println(\"&lt;a href='/WEB10/downloadServlet?filename=WEB01.zip'&gt;WEB01.zip&lt;/a&gt;\"); 2.编写 DownloadServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445//获取下载文件的名称String filename = request.getParameter(\"name\");//注意中文乱码:filename = new String(filename.getBytes(\"iso8859-1\"), \"utf-8\");ServletContext context = this.getServletContext();//文件下载//1.设置文件的mimeTypeString mimeType = context.getMimeType(filename);response.setContentType(mimeType);//2.设置下载的头信息//原始的//response.setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//常见的浏览器将文件名称使用utf-8 不推荐 不兼容火狐//response.setHeader(\"content-disposition\", \"attachment;filename=\"+URLEncoder.encode(filename, \"utf-8\"));//方式1:通过 DownLoadUtils 工具类编码//String _filename=DownLoadUtils.getName(request.getHeader(\"user-agent\"), filename);//response.setHeader(\"content-disposition\", \"attachment;filename=\"+_filename);//方式2:网络上的方式 (8成好使)response.setHeader(\"content-disposition\", \"attachment;filename=\" + new String(filename.getBytes(\"gbk\"), \"iso8859-1\"));//3.对拷流//获取输入流InputStream is = context.getResourceAsStream(\"/download/\" + filename);//获取输出流ServletOutputStream os = response.getOutputStream();/*int len = -1;byte[] b = new byte[1024];while((len = is.read(b))!=-1)&#123; os.write(b, 0, len);&#125;is.close();*///使用commons-io工具类对拷流IOUtils.copy(is, os);os.close();is.close(); 其中，DownLoadUtils 如下进行封装： 1234567891011121314151617public class DownLoadUtils &#123; public static String getName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains(\"MSIE\")) &#123; // IE浏览器 filename = URLEncoder.encode(filename, \"utf-8\"); filename = filename.replace(\"+\", \" \"); &#125; else if (agent.contains(\"Firefox\")) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = \"=?utf-8?B?\" + base64Encoder.encode(filename.getBytes(\"utf-8\")) + \"?=\"; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, \"utf-8\"); &#125; return filename; &#125;&#125; 扩展-生成验证码 编写 CodeServlet: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 使用java图形界面技术绘制一张图片int charNum = 4;int width = 30 * 4;int height = 30;// 1. 创建一张内存图片BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);// 2.获得绘图对象Graphics graphics = bufferedImage.getGraphics();// 3、绘制背景颜色graphics.setColor(Color.YELLOW);graphics.fillRect(0, 0, width, height);// 4、绘制图片边框graphics.setColor(Color.BLUE);graphics.drawRect(0, 0, width - 1, height - 1);// 5、输出验证码内容graphics.setColor(Color.RED);graphics.setFont(new Font(\"宋体\", Font.BOLD, 20));// 随机输出4个字符Graphics2D graphics2d = (Graphics2D) graphics;String s = \"ABCDEFGHGKLMNPQRSTUVWXYZ23456789\";Random random = new Random();// session中要用到String msg = \"\";int x = 5;for (int i = 0; i &lt; 4; i++) &#123; int index = random.nextInt(32); String content = String.valueOf(s.charAt(index)); msg += content; double theta = random.nextInt(45) * Math.PI / 180; // 让字体扭曲 graphics2d.rotate(theta, x, 18); graphics2d.drawString(content, x, 18); graphics2d.rotate(-theta, x, 18); x += 30;&#125;// 6、绘制干扰线graphics.setColor(Color.GRAY);for (int i = 0; i &lt; 5; i++) &#123; int x1 = random.nextInt(width); int x2 = random.nextInt(width); int y1 = random.nextInt(height); int y2 = random.nextInt(height); graphics.drawLine(x1, y1, x2, y2);&#125;// 释放资源graphics.dispose();// 图片输出 ImageIOImageIO.write(bufferedImage, \"jpg\", response.getOutputStream()); 点击换一张验证码的 js 代码: 1234function changeImg(obj)&#123; //操作src属性 obj.src=\"/day10/code?i=\"+Math.random();&#125; 结果如下图： Request请求 的作用是获取浏览器发送过来的数据。 操作 Request 对象操作请求行请求行的格式：请求方式 请求资源 协议/版本 常用方法：HttpServletRequest 【掌握】★ 123String getMethod() //获取请求方式String getRemoteAddr() //获取ip地址String getContextPath() //在 java 中获取项目名称 (/javaweb) 【了解】 1234getRequestURI() //获取的是 从项目名到参数之前的内容 /javaweb/registgetRequestURL() //获取的带协议的完整路径 http://localhost/javaweb/registString getQueryString() //get请求的所有参数 username=tom&amp;password=123String getProtocol() //获取协议和版本 例如：请求行 1GET /day10/row?username=tom&amp;password=123 HTTP/1.1 操作请求头格式：key/value（value 可以是多个值） 常用方法 【掌握】★ 1String getHeader(String key) //通过key获取指定的value(一个) 【了解】 1234Enumeration getHeaders(String name) //通过key获取指定的value(多个)Enumeration getHeaderNames() //获取所有的请求头的名称int getIntHeader(String key) //获取整型的请求头long getDateHeader(String key) //获取时间的请求头 重要的请求头: user-agent：浏览器内核 msie firefox chromereferer：页面从那里来 防盗链 操作请求参数请求参数：username=tom&amp;password=123&amp;hobby=drink&amp;hobby=sleep 常用方法123String getParameter(String key) //获取一个值String[] getParameterValues(String key) //通过一个key获取多个值Map&lt;String,String[]&gt; getParameterMap() //获取所有的参数名称和值 例如： 12345678910//valueusername:tom//valueshobby:[drink, sleep]//mapusername::[tom]password::[123]hobby::[drink, sleep] 请求的中文乱码 对于 get 请求：参数追加到地址栏，会使用 utf-8 编码，服务器（tomcat7）接受到请求之后，使用 iso-8859-1 解码，所以会出现乱码。 对于 post 请求：参数是放在请求体中，服务器获取请求体的时候使用 iso-8859-1 解码，也会出现乱码。 通用的方法：缺点是需要一个一个设置 1new String(参数.getBytes(\"iso-8859-1\"),\"utf-8\"); 针对于 post 请求的方法：只需要将请求流的编码设置成 utf-8 即可。 1request.setCharacterEncoding(\"utf-8\"); 域对象 request request 域 生命周期 创建 一次请求来的时候 销毁 响应生成的时候 作用 存放一次请求里面的数据 请求转发（也叫请求链、请求串） 1request.getRequestDispatcher(\"内部路径\").forward(request,response); 作为域对象存取值 123void setAttribute(String name, Object o)void removeAttribute(String name)Object getAttribute(String name) 例如： 123request.setAttribute(\"username\",\"tom\");request.getAttribute(\"username\"); 请求转发与重定向 重定向 1response.sendRedirect(String path); 请求转发 1request.getRequestDispatcher(String path).forward(request,response); 重定向发送两次请求，请求转发一次请求 重定向地址栏发生改变，请求转发不变 重定向是从浏览器发送，请求转发是服务器内部 重定向不存在 request 域对象，请求转发可以使用 request 域对象 重定向是 response 的方法，请求转发是 request 的方法 重定向可以请求站外资源，请求转发不可以 扩展-编码解码12URLEncoder.encode(String s, \"utf-8\"); //指定编码URLDecoder.decode(String s8, \"iso8859-1\"); //指定解码 例如： 12345678910111213141516public static void main(String[] args) throws Exception &#123; String s=\"天下\"; //用 utf-8 进行编码 String s8=URLEncoder.encode(s, \"utf-8\"); //System.out.println(s8); //对utf-8的字符串通过iso8859-1进行解码，则会出现乱码 String so = URLDecoder.decode(s8, \"iso8859-1\"); System.out.println(so); //乱码 byte[] b = so.getBytes(\"iso-8859-1\"); String _s = new String(b, \"utf-8\"); //上面的两句简写为：String _s=new String(so.getBytes(\"iso8859-1\"),\"utf-8\"); System.out.println(_s);&#125; 整理的也许不全面，就这样吧！","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JavaWeb 学习笔记（一）—— HTTP 与 Servlet","slug":"JavaWeb01-http-servlet","date":"2018-03-27T13:14:24.000Z","updated":"2018-05-01T10:46:45.551Z","comments":true,"path":"posts/JavaWeb/2018-03-27-JavaWeb01-http-servlet.html","link":"","permalink":"http://yoursite.com/posts/JavaWeb/2018-03-27-JavaWeb01-http-servlet.html","excerpt":"","text":"HTTP 协议HTTP 协议的概念超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。 规定被约束的对象要遵守的规则！ HTTP 协议HTTP 协议规定：浏览器（客户端）向服务器发送何种格式的数据，服务器会处理数据，向浏览器（客户端）作出响应。（向客户端发送何种格式的数据） HTTP 协议的特点: HTTP 协议遵守一个请求响应模型； 请求和响应必须成对出现； 必须先有请求后有响应； HTTP 协议默认的端口：80 HTTP 协议的请求部分（Request）组成部分：请求行、请求头、请求体 12345678910//get 请求方式的抓包：GET /WEB09/demo1/subSucc.html?username=aaa&amp;password=123 HTTP/1.1Accept: text/html, application/xhtml+xml, */*X-HttpWatch-RID: 63397-10023Referer: http://localhost:8080/WEB09/demo1/demo1.htmlAccept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: localhost:8080Connection: Keep-Alive 123456789101112131415//post 请求方式的抓包：POST /WEB09/demo1/subSucc.html HTTP/1.1Accept: text/html, application/xhtml+xml, */*X-HttpWatch-RID: 63397-10049Referer: http://localhost:8080/WEB09/demo1/demo1.htmlAccept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoContent-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: localhost:8080Content-Length: 25Connection: Keep-AliveCache-Control: no-cacheusername=aaa&amp;password=123 请求行请求行：请求信息的第一行，包含：请求方式、请求路径、协议版本。 例如： 1GET /WEB09/demo1/subSucc.html?username=aaa&amp;password=123 HTTP/1.1 请求方式：请求方式有很多种，常用的是 GET 和 POST。 GET 和 POST 区别： GET：请求参数会显示到地址栏；GET方式有大小的限制；GET方式没有请求体。 POST：请求参数不会显示到地址栏；在请求体中，POST没有大小限制；POST方式有请求体。 只有表单设置为 method=&quot;post&quot; 才是 post 请求，其他的都是 get 请求 请求头请求头：请求信息的第二行到空行结束。 格式：key：value（value可以是多个值） 常见的请求头: 请求头 描述 Accept: text/html,image/bmp 支持数据类型text/html text/css text/javascript 大类型/小类型 mime类型 Accept-Charset: ISO-8859-1 字符集 Accept-Encoding: gzip 支持压缩 Accept-Language:zh-cn 语言环境 Host: www.renkaigis.com:80 访问主机 ★ If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT 缓存文件的最后修改时间，和响应中一个头一起使用，完成本地缓存的查找 ★ Referer: http://www.renkaigis.com/index.jsp 来自哪个页面、防盗链 ★ User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) 获得客户端浏览器的信息。（文件下载：IE：URL编码，火狐：Base64） Connection:Keep-Alive 链接状态 请求体请求体：空行以下的内容。 只有post才有请求体，获取请求参数：http://xxxx?username=tom&amp;password=123 格式：username=tom&amp;password=123 HTTP 协议的响应部分（Response）组成部分：响应行、响应头、响应体 12345678910111213141516171819HTTP/1.1 200 OKServer: Apache-Coyote/1.1Accept-Ranges: bytesETag: W/&quot;147-1455670867735&quot;Last-Modified: Wed, 17 Feb 2016 01:01:07 GMTContent-Type: text/htmlContent-Length: 147Date: Wed, 17 Feb 2016 01:17:06 GMT&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Java&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Java学习&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应行响应行：响应信息的第一行。 格式：协议/版本 状态码 状态码说明 例如：HTTP/1.1 200 OK 状态码： 200 正常响应成功 302 重定向 304 读缓存 404 用户操作资源不存在 500 服务器内部异常 响应头响应头：从响应信息的第二行到空行结束。 格式:key：value(value可以是多个值) 常见的响应头： 响应头 描述 ★ Location: http://www.it315.org/index.jsp 跳转方向 和302一起使用的 Server:apache tomcat 服务器型号 Content-Encoding: gzip 数据压缩 Content-Length: 80 数据长度 Content-Language: zh-cn 语言环境 ★ Content-Type: text/html; charset=GB2312 数据类型 ★ Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 最后的修改文件的事件.与 If-Modified-Since 一起使用 ★ Refresh: 1;url=http://www.it315.org 定时刷新 ★ Content-Disposition: attachment; filename=aaa.zip 下载 ★ Set-Cookie:SS=Q0=5Lb_nQ; path=/search Expires: -1 缓存 Cache-Control: no-cache 缓存 Pragma: no-cache 缓存 Connection: Keep-Alive 连接 响应体响应体：页面上展示的内容。 Servlet概念Servlet 是运行在服务器端的一个 Java 小程序，动态的 web 开发技术，主要功能在于交互式地浏览和修改数据，生成动态 web 内容。 Servlet = Service + Applet Servlet 实现过程 客户端发送请求至服务器端； 服务器将请求信息发送至 Servlet； Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求； 服务器将响应返回给客户端。 编写一个 Servlet 步骤1、编写一个类: a. 继承 HttpServlet， b. 重写 doGet 或者 doPost 方法； 2、编写配置文件（web-inf/web.xml）: a. 注册 Servlet; b. 绑定路径 3、访问：http://主机:端口号/项目名/路径 接收参数格式:key=value 1Sting value=request.getParameter(\"key\") 例如: http://localhost/day09/hello?username=tom request.getParameter(“username”) 就可以获取 tom 值 回写内容1response.getWriter().print(\"success\"); 处理响应数据中文乱码: 1response.setContentType(\"text/html;charset=utf-8\"); //建议放在方法中的第一行 编写配置文件配置文件路径：web-inf/web.xml 配置 Servlet 到 WEB 服务器。 123456789101112131415&lt;!-- 配置Servlet --&gt;&lt;servlet&gt; &lt;!-- Servlet的名称 --&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;!-- Servlet的类的全路径 --&gt; &lt;servlet-class&gt;com.servlet.demo1.DemoServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 配置Servlet的映射 --&gt;&lt;servlet-mapping&gt; &lt;!-- Servlet的名称 --&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;!-- Servlet的访问路径 --&gt; &lt;url-pattern&gt;/servletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; url-pattern的配置: ★ 方式1：完全匹配 必须以&quot;/&quot;开始 例如: /hello /a/b/c 方式2：目录匹配 必须&quot;/&quot;开始 以&quot;*&quot;结束 例如: /a/* /* 方式3：后缀名匹配 以&quot;*&quot;开始 以字符结尾 例如: *.jsp *.do *.action 优先级: 完全匹配 &gt; 目录匹配 &gt; 后缀名匹配 练习: 有如下的一些映射关系： Servlet1 映射到 /abc/* Servlet2 映射到 /* Servlet3 映射到 /abc Servlet4 映射到 *.do 问题: 当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/*”和“/abc”都匹配，哪个servlet响应 Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2. 当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 配置 Servlet 的启动时加载在 web.xml 中 &lt;servlet&gt; 标签中配置 1&lt;load-on-startup&gt;2&lt;/load-on-startup&gt; 作用：用来修改 servlet 的初始化时机 取值：正整数，值越大优先级越低 当我们的配置文件里面没有指定配置的话，会查找 tomcat 的 web.xml，若请求我们自己的项目处理不了,tomcat 的默认的 servlet 会帮我们处理信息。 路径的写法相对路径： 当前路径 ./ 或者 什么都不写 上一级路径 ../ 绝对路径：(我们使用) 带主机和协议的绝对路径（访问站外资源） http://www.itheima.com/xxxx http://localhost:80/day09/hello 不带主机和协议的绝对路径 /day09/hello（经常使用） Servlet 结构与方法servlet的体系结构:Servlet:接口 | GenericServlet:抽象类 | HttpServlet:抽象类 | 自定义servlet Servlet 常用方法: void init(ServletConfig config):初始化 void service(ServletRequest request,ServletResponse response):服务 处理业务逻辑 void destroy():销毁 ServletConfig getServletConfig():获取当前 servlet 的配置对象 GenericServlet 常用方法:除了 service 方法没有显示，其他都实现了 空参的 init()，若我们自己想对 servlet 进行初始化操作，重写这个 init() 方法即可 HttpServlet 常用方法：service 做了实现，把参数强转，调用了重载的 service 方法 重载的 service 方法获取请求的方式，根据请求方式的不同调用相应 doXxx() 方法 doGet 和 doPost 方法 Servlet 的生命周期生命周期指的是一个对象从创建到销毁的过程。 Servlet 的生命周期，指的是 Servlet 对象从创建到销毁的过程。 void init(ServletConfig config):初始化 * 初始化方法 * 执行者:服务器 * 执行次数:一次 * 执行时机:默认第一次访问的时候 void service(ServletRequest request,ServletResponse response):服务 处理业务逻辑 * 服务 * 执行者:服务器 * 执行次数:请求一次执行一次 * 执行时机:请求来的时候 void destroy():销毁 * 销毁 * 执行者:服务器 * 执行次数:只执行一次 * 执行时机:当servlet被移除的时候或者服务器正常关闭的时候 Serlvet是单实例多线程 默认客户端第一次访问 Servlet 的时候，服务器创建一个 Servlet 对象，并调用 init 实现初始化操作。并调用一次 service 方法，每当请求来的时候，服务器创建一个线程，调用 service 方法执行自己的业务逻辑。当 Servlet 被移除的时候或者服务器正常关闭的时候，Servlet 对象就会被销毁，服务器调用 Servlet 的 destroy 方法实现销毁操作。 补充常见的响应头——refreshrefresh（定时刷新） 响应头格式: refresh:秒数;url=跳转的路径 123//设置响应头：//设置字符串形式的响应头response.setHeader(String key,String value); 12//追加响应头，若之前设置过这个头，则追加；若没有设置过，则设置response.addHeader(String key,String value); 12//设置定时刷新：response.setHeader(\"refresh\",\"3;url=/day0901/login.htm\"); 另： 可以通过html页面中的一个标签设置头信息 &lt;meta&gt; 标签，跳转到指定路径。 1&lt;meta http-equiv=\"Refresh\" content=\"5;url=/WEB09/succ.html\"&gt; ServletContextServletContext ：全局管理者（上下文），是一个项目的引用，代表了当前项目。 当项目启动的时候，服务器会为每一个 web 项目创建一个 servletContext 对象。 当项目被移除的时候或者服务器关闭的时候 servletContext 销毁。 servletContext 接口是 Servlet 中最大的一个接口，呈现了 web 应用的 Servlet 视图。 ServletContext 实例是通过 getServletContext() 方法获得的，由于 HttpServlet 继承 GenericServlet 的关系，GenericServlet 类和 HttpServlet 类同时具有该方法。 作用: 获取全局的初始化参数 共享资源(xxxAttribute) 获取文件资源 其他操作 获取 servletcontext方式1：了解 getServletConfig().getServletContext() 方式2： getServletContext() 常用方法 了解 12String getInitParameter(String key)//通过名称获取指定的参数值Enumeration getInitParameterNames()//获取所有的参数名称 在根标签下有一个 context-param 子标签，用来存放初始化参数： 1234&lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/context-param&gt; xxxAttribute（set,get） 12345String getRealPath(String path)//获取文件部署到tomcat上的真实路径(带tomcat路径)getRealPath(\"/\")//D:\\javaTools\\apache-tomcat-7.0.52\\webapps\\day09\\InputStream getResourceAsStream(String path)//以流的形式返回一个文件 获取文件的 mime 类型（大类型/小类型） 1String getMimeType(String 文件名称) 域对象 ★★★servletcontext 可以被当成map集合。 常用方法: xxxAttribute() servletcontext 创建和销毁： 当项目启动的时候服务器为每一个 web 项目创建一个 servletcontext 对象。当项目被移除的时候或者服务器关闭的时候 servletcontext 销毁。 存放: 共享的数据 获取文件的路径通过类加载器获取文件：2.txt 放在 classes 目录下无论是 java 项目还是 web 项目都可以。 1类.class.getClassLoader().getResource(\"2.txt\").getPath();","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"ArcGIS Engine 空间关系之判断点在面内","slug":"ArcGIS-Engine-PointInPolygon","date":"2018-03-23T02:36:45.000Z","updated":"2018-03-23T03:07:42.231Z","comments":true,"path":"posts/ArcGIS/2018-03-23-ArcGIS-Engine-PointInPolygon.html","link":"","permalink":"http://yoursite.com/posts/ArcGIS/2018-03-23-ArcGIS-Engine-PointInPolygon.html","excerpt":"做项目遇到的问题。寥寥几行代码轻松解决，记录一下。","text":"做项目遇到的问题。寥寥几行代码轻松解决，记录一下。 几何对象之间的空间关系主要有包含、相等、在内部、相交等。矢量数据的空间关系运算需要用到 IRelationalOperation 接口，通过该接口的不同方法判定两个几何对象之间的关系是否存在。关系运算符用于比较两个几何体，并返回一个布尔类型值来说明某种控件关系是否存在。 空间包含关系（Contains &amp; Within）空间包含（Contains）表示当前几何对象包含输入几何对象。在内部（Within）表示当前几何对象在输入几何对象的内部。Contains 和 Within 是相对的关系，即 Contains 的反面就是 Within。 交叉（Crosses）交叉（Crosses）表示线和线或者线和面的边界之间有相交。 相离（Disjoint）相离（Disjoint）表示两个几何对象之间没有任何公共部分。 重叠（Overlaps）重叠（Overlaps）表示两个同一维度的几何对象具有公共部分，并且公共部分和输入集合对象具有相同的维度。 相等（Equals）相等（Equals）表示两个几何对象具有相同的几何维度、顶点集合等。对于多边形和线几何类型，如果它们具有相等关系，则 SymmetricDifference 方法返回值为空。 相接（Touches）相接（Touches）表示两个几何对象的边界相交。如果两个几何对象相接，那么它们的交集不为空，但是集合对象的内部交集为空。 IRelationalOperator的一些关系类型: 关系类型 描述 Contains 判断一个图形是否包含另外一个图形 Within 判断一个图形是否被另外一个图形所包含。 Crosses 判断两个图形是否在维数较少的那个图形的内部相交 Disjoint 判断两个图形间是否没有相同点 Equals 判断两个图形是否是同一个类型并且在平面上的点是否是相同的位置。如果返回值为真，则它们应该包含（Contains）另外一个图形同时也被另外一个图形所包含(Within)。 Overlaps 判断两个图形的交集是否和其中的一个图形拥有相同的维数，并且他们交集不能和其中任何一个图形相等。该方法只使用与两个Polyline 之间或者两个Polygon 之间。 Touches 判断两个图形的边界是否相交，如果两个图形的交集不为空，但两个图形内部的交集为空，则返回值为真。 本文主要实现了判断点在面内（空间包含关系） AE 代码见 Github：PointInPolygon (AE 版本 10.1，VS 版本 2017) 若代码不能运行，请添加如下引用： 12345678910111213141516using ESRI.ArcGIS.Carto;using ESRI.ArcGIS.esriSystem;using ESRI.ArcGIS.Geodatabase;using ESRI.ArcGIS.Geoprocessing;using ESRI.ArcGIS.AnalysisTools;using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ESRI.ArcGIS.Geoprocessor;using ESRI.ArcGIS.Geometry; 我主要实现了 判断点在面内 的方法，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void pointInPolygonButton_Click(object sender, EventArgs e)&#123; // 获得点图层 int PointId = 1; IFeatureLayer PointLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; PointLayer = axMapControl1.get_Layer(i) as IFeatureLayer; if (PointLayer is IFeatureLayer &amp;&amp; PointLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPoint) &#123; PointId = i; &#125; &#125; if (PointId == -1) &#123; MessageBox.Show(\"找不到质点图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; // 获得面图层 int PolygonId = -1; IFeatureLayer PolygonLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; PolygonLayer = axMapControl1.get_Layer(i) as IFeatureLayer; if (PolygonLayer is IFeatureLayer &amp;&amp; PolygonLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolygon) &#123; PolygonId = i; &#125; &#125; if (PolygonId == -1) &#123; MessageBox.Show(\"找不到边界图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; PointLayer = axMapControl1.get_Layer(PointId) as IFeatureLayer; PolygonLayer = axMapControl1.get_Layer(PolygonId) as IFeatureLayer; IFeatureCursor PointFeatureCursor = PointLayer.Search(null, true); IFeature PointFeature = PointFeatureCursor.NextFeature(); IFeatureCursor PolygonFeatureCursor = PolygonLayer.Search(null, true); IFeature PolygonFeature = PolygonFeatureCursor.NextFeature(); IRelationalOperator pRelationalOperator = PolygonFeature.Shape as IRelationalOperator; if (pRelationalOperator.Contains(PointFeature.Shape)) &#123; MessageBox.Show(\"点在面内！\", \"恭喜你！\", MessageBoxButtons.OK, MessageBoxIcon.Information); return; &#125; else &#123; MessageBox.Show(\"点在面外！\", \"很遗憾！\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125;&#125; 运行结果：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"ArcGIS Engine 之 GP 工具实现矢量转栅格","slug":"ArcGIS-Engine-PointToRaster","date":"2018-03-21T09:02:30.000Z","updated":"2018-03-23T03:09:53.076Z","comments":true,"path":"posts/ArcGIS/2018-03-21-ArcGIS-Engine-PointToRaster.html","link":"","permalink":"http://yoursite.com/posts/ArcGIS/2018-03-21-ArcGIS-Engine-PointToRaster.html","excerpt":"做项目遇到需要将矢量数据转换成栅格数据的问题，走了很多弯路，后来发现使用 GP 工具很轻松就解决了，记录一下。","text":"做项目遇到需要将矢量数据转换成栅格数据的问题，走了很多弯路，后来发现使用 GP 工具很轻松就解决了，记录一下。 ArcGIS 软件中 ArcToolbox 中的工具几乎都可以使用 GP 工具来完成。矢量转栅格的工具主要在 ArcToolbox --&gt; Conversion Tools --&gt; To Raster 下，包括 Feature to Raster、Point to Raster、Polygon to Raster 和 Polyline to Raster。其中 Feature to Raster 与其他三种效果相同。 ArcGIS 中 Feature to Raster 方法如下图所示： 官方文档给出的工具语法如下： FeatureToRaster_conversion (in_features, field, out_raster, {cell_size}) Parameter Explanation Data Type in_features The input feature dataset to be converted to a raster dataset. Feature Layer field The field used to assign values to the output raster.It can be any field of the input feature dataset’s attribute table.If the Shape field of a point or multipoint dataset contains z or m values, then either of these can be used. Field out_raster The output raster dataset to be created.When not saving to a geodatabase, specify .tif for a TIFF file format, .img for an ERDAS IMAGINE file format, or no extension for an Esri Grid raster format. Raster Dataset cell_size(Optional) The cell size for the output raster dataset.The default cell size is the shortest of the width or height of the extent of the input feature dataset, in the output spatial reference, divided by 250. Analysis Cell Size AE 代码见 Github：PointToRaster (AE 版本 10.1，VS 版本 2017) 若代码不能运行，请添加如下引用： 12345678910111213141516using ESRI.ArcGIS.Carto;using ESRI.ArcGIS.esriSystem;using ESRI.ArcGIS.Geodatabase;using ESRI.ArcGIS.Geoprocessing;using ESRI.ArcGIS.AnalysisTools;using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ESRI.ArcGIS.Geoprocessor;using ESRI.ArcGIS.DataSourcesRaster; 我主要实现了 点转栅格 的方法，核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void toRaster_Click(object sender, EventArgs e)&#123; Geoprocessor gp = new Geoprocessor(); gp.OverwriteOutput = true; int pLayerId = -1; ILayer pLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; pLayer = axMapControl1.get_Layer(i); //if (pLayer is IFeatureLayer &amp;&amp; pLayer.Name == \"质点\") if (pLayer is IFeatureLayer) &#123; pLayerId = i; &#125; &#125; if (pLayerId == -1) &#123; MessageBox.Show(\"找不到点图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; try &#123; ESRI.ArcGIS.ConversionTools.FeatureToRaster ptr = new ESRI.ArcGIS.ConversionTools.FeatureToRaster(); // 获得点图层 IFeatureLayer pfeatureLayer = axMapControl1.get_Layer(pLayerId) as IFeatureLayer; IFeatureClass feaureClass = pfeatureLayer.FeatureClass; ptr.in_features = pfeatureLayer; string filepath = @\"d:\\gis\\\"; ptr.out_raster = filepath + pfeatureLayer.Name + \".tif\"; // 将转换结果保存为tif格式 ptr.field = \"id\"; // 设置根据那个字段进行转换 ptr.cell_size = 64; // 设置转换后的栅格像元大小 gp.Execute(ptr, null); // 执行 GP 工具 MessageBox.Show(\"转换成功！\", \"恭喜你！\", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); // 加载栅格 IWorkspaceFactory pWorkspaceFactory = new RasterWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filepath, 0); IRasterWorkspace pRasterWorkspace = pWorkspace as IRasterWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pfeatureLayer.Name + \".tif\"); IRaster pRaster= pRasterDataset.CreateDefaultRaster(); IRasterLayer pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromRaster(pRaster); ILayer layer = pRasterLayer as ILayer; axMapControl1.AddLayer(layer, 0); &#125; catch (Exception ex) &#123; MessageBox.Show(\"转换失败！\", \"很遗憾！\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125;&#125; 运行结果： 经测试，该代码同样适用与 面数据转换栅格：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"2018 要酷酷的","slug":"2017-2018singledogsingledog","date":"2017-12-31T09:37:34.000Z","updated":"2018-04-15T05:05:02.843Z","comments":true,"path":"posts/Mine/2017-12-31-2017-2018singledogsingledog.html","link":"","permalink":"http://yoursite.com/posts/Mine/2017-12-31-2017-2018singledogsingledog.html","excerpt":"本想写个年终总结的。","text":"本想写个年终总结的。 年末刷微博的时候，突然看到这幅漫画，瞬间泪奔。 2017 对我很好，他没有亏待我，是我自己不争气，辜负了 2017，浪费了 2017 的大好时光。 2017 再见，抱歉虚度了你，有太多抱怨不解难过与孤独，但都自己一个人撑过来。若是我有做的不好的地方，还请你宽容我，请原谅我这一年的放纵不羁，原谅最后的我没有给你一个满意的答卷。若是 2018 对我不好，我还是会想你的。 对于 2018 我不敢承诺什么，但是我还是要说： 2018，请你对这个傻逼好点！拜托啦！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"Java 泛型：T/K/V/E含义","slug":"java-generic-means-TKVE","date":"2017-12-02T11:54:51.000Z","updated":"2017-12-02T12:32:05.746Z","comments":true,"path":"posts/Java/2017-12-02-java-generic-means-TKVE.html","link":"","permalink":"http://yoursite.com/posts/Java/2017-12-02-java-generic-means-TKVE.html","excerpt":"从 Java 5 之后，Java 引入了 “参数化类型（parameterized type）” 的概念，允许程序在创建集合时指定集合元素的类型。例如 List&lt;String&gt; ，这表明该 List 只能保存字符串类型的对象。Java 的参数化类型被称为 泛型（Generic）。 看了很多的泛型，T、K、V、E 的字眼层出不穷，却不知道是什么意思。网上查了一些资料，学习了！","text":"从 Java 5 之后，Java 引入了 “参数化类型（parameterized type）” 的概念，允许程序在创建集合时指定集合元素的类型。例如 List&lt;String&gt; ，这表明该 List 只能保存字符串类型的对象。Java 的参数化类型被称为 泛型（Generic）。 看了很多的泛型，T、K、V、E 的字眼层出不穷，却不知道是什么意思。网上查了一些资料，学习了！ Java 泛型中的标记符含义： ？：表示不确定的 java 类型。 T：表示 java 类型。 K、V：分别代表 java 键值中的 Key、Value。 E：表示 enum 枚举。 Object：java 中所有类的父类。 jdk 中的 K，V，T，E 等泛型名称很多人以为是固定写法，其实这些名称是可以改的，比如改成 zhangsan，lisi 都可以，jdk 为了容易看懂，所以用 K 表示键，V 表示值，T 表示 type 类型，E 表示 enum 枚举，其实这四个都只是符号，都是表示泛型名称，T 全部可以换成 E，也可以换成 K，V，zhangsan，都没关系。 Object 跟这些标记符代表的 java 类型有什么区别呢？Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型 T、E 等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。 代码摘自网络： 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;//T1,T2都是随便定义的东西，注意1:他们不会关联到其他类，只是在本类中通用，只是告诉我们new的时候要加入泛型public class Test&lt;T1, T2&gt; &#123; public static void main(String[] args) &#123; System.out.println(new Test().getaa()); new Test&lt;String, String&gt; ().getbb(\"\"); new Test().getcc(Test.class); //注意下6:面这个HashMap的括号里面不能是T,E,T1,T2等不确定的东西,但可以是? HashMap&lt;Object, String&gt; map = new HashMap&lt;Object, String&gt;(); List&lt;?&gt; list = new ArrayList&lt;String&gt;(); &#125; T2 getaa() &#123; //注意2:T2将自动转型为String,这个不需要去担心 return (T2) \"few\"; &#125; public &lt;T&gt; void getbb(T x) &#123; //注意3:Class&lt;T&gt;前面缺少&lt;T&gt;将编译错误 System.out.println(x.getClass().getName()); &#125; public &lt;T&gt; Class&lt;?&gt; getcc(Class&lt;T&gt; a) &#123; //getcc前面的Class&lt;T&gt;前面缺少&lt;T&gt;将编译错误,注意4:Class&lt;?&gt;里面的问号可以换成T System.out.println(a.getClass().getName()); //注意5:参数里面的Class&lt;T&gt;最大的好处是如果方法里面定义了泛型，可以自动获取类型值，比如如下的List&lt;T&gt;可以自动获取到a的类型，不必强调死 List&lt;T&gt; aa=new ArrayList&lt;T&gt;(); System.out.println(aa); return a; &#125;&#125; 运行结果： 1234fewjava.lang.Stringjava.lang.Class[]","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"滇池实验——昆明之旅","slug":"experiment-in-Kunming-Dianchi","date":"2017-11-20T02:02:56.000Z","updated":"2017-11-20T08:51:58.661Z","comments":true,"path":"posts/Mine/2017-11-20-experiment-in-Kunming-Dianchi.html","link":"","permalink":"http://yoursite.com/posts/Mine/2017-11-20-experiment-in-Kunming-Dianchi.html","excerpt":"于我而言，对这趟“滇池实验”充满着期待…第一次出差，第一次去云南，第一次坐飞机，第一次冲上云霄，…… 内含多图，流量慎点！","text":"于我而言，对这趟“滇池实验”充满着期待…第一次出差，第一次去云南，第一次坐飞机，第一次冲上云霄，…… 内含多图，流量慎点！ 讲真，从小到大第一次坐飞机，对一切都是陌生又期待的。天生的贪玩属性，出差不仅要做好本职工作，还要好好地玩~ 飞机篇 没坐过飞机的人看见什么都是充满新奇的~ 工作篇 采水样，做实验，实地考察滇池，做汇报。工作先行，游玩次之~ 海鸥篇 这么铺天盖地的海鸥还是第一次见，抑制不住的兴奋~ 滇池篇 讲真，滇池的水真的脏，真 · 青山绿水 风景篇 昆明的天气一直都那么好，随手一拍都是美美的照片 蓝蓝的天，白白的云，太阳直射，暖洋洋 文艺篇 找到了一家西西弗书店，灯光及装饰都给人温暖的感觉 在矢量咖啡点上一杯咖啡，轻柔的音乐响起，无比惬意！ 还去了猫的天空之城概念书店、花生书店。这两家店都太小了，远不如西西弗书店大气。尤其是不消费还赶人！！！ 美食篇 云大附近的园西路，很多好吃的 海埂公园附近的小吃一条街 满足的两个吃货 人物篇 和师姐同游昆明，帮师姐拍了很多美美的照片 我自己的照片很少，满屏幕都是师姐的照片 哼😒等我瘦下来！ 总结昆明之旅很开心，很满足。 最重要的是，看到了和别人的差距，自我感觉别人的 web 平台做的真的很好，而我们的单机版系统不仅从界面还是可视化都感觉很 low。 后面滇池的项目得我接手了，继续学习，继续努力，远离农药，提高代码功底，像师姐学习！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"秦时明月之风林火山集结","slug":"video-qsmoon-flhs","date":"2017-08-31T13:02:14.000Z","updated":"2017-08-31T15:52:14.819Z","comments":true,"path":"posts/Mine/2017-08-31-video-qsmoon-flhs.html","link":"","permalink":"http://yoursite.com/posts/Mine/2017-08-31-video-qsmoon-flhs.html","excerpt":"","text":"楚虽三户，亡秦必楚！ 想要成就霸王之业 你需要找到四个重要的人 这四个人就是传承兵道的 风 林 火 山 秦时明月视频纯剪辑 素材：秦时明月之君临天下（第19集-楚之军魂、第68集-一血一脉） 软件：Corel VideoStudio X9 插件：Xvid 分辨率：1920 × 1080","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Video","slug":"Video","permalink":"http://yoursite.com/tags/Video/"}]},{"title":"CSS 基础学习笔记","slug":"css-basic-learning-notes","date":"2017-08-31T03:05:17.000Z","updated":"2017-11-03T13:25:22.074Z","comments":true,"path":"posts/HTML-CSS-JS/2017-08-31-css-basic-learning-notes.html","link":"","permalink":"http://yoursite.com/posts/HTML-CSS-JS/2017-08-31-css-basic-learning-notes.html","excerpt":"自学 CSS 基础笔记。笔记整理中，未完待续……","text":"自学 CSS 基础笔记。笔记整理中，未完待续…… CSS 重点内容： 选择器 浮动 盒子模型 定位 前言CSS 概念 CSS（Cascading Style Sheet，可译为 层叠样式表 或 级联样式表 ）是一组 格式设置规则，用于控制 Web 页面的外观。 通过使用CSS样式设置页面的格式，可将页面的 内容与表现形式分离。页面内容存放在HTML文档中，而用于定义表现形式的CSS规则则存放在另一个文件中或HTML文档的某一部分，通常为文件头部分。 将内容与表现形式分离，不仅可使 维护站点的外观更加容易，而且还可以使HTML文档代码更加简练， 缩短浏览器的加载时间 。 可以用 CSS 做什么？ CSS 是一种 样式表语言 ，用于 为HTML文档定义布局 。例如，CSS 涉及字体、颜色、边距、高度、宽度、背景图像、高级定位等方面。 HTML 可以用于为网站添加布局效果，但有可能被误用。而CSS则提供了更多选择，而且更为精确、完善。现在所有浏览器都支持CSS。 你可以制作自己的CSS样式表，为自己的网站增添花样。 CSS 和 HTML 的区别在哪里？HTML 用于结构化内容CSS 用于格式化结构化的内容 CSS 以 html 为基础的。 CSS 主要设置的就是 html 标签中的属性样式，css进行网页布局。 结构 作用 HTML 结构层 负责从 语义的角度 搭建页面结构 CSS 样式层 负责从 审美的角度 美化页面 JavaScript 行为层 负责从 交互的角度 提升用户体验 采用CSS有哪些好处？ CSS 是 Web 设计界的一次革命。 CSS 的具体优点包括： 通过单个样式表控制多个文档的布局； 更精确的布局控制； 为不同的媒体类型（屏幕、打印等）采取不同的布局； 无数高级、先进的技巧… 采用CSS布局相对于传统的 TABLE 网页布局而具有以下4个显著优势： 表现和内容相分离 将设计部分剥离出来放在一个独立样式文件中，HTML文件中只存放文本信息。这样的页面对搜索引擎更加友好。 提高页面浏览速度 对于同一个页面视觉效果，采用 CSS 布局的页面容量要比 TABLE 编码的页面文件容量小得多，前者一般只有后者的1/2大小。浏览器就不用去编译大量冗长的标签。 易于维护和改版 你只要简单的修改几个 CSS 文件就可以重新设计整个网站的页面。 使用CSS布局更符合现在的 W3C 标准 W3C 组织并不是 ISO 国际标准组织的成员，而是自成一派的万维网联盟(World Wide Web Consortium)，又称 W3C 理事会，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。 CSS 工作原理CSS 语法1选择器&#123;属性:值; 属性:值;.... &#125; 选择器：就是一个选择谁的过程。 参数说明：属性和属性值之间用 冒号(:) 隔开，定义多个属性时，属性之间用英文输入法下的 分号(;) 隔开。 属性 赋值 介绍 color color: red; 前景色（文字颜色） font-size font-size: 20px; 设置文字大小 width width: 30px; 设置宽度 height height: 30px; 设置高度 background-color background-color: red; 设置背景颜色 text-align text-align: center; left/right 文字居中 text-indent text-indent: 2em; 首行缩进 注意：text-align: center; 在块级元素中可以使文字居中显示 CSS 书写位置介绍方法1：行内样式表（style属性） 为 HTML 应用 CSS 的一种方法是使用 HTML 属性 style 。 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; 例子 &lt;/title&gt;&lt;/head&gt;&lt;body style=\"background-color: #FF0000;\"&gt; &lt;p style=\"color:green;font-size:30px;\"&gt;这个页面背景是红色的!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 方法2：内部样式表（style元素） 为 HTML 应用 CSS 的另一种方法是采用 HTML 元素 style 。比如像这样： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;例子&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123;background-color: #FF0000;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这个页面是红色的&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 方法3：外部样式表（引用一个样式表文件）更推荐采用这种引用外部样式表的方法。 外部样式表就是一个扩展名为 css 的文本文件。跟其他文件一样，你可以把样式表文件放在Web服务器上或者本地硬盘上。 例如，比方说你的样式表文件名为 style.css ，它通常被存放于名为style的目录中。可以像下面的方法一样引用： 12&lt;!-- 引用外部样式表 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" /&gt; 注意： 要在href属性里给出样式表文件的地址。 这行代码必须被插入 HTML 代码的头部（header），即放在标签 &lt;head&gt; 和标签 &lt;/head&gt; 之间。就像这样： 12345678&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;我的文档&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" /&gt;&lt;/head&gt;&lt;body&gt; .... 这个链接告诉浏览器：在显示该 HTML 文件时，应使用给出的 CSS 文件进行布局。 这种方法的优越之处在于：多个 HTML 文档可以同时引用一个样式表。换句话说，可以用一个 CSS 文件来控制多个 HTML 文档的布局。 CSS 书写方式之间的区别内嵌式写法： 代码可维护性较差，没有实现css代码与html结构的完全分离 影响的范围只有当前页面 行内是写法： 代码可维护性极差，css代码和html结构没有实现分离 影响的范围只有当前标签 外联式写法： 代码可维护性高，css与html结构完全分离 影响范围广，当前整个网页站点。 选择器选择器分类 基础选择器 标签选择器 类选择器 （⭐⭐⭐⭐⭐） id 选择器 通配符选择器 复合选择器 标签指定式选择器 （⭐⭐⭐⭐） 后代选择器 （⭐⭐⭐⭐⭐） 并集选择器 标签选择器标签：就是 html 中的标签 用法1234标签名&#123; 属性: 值; 属性: 值;&#125; 例如：12345678910111213141516171819&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标签选择器&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;!-- 设置 p 标签的样式 --&gt; p&#123; color: red; font-size: 25px; width: 200px; height: 50px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个p标签&lt;/p&gt;&lt;/body&gt; 补充颜色的显示方式： 直接设置对应颜色的名称 1color：red; 通过十六进制显示：以 # 开头，0-ff 1color: #2934de; 通过 rgb 方式显示：R：红色，0-255；G：绿色，0-255；B：蓝色，0-255 1color: rgb(4,255,20); 通过 rgba 显示：a 设置透明度（alpha），范围 0-1 1background-color: rgba(0,0,0,0.1); 类选择器（重点）用法123.自定义名称&#123; 属性: 值;&#125; 调用：标签通过 class 属性调用类样式。 1234567891011121314&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;类选择器&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;!-- 类样式的定义 --&gt; .fontcolor&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 调用类选择器 --&gt; &lt;p class=\"fontcolor\"&gt;类选择器例子&lt;/p&gt;&lt;/body&gt; 特点 谁调用谁改变，多个标签可以同时调用一个类样式 一个标签可以调用多个类样式（相当于人的名字） 例如：12&lt;!-- 调用多个类样式 --&gt;&lt;p class=\"fontcolor fontsize\"&gt;调用多个类样式&lt;/p&gt; 类的命名规范 不能以纯数字或者以数字开头定义类名 不推荐使用汉字定义类名 不能以特殊符号或者以特殊符号开头（“_”除外）定义类名 不建议使用标签名或者属性名定义类名 常用的命名： 中文 英文 头 header 内容 content/container 尾 footer 导航 nav 侧栏 sidebar 栏目 column 页面外围控制整体布局宽度 wrapper 左右中 left/right/center 登陆条 loginbar 标志 logo 广告 banner 页面主体 main 热点 hot 新闻 news 下载 download 子导航 subnav 菜单 menu 子菜单 submenu 搜索 search 友情链接 friendlink 页脚 footer 版权 copyright 滚动 scroll 内容 content id 选择器用法1234#id名称&#123; 属性: 值; ……&#125; 调用：通过 id 属性调用样式 1&lt;p id=\"p_color\"&gt;p1&lt;/p&gt; 特点 不建议多个标签使用同一 id 选择器的样式（id 和 js 配合使用） 一个标签只能调用一个 id 样式 通配符选择器用法1234*&#123; 属性: 值； ……&#125; 例如： 1234*&#123; color: red; font-size: 20px;&#125; 特点 将页面中的所有标签都选中，设置样式； 可以用来进行页面样式的初始化。 字体相关属性 属性 描述 color 设置文字颜色 font-size 设置文字大小 font-family 设置文字字体 font-weight 设置文字加粗 font-style 设置文字斜体 line-height 行高 font-family 直接设置汉字 123p&#123; font-family: 微软雅黑;&#125; 设置对应字体的英文 设置 unicode 编码 字体名称 英文名称 unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 microsoft yahei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 font-family 可以设置多个值： 123body&#123; font-family: \"SimSun\",\"Arial Narrow\",\"微软雅黑\",\"\\5B8B\\4F53\";&#125; font-weight取值方式： 直接设置数字，范围 100-900 bold (字体加粗) 效果为 700-900 normal(文字字体正常显示) 注意：文字加粗显示，推荐使用 font-weight:700; 1234567p&#123; font-weight: normal; &lt;!-- 文字加粗 --&gt; &lt;!-- font-weight: 900; --&gt; &lt;!-- font-weight: bold; --&gt;&#125; font-style italic：文字斜体显示 normal：文字正常显示 font 属性联写用法： 1font: font-style font-weight font-size/line-height font-family 例如： 123p&#123; font: italic 700 30px 宋体;&#125; 注意： font属性联写必须有 font-size 和 font-family （其他属性可以不写）； font-size 和 font-family 的 顺序不能换。 标签指定式选择器标签指定式选择器又称交集选择器，由两个选择器构成，其中第一个为标记选择器，第二个为 class 选择器或 id 选择器，两个选择器之间不能有空格。如： 123h1.one或h1#two 用法： 1234标签名.选择器名&#123; 属性:值; 属性:值;&#125; 特点关系： 既……又…… 实例： 1234567p.one&#123; color: yellow;&#125; */div#div1&#123; color: red;&#125; 后代选择器后代选择器用来选择元素或元素组的后代，其写法就是把外层标记写在前面，内层标记写在后面，中间用空格分隔。当标记发生嵌套时，内层标记就成为外层标记的后代。 用法： 1234选择器 + 空格 + 选择器&#123; 属性: 值； 属性: 值;&#125; 特点： 标签之间必须属于嵌套关系 选择器之间必须有空格 关系：父与子 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;style type=\"text/css\"&gt; /* p&#123; color: red; &#125; */ /* div p&#123; color: red; &#125; */ /* .one p&#123; color: red; &#125; */ p.one span&#123; color: red; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"one\"&gt; &lt;span&gt; 文字 &lt;/span&gt; &lt;/p&gt; &lt;p class=\"two\"&gt; &lt;span&gt; 文字 &lt;/span&gt; &lt;/p&gt; &lt;!-- &lt;div class=\"one\"&gt; &lt;p&gt; 幸福的p &lt;/p&gt; &lt;/div&gt; &lt;p&gt; 孤独的p &lt;/p&gt; --&gt;&lt;/body&gt; 并集选择器并集选择器是各个选择器通过逗号连接而成的，任何形式的选择器（包括标记选择器、class 类选择器、id 选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 用法： 1234选择器,选择器,选择器&#123; 属性: 值; ……&#125; 作用：将样式集体声明，css 样式初始化 特点：并集选择器之间必须用逗号隔开！ 123456789101112131415161718div,p,span&#123; color: red;&#125;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; div,p,span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;p&gt;567&lt;/p&gt; &lt;span&gt;asdf&lt;/span&gt;&lt;/body&gt; CSS 书写位置及 Html 标签分类CSS 书写位置外部样式表1&lt;link rel=”stylesheet” href=””&gt; 新建一个文件，后缀名以 .css 命名（css文件） 在 html 页面中通过 &lt;link rel=”stylesheet” href=””&gt; 标签将 css 文件引入. 例如： 123456&lt;head&gt; &lt;title&gt;外部样式表&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"1/1.css\"&gt;&lt;/head&gt;&lt;body&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 123456789&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内部样式表&lt;/title&gt; &lt;style type=\"text/css\"&gt; p &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; 内联样式表由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。 123&lt;body&gt; &lt;p style=\"color:red;font-size: 30px;font-family: 华文宋体;font-weight: 900;\"&gt;p中的文字&lt;/p&gt;&lt;/body&gt; CSS 书写方式之间的区别 内嵌式写法： ◆ 代码可维护性较差，没有实现 css 代码与 html 结构的完全分离 ◆ 影响的范围只有当前页面 行内式写法： ◆ 代码可维护性极差，css 代码和 html 结构没有实现分离 ◆ 影响的范围只有当前标签 外联式写法： ◆ 代码可维护性高，css 与 html 结构完全分离 ◆ 影响范围广，当前整个网页站点。 HTML 标签的分类块级标签例如： div,p,h1-h6,ul,li,dl,dt,dd 特点： 元素自己独占一行显示，不与其他元素待在同一行 可以设置宽度和高度 当嵌套一个块级元素，子元素如果不设置宽度，那么该子元素的宽度为父元素的宽度。 行级标签例如： a，span,strong,u 特点： 元素在一行上显示 不能直接设置宽度和高度 行内块元素例如： img,input,textarea 特点： 元素在一行上显示 可以设置宽度和高度 元素之间的转换123display:inline // 将元素转化为行内元素display:inline-block // 将元素转化行内块元素display:block // 将元素转化为块元素 实例： 1234567891011121314151617a&#123; width: 300px; height: 300px; background-color: red; /* display: inline-block; */ /* 将行内元素转化为行内块元素 */ display: block; /* 将行内元素转化为块元素 */&#125;div&#123; width: 300px; height: 300px; background-color: pink; /* 将行内元素转化为行内元素 */ display: inline;&#125; 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12","categories":[{"name":"HTML+CSS+JS","slug":"HTML-CSS-JS","permalink":"http://yoursite.com/categories/HTML-CSS-JS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML基础学习笔记","slug":"html-basic-learning-notes","date":"2017-08-22T06:17:00.000Z","updated":"2017-09-01T13:00:34.021Z","comments":true,"path":"posts/HTML-CSS-JS/2017-08-22-html-basic-learning-notes.html","link":"","permalink":"http://yoursite.com/posts/HTML-CSS-JS/2017-08-22-html-basic-learning-notes.html","excerpt":"自学 html 基础笔记。","text":"自学 html 基础笔记。 Web 前端简单介绍web 前端包含： pc 端页面 移动端页面 web 前端首先要解决用户体验的问题 认识网页网页的组成网页主要由文字、图片和按钮等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及 Flash 等。 Web 标准1：w3c 万维网联盟组织：用来制定 web 标准的机构（组织） 2：web 标准：制作网页要遵循的规范 3：web 标准规范的分类：结构标准；表现标准；行为标准 结构标准：html（用来制作网页的） 表现标准：css（对网页进行美化的） 行为标准：javascript（让网页动起来，具有生命力） 4：web 标准总结： 结构标准：相当于人的身体 表现标准：相当于人的衣服 行为标准：相当于人的动作 浏览器介绍浏览器是网页运行的平台，常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。 浏览器内核：也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内 ，容以及页面的格式信息。 IE Google/Opera FireFox Safari trident blink gecko webkit 浏览器与服务器1：浏览器向服务器发送请求（通过http协议） 2：http协议：超文本传输协议，也就是浏览器和服务器端的网页传输数据的约束和规范 3：https：加密处理 4：url协议:平时我们写的网址就是 url 地址 url协议：规定 url 地址的格式 协议规定格式： scheme://host.domain:port/path/filename scheme: 定义因特网服务的类型。常见的就是httphost: 定义域主机（http 的默认主机是www）domain: 定义因特网域名 比如：w3school.com.cn:port 定义端口号（网页默认端口 :80）path: 网页所在服务器上的路径filename: 文件名称 认识 html概念html (Hyper Text Markup Language ) 中文译为 超文本标记语言，主要是通过 html 标记对网页中的文本，图片，声音等内容进行描述。 HTML 之所以称为超文本标记语言，不仅是因为他通过标记描述网页内容，同时也由于文本中包含了所谓的 超级链接，通过超链接可以实现网页的跳转。从而构成了丰富多彩的 Web 页面。 html 结构基本结构如下：1234567&lt;! Doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 各部分的含义：12&lt;!-- 文档类型 --&gt;&lt;! Doctype html&gt; 12&lt;!-- 根标签 --&gt;&lt;html&gt;&lt;/html&gt; &lt;html&gt;&lt;/html&gt; 用于告知浏览器其自身是一个 HTML 文档，&lt;/html&gt; 标记标志着 HTML 文档的开始，&lt;/html&gt; 标记标志着 HTML 文档的结束，在他们之间的是文档的头部和主体内容。 12&lt;!-- &lt;html lang=\"en\"&gt; 向搜索引擎表示该页面是html语言，并且语言为英文网站 --&gt;&lt;html lang=\"en\"&gt; 这个主要是给搜索引擎看的，搜索引擎不会去判断该站点是中文站还是英文站，所以这句话就是让搜索引擎知道，你的站点是中文站，对 html 页面本身不会有影响。 12&lt;!-- html文档头部分 --&gt;&lt;head&gt;&lt;/head&gt; 主要用来封装其他位于文档头部的标记。一个 HTML 文档只能含有一对 &lt;head&gt; 标记，绝大多数文档头部包含的数据都不会真正作为内容显示在页面中。 12&lt;!-- 网页的标题 --&gt;&lt;title&gt;&lt;/title&gt; &lt;title&gt; 标记用于定义HTML页面的标题，&lt;title&gt;&lt;/title&gt; 之间的内容将显示在浏即给网页取一个名字，必须位于 &lt;head&gt; 标记之内。一个HTML文档只能含有一对 &lt;title&gt;&lt;/title&gt; 标记，将显示在浏览器窗口的标题栏中。 12&lt;!-- html结构的主体部分 --&gt;&lt;body&gt;&lt;/body&gt; &lt;body&gt; 标记用于定义 HTML 文档所要显示的内容，也称为主体标记。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于 &lt;body&gt; 标记内，&lt;body&gt; 标记中的信息才是最终展示给用户看的。一个HTML文档只能含有一对 &lt;body&gt; 标记，且 &lt;body&gt; 标记必须在 &lt;html&gt; 标记内，位于 &lt;head&gt; 头部标记之后。 标签的分类HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;； HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;； 标签对中的第一个标签是开始标签，第二个标签是结束标签； 开始和结束标签也被称为开放标签和闭合标签； HTML标记—双标记双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：123&lt;标记名&gt;&lt;/标记名&gt;&lt;!-- 例如： --&gt;&lt;body&gt;&lt;/body&gt; 该语法中 &lt;标记名&gt; 表示该标记的作用开始，一般称为 开始标记（start tag），&lt;/标记名&gt; 表示该标记的作用结束，一般称为 结束标记（end tag）。和开始标记相比，结束标记只是在前面加了一个关闭符 /。 HTML标记—单标记单标记也称空标记，只有开始标签没有结束标签：123&lt;标记名&gt;&lt;!-- 例如： --&gt;&lt;! doctype html&gt; 标签关系 嵌套关系：类似父亲和儿子之间的关系 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 并列关系：类似与兄弟之间的关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; html 标签介绍单标签文本注释标签1&lt;!-- 文本注释标签 Ctrl+/ --&gt; 文本换行标签1你好&lt;br&gt;我来自中国 效果演示：你好我来自中国 横线标签1&lt;hr&gt; 效果演示： 双标签段落标签12&lt;p&gt;这是一行文字&lt;/p&gt;&lt;p&gt;这也是一行文字&lt;/p&gt; 效果演示：这是一行文字这也是一行文字 标题标签 注意：标题标签只能取到数字 1-6 123456&lt;h1&gt;这是一个标题1&lt;/h1&gt;&lt;h2&gt;这是一个标题2&lt;/h2&gt;&lt;h3&gt;这是一个标题3&lt;/h3&gt;&lt;h4&gt;这是一个标题4&lt;/h4&gt;&lt;h5&gt;这是一个标题5&lt;/h5&gt;&lt;h6&gt;这是一个标题6&lt;/h6&gt; 文本标签1&lt;font&gt;&lt;/font&gt; 例如：1&lt;font size=\"10\" color=\"red\"&gt;优美的文字&lt;/font&gt; 效果演示： 优美的文字 文本格式化标签文字加粗显示1&lt;strong&gt;该减肥了！&lt;/strong&gt; 效果演示：该减肥了！ 文字斜体1&lt;em&gt;这行字是斜的&lt;/em&gt; 效果演示：这行字是斜的 文字下横线12&lt;ins&gt;文字下横线&lt;/ins&gt;&lt;u&gt;文字下横线&lt;/u&gt; 效果演示：文字下横线文字下横线 文字删除线12&lt;del&gt;删除线&lt;/del&gt;&lt;s&gt;删除线&lt;/s&gt; 效果演示：删除线删除线 图片标签1&lt;img&gt; 属性 描述 src 设置显示图片（图片名称或者图片路径） title 用来设置鼠标放在图片上显示的文字 alt 当图片无法正常显示的时候，对图片的描述 width 用来设置图片宽度 height 用来设置图片的高度 12&lt;!-- 下图来自百度图片 --&gt;&lt;img src=\"www.baidu.com/imags/1.png\" title=\"HTML\" alt=\"测试图片\" width=\"200\" height=\"200\"&gt; 效果演示： 相对路径 当图片和文件（html）在同一个文件夹中时，src 属性中直接写上图片名称即可。 1&lt;img src=\"1.jpg\"&gt; 当图片在文件（html）的下一级目录中时，src 属性中写上图片所在的文件夹名 +“/” + 图片名称 1&lt;img src=\"1/1.jpg\"&gt; 当图片在文件（html）的上一级目录中时，src 属性中写上 ../图片所在文件夹名 + “/” + 图片名称 1&lt;img src=\"../2/1.jpg\"&gt; 绝对路径凡是带有 磁盘路径 的都是绝对路径，或者带有 网站地址 的也是绝对路径。 12&lt;img src=\"D:\\a\\1.png\"&gt;&lt;img src=\"www.baidu.com/imags/1.png\"&gt; 超链接在HTML中创建超链接非常简单，只需用 &lt;a&gt;&lt;/a&gt; 标记环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt; 属性 描述 href 用于指定链接目标的 url 地址，当为 &lt;a&gt; 标记应用 href 属性时，它就具有了超链接的功能。 target 用于指定链接页面的打开方式，其取值有 _self 和 _blank 两种，其中 _self 为默认值， _blank 为在新窗口中打开方式。 在 &lt;head&gt; 标签中使用 &lt;base&gt; 标签可以设置网页整体链接的打开状态。 123&lt;head&gt; &lt;base target=\"_blank\"&gt;&lt;/head&gt; 实例：12&lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.renkaigis.com\" target=\"_blank\"&gt;Kai's Blog&lt;/a&gt; 效果演示：百度Kai’s Blog 注意: （1）暂时没有确定链接目标时，通常将 &lt;a&gt; 标记的 href 属性值定义为“#”(即 href=&quot;#&quot; )，表示该链接暂时为一个空链接。 （2）不仅可以创建文本超链接，在网页中各种网页元素，如 图像、表格、音频、视频 等都可以添加超链接。 锚链接通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 使用 “ &lt;a href=&quot;#id名&quot;&gt; 链接文本 &lt;/a&gt; ” 创建链接文本； 使用相应的 id 名标注跳转目标的位置。 12345&lt;!-- 例如在网页顶部写个你好 --&gt;&lt;p id=\"db\"&gt;你好&lt;/p&gt;&lt;!-- 给 a 标签设置 href 属性 \"#id名称\" --&gt;&lt;a href=\"#db\"&gt;返回顶部&lt;/a&gt; 效果演示： 你好返回顶部 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方（上标2） &amp;sup2; ³ 立方（上标3） &amp;sup3; 列表无序列表（ul）12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; 列表项 &lt;li&gt;&lt;/li&gt; ......&lt;/ul&gt; 例如：12345678大家喜欢吃什么水果&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;水蜜桃&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt;&lt;/ul&gt; 效果演示：大家喜欢吃什么水果苹果香蕉菠萝 属性：type （默认值）实心圆点：disc 实心方块：square 空心圆圈：circle 实例：123456789101112&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type=\"square\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type=\"circle\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 有序列表（ol）1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 属性：type A（ABCD排序），a（abcd排序），i（小写的罗马数字），I（大写的罗马数字） 属性：start=”3”，表示从第几个数开始 123456把大象放冰箱分几步？&lt;ol type=\"a\" start=\"3\"&gt; &lt;li&gt;打开冰箱门&lt;/li&gt; &lt;li&gt;把大象放进去&lt;/li&gt; &lt;li&gt;关上冰箱门&lt;/li&gt;&lt;/ol&gt; 效果演示： 把大象放冰箱分几步？打开冰箱门把大象放进去关上冰箱门 自定义列表（dl）自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; 小标题 &lt;dd&gt;&lt;/dd&gt; 列表项 &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 一般用于网页的底部，例如：1234567&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;售后服务&lt;/dt&gt; &lt;dd&gt;收货地址&lt;/dd&gt; &lt;dd&gt;在线支付&lt;/dd&gt; &lt;dd&gt;联系客服&lt;/dd&gt;&lt;/dl&gt; 效果演示： 售后服务收货地址在线支付联系客服 小补充页面背景音乐1&lt;embed src=\"1.mp3\" hidden=\"true\"&gt; 属性： src：设置音乐路径 hidden：隐藏播放按钮，true 隐藏，false 显示 页面滚动效果1234&lt;!-- 中间的内容可以为 文字、图片，也可以是由程序生成的文字或图片 --&gt;&lt;marquee&gt; ...&lt;/marquee&gt; 实例展示： 1&lt;marquee bgcolor=\"blue\" &gt;我会滚动&lt;/marquee&gt; 效果演示： 我会滚动 属性 描述 height 设置高度 width 设置宽度 bgcolor 设置背景颜色 behavior 设定滚动的方式：alternate：表示在两端之间来回滚动；scroll：表示由一端滚动到另一端，会重复；slide：表示由一端滚动到另一端，不会重复。 direction 设定滚动的时间：down：向下滚动；left：向左滚动；right：向右滚动；up：向上滚动。 loop 设置滚动次数，-1 表示一直滚下去 Meta标签和Link标签Meta 标签meta 的属性有两种：name 和 http-equiv。 name 属性主要用于描述网页，对应于 content（网页内容）。 1、用来说明网页使用的字符集，即编码格式 1&lt;meta charset=\"utf-8\"&gt; 2、用以说明生成工具（如Microsoft FrontPage 4.0）等； 1&lt;meta name=\"generator\" contect=\"\"&gt; 3、向搜索引擎说明你的网页的关键词； 1&lt;meta name=\"keywords\" contect=\"\"&gt; 4、告诉搜索引擎你的站点的主要内容； 1&lt;meta name=\"description\" contect=\"\"&gt; 5、告诉搜索引擎你的站点的制作的作者； 1&lt;meta name=\"author\" contect=\"你的姓名\"&gt; 6、有时候会有一些站点内容，不希望被ROBOTS抓取而公开。为了解决这个问题，ROBOTS开发界提供了两个办法：一个是robots.txt，另一个是 The Robots META 标签。 1&lt;meta name=\"robots\" contect= \"all|none|index|noindex|follow|nofollow\"&gt; robots 其中的属性说明如下： 设定为 all：文件将被检索，且页面上的链接可以被查询； 设定为 none：文件将不被检索，且页面上的链接不可以被查询； 设定为 index：文件将被检索； 设定为 follow：页面上的链接可以被查询； 设定为 noindex：文件将不被检索，但页面上的链接可以被查询； 设定为 nofollow`：文件将不被检索，页面上的链接可以被查询。 http-equiv 属性1&lt;meta http-equiv=\"refresh\" content=\"5;url=http://www.baidu.com\" /&gt; 网页重定向，表示的是 5 秒后网页自动跳转到指定网址。 Link 标签1&lt;link rel=\"icon\" href=\"favicon.ico\"&gt; 给网页 titile 中放置小图标1&lt;link rel=\"stylesheet\" href=\"1.css\"&gt; 引入外部样式表 表格（table）表格基本结构在 HTML 语言中，表格至少由 &lt;TABLE&gt; 标签、&lt;TR&gt; 标签和 &lt;TD&gt; 标签这 3 对标签组成。 1.&lt;table&gt;&lt;table&gt;...&lt;/table&gt; 标签用于在HTML文档中创建表格。它包含表名和表格本身内容的代码。表格的基本单元是单元格，用 &lt;td&gt;...&lt;/td&gt; 标签定义。 2.&lt;tr&gt;表格行用 &lt;tr&gt; 标签定义，由单元格构成。多个行结合在一起就构成一个表格，这反映在用于创建表格的HTML语法中。表格的每一行都用 &lt;tr&gt; 标签表示，并用相应的 &lt;/tr&gt; 结束. 3.&lt;td&gt;表格的每一行又有若干表格单元格，用 &lt;td&gt;...&lt;/td&gt; 标签表示。td 是”表格数据(Table Data)”的英文缩写。&lt;td&gt; 标签定义一个列，嵌套于 &lt;tr&gt; 标签内。border 属性是最常用的属性，可用于定义表格的单元格和结构。该属性指定边框的厚度，如果其值设置为零(0)，则不显示边框。 基本语法：12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;职业&lt;/td&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 属性介绍： bord：设置表格边框的厚度 width：设置表格宽度 height：设置表格高度 cellspacing：设置单元格之间的距离 cellpadding：文字距离单元格边框的距离 bgcolor=”red”：设置背景颜色 align=”center” | left | right：给 tr 或者 td 设置让文字居中，给 table 设置让表格居中 属性名 含义 常用属性值 border 设置边框，默认为0，没有边框 单位为 px 像素值 cellspacing 设置单元格与单元格之间的距离 单位为 px 像素值，默认为 2px cellpadding 设置文字与单元格之间的距离 默认 1px width 设置表格的宽度 单位 px height 设置表格的高度 单位 px align 设置表格在网页中的对其方式 left 左rigth 右center 居中 bgcolor 设置背景颜色 white，red，green等 设置表格表头，用法和 td 一样表头一般位于表格的第一行或第一列，其文本加粗居中。1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18码农江苏 表格属性设置示例：1234567891011121314&lt;table border=\"1\" width=\"200\" height=\"300\" cellspacing=\"0\" cellpadding=\"20\" bgcolor=\"red\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示：（本应整个表格都是 bgcolor 的，这里显示有问题） 姓名年龄职业籍贯小明18码农江苏 设置表格标题：caption 标签必须紧随 table 标签之后。只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。12345678910111213141516&lt;table&gt; &lt;!-- 设置表格标题 --&gt; &lt;caption&gt; &lt;h3&gt;人员信息表&lt;/h3&gt;&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 人员信息表姓名年龄职业籍贯小明18码农江苏 表格结构12345&lt;table&gt; &lt;thead&gt;&lt;/thead&gt; 头 &lt;tbody&gt;&lt;/tbody&gt; 身体 &lt;tfoot&gt;&lt;/tfoot&gt; 脚&lt;/table&gt; 在使用表格进行布局时，可以将表格划分为头部、主体和页脚，具体如下所示： &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部，必须位于 &lt;table&gt;&lt;/table&gt; 标记中，一般包含网页的logo和导航等头部信息。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;thead&gt;&lt;/thead&gt; 标记之后，一般包含网页中除头部和底部之外的其他内容。 &lt;tfoot&gt;&lt;/tfoot&gt;：用于定义表格的页脚，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;tbody&gt;&lt;/tbody&gt; 标记之后，一般包含网页底部的企业信息等。 补充知识：单元格的合并横向合并12345&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415&lt;!-- 实例展示 --&gt;&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"20\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan=\"2\"&gt;年龄&lt;/th&gt; &lt;!--&lt;th&gt;职业&lt;/th&gt;--&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄籍贯小明18码农江苏 纵向合并12345678910&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;!--&lt;td&gt;&lt;/td&gt;--&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415161718192021&lt;!-- 实例展示 --&gt;&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"20\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td rowspan=\"2\"&gt;码农&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;!--&lt;td&gt;前端&lt;/td&gt;--&gt; &lt;td&gt;北京&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18程序猿江苏小白21北京 表单（form）表单介绍表单的作用：主要负责数据采集功能。 对于表单构成中的表单控件、提示信息和表单域，对他们的具体解释如下： 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 基本语法：1&lt;form name=\"form_name\" action=\"url\" method=\"get|post\"&gt;…&lt;/form&gt; 属性介绍： Name ：定义表单的名称； Action ：用来指定表单处理程序的位置（服务器端脚本处理程序）； Method: 定义表单结果从浏览器传送到服务器的方式，默认参数为：get。 get数据提交：① 通过地址栏的方式进行数据提交，将用户输入的信息显出来；② get提交安全性差。 post提交：① 数据通过后台进行提交，不会将用户信息显示出来；② 安全性比较好。 表单域123&lt;form action=\"\"&gt; …&lt;/form&gt; 容纳表单空间和提示信息的一个区域。 表单控件input 控件语法：1&lt;input type=“控件类型”&gt; 在上面的语法中，&lt;input&gt; 标记为单标记，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input&gt; 标记还可以定义很多其他的属性，其常用属性如下表所示。 属性 属性值 描述 type textpasswordradiocheckboxbuttonsubmitresetimagehiddenfile 单行文本输入框密码输入框单选按钮复选框普通按钮提交按钮重置按钮图像形式的提交按钮隐藏域文件域 name 由用户自定义 控件的名称 value 由用户自定义 input 控件中的默认文本值 size 正整数 input 控件在页面中的显示宽度 readonly readonly 该控件内容为只读（不能编辑修改） disabled disabled 第一次加载页面时禁用该控件（显示为灰色） 文本输入框12&lt;!-- 文本输入框 --&gt;用户名：&lt;input type=\"text\" maxlength=\"6\" name=\"username\" value=\"1234\" &gt; 效果演示：用户名： 属性: maxlength：设置文本输入框最多能输多少字符 readonly=”readonly”：设置文本输入框为只读（不能编辑） disabled+”disabled”：控件属于非激活状态 name=”username”：给输入框设置名称 value：设置默认显示的值 密码输入框12&lt;!-- 密码输入框 --&gt;密码：&lt;input type=\"password\" name=\"pwd\" value=\"123\"&gt; 效果演示：密码： 属性用法与文本输入框的用法一样。 单选按钮1234&lt;!-- 单选按钮 --&gt;性别：&lt;input type=\"radio\" name=\"xb\" checked=\"checked\" value=\"nan\"&gt;男&lt;input type=\"radio\" name=\"xb\" value=\"nv\" &gt;女 效果演示：性别：男 女 注意：实现单选效果一定要给控件设置相同的名称 属性： checked=”checked”：设置默认选中项 多选控件1234兴趣爱好：&lt;input type=\"checkbox\" checked=\"checked\"&gt;抽烟&lt;input type=\"checkbox\" checked=\"checked\"&gt;喝酒&lt;input type=\"checkbox\" checked=\"checked\"&gt;烫头 效果演示：兴趣爱好：抽烟喝酒烫头 属性： checked=”checked”：设置默认选中项 图片上传控件12头像：&lt;input type=\"file\"&gt; 效果演示：头像： 表单提交按钮12&lt;!-- 表单提交按钮 --&gt;&lt;input type=\"submit\" value=\"登录\"&gt; 效果演示： 普通按钮12&lt;!-- 普通按钮 --&gt;&lt;input type=\"button\" value=\"普通按钮\"&gt; 效果演示： 注意：该按钮不能进行表单提交。通常和 js 代码配合使用。 重置按钮清空所有表单数据，恢复到初始状态12&lt;!-- 重置按钮 --&gt;&lt;input type=\"reset\"&gt; 效果演示： 图片按钮12&lt;!-- 图片按钮 --&gt;&lt;input type=\"image\" src=\"按钮.jpg\"&gt; 注意：该控件也可以进行表单的提交。 select 控件在 HTML 中，要想制作下拉菜单，就需要使用select控件。 下拉列表123456789出生地：省：&lt;select multiple=\"multiple\"&gt; &lt;option&gt;山东&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;option&gt;河南&lt;/option&gt; &lt;option&gt;河北&lt;/option&gt; &lt;option selected=\"selected\"&gt;北京&lt;/option&gt;&lt;/select&gt; 效果演示：出生地：省： 山东 山西 河南 河北 北京 属性： selected=”selected”：设置默认选中项 multiple=”multiple”：可以实现多选效果 下拉列表分组显示123456789101112131415市(区)：&lt;select id=\"name\"&gt; &lt;optgroup label=\"北京市\"&gt; &lt;option&gt;西城区 &lt;/option&gt; &lt;option&gt;东城区&lt;/option&gt; &lt;option&gt;海淀区&lt;/option&gt; &lt;option&gt;昌平区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"上海市\"&gt; &lt;option&gt;黄浦区 &lt;/option&gt; &lt;option&gt;松江区&lt;/option&gt; &lt;option&gt;浦东新区&lt;/option&gt; &lt;option&gt;静安区&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 效果演示：市(区)： 西城区 东城区 海淀区 昌平区 黄浦区 松江区 浦东新区 静安区 textarea 控件如果需要输入大量的信息，就需要用到 &lt;textarea&gt;&lt;/textarea&gt; 标记。通过 textarea 控件可以轻松地创建多行文本输入框，其基本语法格式如下：123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 文本内容&lt;/textarea&gt; 属性： cols：相当于宽度 rows：相当于高度 123自我介绍：&lt;textarea cols=\"20\" rows=\"5\"&gt;&lt;/textarea&gt; 效果演示：自我介绍： 组合表单fieldset 用于表单分组。语法：123&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt;&lt;/fieldset&gt; 举例：1234567&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; 用户名：&lt;input type=\"text\" maxlength=\"6\" name=\"username\" value=\"\" &gt; &lt;br&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"pwd\" value=\"123\"&gt;&lt;/fieldset&gt; 效果演示： 用户注册 用户名： 密码： 表单补充判断网址123&lt;!-- 判断网址 --&gt;&lt;input type=\"url\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 判断邮箱123&lt;!-- 判断邮箱 --&gt;&lt;input type=\"email\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 日期控件123&lt;!-- 日期控件 --&gt;&lt;input type=\"date\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 时间控件123&lt;!-- 时间控件 --&gt;&lt;input type=\"time\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 带有 spinner 控件的数字字段123&lt;!-- 带有 spinner 控件的数字字段 --&gt;&lt;input type=\"number\"&gt;&lt;input type=\"submit\"&gt; 属性： step：表示每次加减的值（即步长） 效果演示： 带有 slider 控件的数字字段123&lt;!-- 带有 slider 控件的数字字段 --&gt;&lt;input type=\"range\"&gt;&lt;input type=\"submit\"&gt; 属性： max：最大值 min：最小值 step：每次加减的值（即步长） 效果演示： 定义拾色器123&lt;!-- 定义拾色器 --&gt;&lt;input type=\"color\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 标签语义化 标签语义化概念： 根据内容的结构化（内容语义化），选择合适的标签（代码语义化） 标签语义化意义： 1: 网页结构合理 2: 有利于 SEO :和搜索引擎建立良好沟通，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取； 3: 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）; 4: 便于团队开发和维护. 标签语义化（注意事项） 1：尽可能少的使用无语义的标签 div 和 span ； 2：在语义不明显时，既可以使用 div 或者 p 时，尽量用 p, 因为 p 在默认情况下有上下间距，对兼容特殊终端有利； 3：不要使用纯样式标签，如：b、font、u 等，改用 css 设置。 4：需要强调的文本，可以包含在 strong 或者 em 标签中。strong 默认样式是加粗（不要用b），em 是斜体（不用 i ）； 总结我的 html 基础学习是跟着传智播客2016年的视频课程学习的，基础就这些内容，特别整理下来以加深记忆。内容或多或少会与网络上的内容有些许出入。总的来说 html 很简单，很容易上手。但这只是基础，html + css + javascript 才能做出真正漂亮的网页。 千里之行，始于足下，接下来的路，加油！","categories":[{"name":"HTML+CSS+JS","slug":"HTML-CSS-JS","permalink":"http://yoursite.com/categories/HTML-CSS-JS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"观建军90周年阅兵之感悟","slug":"view-of-army-building-90th","date":"2017-07-30T05:45:20.000Z","updated":"2017-08-24T14:46:36.865Z","comments":true,"path":"posts/Mine/2017-07-30-view-of-army-building-90th.html","link":"","permalink":"http://yoursite.com/posts/Mine/2017-07-30-view-of-army-building-90th.html","excerpt":"恰逢 中国人民解放军建军 90 周年 ，下一个百年会是什么样的盛况？十年后的今天，肯定特别隆重，中国军队更加现代化，中国的综合实力更加强胜。2017 年 7 月 30 日，一个小阅兵式，不比 2015 年的 9.3 阅兵，但也足以展示中国军队的强势！","text":"恰逢 中国人民解放军建军 90 周年 ，下一个百年会是什么样的盛况？十年后的今天，肯定特别隆重，中国军队更加现代化，中国的综合实力更加强胜。2017 年 7 月 30 日，一个小阅兵式，不比 2015 年的 9.3 阅兵，但也足以展示中国军队的强势！ 2017 年 7 月 30 日 9 时，在朱日和训练基地隆重举行了庆祝建军 90 周年阅兵式。中共中央总书记、国家主席、中央军委主席习近平检阅部队并发表重要讲话。 政治觉悟强、思想素质高的我专门观看了这场直播。看的真是个热血沸腾！尤其是国歌响起的时候，看到我们的军队气势如虹，中国已经不是以前的模样了！她那么年轻，又那么富有活力，最重要的是有一群铁骨铮铮的人的在守卫着她的每一寸土地和国民。 从 1927 到 2017 ，中国军队走过了漫长的岁月，中国军队日益强大。车牌 1927 和 2017 相互对接，是一种历史的传承。 《国歌》 国歌响起的刹那，热泪盈眶。每一个中国人都熟悉的一首歌，竟这样好听。习大大在主席台上也跟着音乐在哼唱着。 《检阅进行曲》 习大大身着迷彩登上车牌 2017 的野战车的时候，《检阅进行曲》响起，一排排列队整齐的军队，一辆辆现代化的作战车辆，一架架直升机、空中梯队，严阵以待，等待着党和人民的检阅。 《分列式进行曲》 这就是我们的军队，这是人民的军队。 时至今日，兔子们已经把种花家变成了蓝星最牛的堂口之一，他走过骨血硝烟，走过繁花似锦，曾跌入泥潭，也能踏上云端。 每一只兔子都有一个大国梦。今生不悔入华夏，来世还愿种花家。 『 幸福并感激着！ 』","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Chrome 浏览器设置 XX-Net 的方法（Windows）","slug":"method-setup-XX-Net-Chrome-Windows","date":"2017-07-27T02:11:01.000Z","updated":"2017-08-26T13:40:25.860Z","comments":true,"path":"posts/Chrome/2017-07-27-method-setup-XX-Net-Chrome-Windows.html","link":"","permalink":"http://yoursite.com/posts/Chrome/2017-07-27-method-setup-XX-Net-Chrome-Windows.html","excerpt":"本文详细介绍如何在一台 Windows 电脑上架设起 Chrome + XX-Net 的上网渠道。XX-Net 对于需要翻墙的用户来说非常方便。尤其是配置了自己的私有 appid 后，浏览外网毫无压力。在整个部署过程中可能有部分网页需要翻墙才可以进入，可以暂时使用 Lantern 进行翻墙。Lantern 下载地址：&nbsp;&nbsp;Download Now","text":"本文详细介绍如何在一台 Windows 电脑上架设起 Chrome + XX-Net 的上网渠道。XX-Net 对于需要翻墙的用户来说非常方便。尤其是配置了自己的私有 appid 后，浏览外网毫无压力。在整个部署过程中可能有部分网页需要翻墙才可以进入，可以暂时使用 Lantern 进行翻墙。Lantern 下载地址：&nbsp;&nbsp;Download Now 下载安装 Chrome 浏览器 Chrome 下载地址：https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html这一步很简单，直接跳过。 获取和运行 XX-Net 打开链接，选择稳定版下载。https://github.com/XX-net/XX-Net/blob/master/code/default/download.md 下载完毕后解压缩文件夹，运行文件夹中 start.vbs 文件。 如果弹出管理员权限请求（用户账户控制），请允许。 首次运行可能会弹出防火墙警告，请允许访问。 设置代理方法一：简单方法 启动 XX-Net 后，右下角会出现托盘图标。右键单击托盘图标，点击“全局 PAC 智能代理”即可。 方法二：安装和使用代理切换插件 打开 XX-Net/SwitchyOmega 文件夹；打开 Chrome 浏览器的扩展程序页面 chrome://extensions 。把 SwitchyOmega.crx 文件拖放到浏览器扩展程序页面安装。如图: 此时。浏览器上方会出现对话框，点击添加扩展程序。 进入 SwitchOmega 页面，第一次进来，选择跳过教程； 点击界面左侧栏的导入/导出，选择从备份文件恢复： 点击从备份文件中恢复后，找到 XX-Net/SwitchyOmega/OmegaOptions.bak 文件，点击打开： 点击左侧栏“情景模式”下的 XX-Net自动切换； 下拉点击立即更新情景模式 点击 Chrome 右上角的 SwitchOmega，切换成 “XX-Net自动切换”； 到此，浏览器端设置代理也就完成了，还需最后一步，把 XX-Net 切换为“取消全局代理”，就可以畅游网络了。 但是此时用的是 公共 APPID，因为资源有限，使用上存在限制，建议部署私有 APPID。 配置个人 APPID登录 Google 账户 https://www.google.com/ncr (若无帐户，需注册) 创建 APPID 打开 https://console.cloud.google.com/start ，点击选择项目，然后点击创建项目： 输入项目名称后，会自动帮你匹配可用ID，然后左击创建(请细读此教程底部说明) 设置 APPID 的 App 引擎 点击激活 Google云端Shell，点击启动云端SHELL进入Shell； 在页面底部输入 gcloud config set project 项目ID,按下键盘的enter键； 然后输入 gcloud beta app create --region us-central ，再按一次enter； 当底部出现 Success! The app is now created. Please use &#39;gcloud app deploy&#39; to deploy your first app. 时，创建 appid 成功。此时可以重复前面两步，创建更多的 appid； 部署服务器端 打开 XX-Net 的设置页：http://127.0.0.1:8085 ，切换到部署服务端； 输入AppID（多个APPID中间使用 | 隔开），“Show Debug Log”选择为 On ，点击 开始部署 ； 弹出授权窗口，点击 Allow（允许），然后就会进行服务端的部署； 日志 里面显示如下信息，则说明部署完成； 部署完成后，切换到 配置 ，输入部署好的 APPID 后点击 保存。 切换到 状态 来确认部署的状态，如果一切正常，那么恭喜你，现在可以流畅的翻墙喽~~~ 说明 每个 AppID 每天1G流量，一般每个 Google 帐户最多12个 AppID； AppID 的数量只影响流量，不影响速度； 若部署过程中始终无法弹出窗口 , 建议使用ss部署服务端； 若部署一直失败，可以安装 Google Cloud SDK，gcloud init 设置代理，gcloud app deploy 上传 gae 文件夹，在 app.yaml 中不要指定 application 和 version。","categories":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"},{"name":"XX-Net","slug":"XX-Net","permalink":"http://yoursite.com/tags/XX-Net/"}]},{"title":"ArcGIS Engine 地图操作基础——地图文档保存","slug":"ArcGIS-Engine-map-basic-save-documents","date":"2017-06-13T13:15:30.000Z","updated":"2017-08-24T05:55:16.087Z","comments":true,"path":"posts/ArcGIS/2017-06-13-ArcGIS-Engine-map-basic-save-documents.html","link":"","permalink":"http://yoursite.com/posts/ArcGIS/2017-06-13-ArcGIS-Engine-map-basic-save-documents.html","excerpt":"在对地图文档进行修改后，经常需要对其进行保存。地图文档的保存分为直接保存和另存为两种。这里的保存仅仅只是修改地图文档文件记录的信息，并不会对数据进行更改。保存地图文档的一般格式是 *.mxd 格式。","text":"在对地图文档进行修改后，经常需要对其进行保存。地图文档的保存分为直接保存和另存为两种。这里的保存仅仅只是修改地图文档文件记录的信息，并不会对数据进行更改。保存地图文档的一般格式是 *.mxd 格式。 地图文档保存实例程序实现思路 (1) 地图文档的保存主要使用 IMapDocument 接口。首先使用 IMxdContents 接口读取已打开地图文档的内容，并使之替换 IMapDocument 接口的实例对象。 (2) 保存时使用 IMapDocument 接口的 Save 方法，函数原型为 public void Save(bool bUseRelativePaths, bool bCreateThumnbail) 参数 描述 bUseRelativePaths 是否保存为相对路径（区别于绝对路径） bCreateThumnbail 表示保存的地图在 ArcCatalog 中查看时是否显示缩略图 1234567891011121314151617181920212223242526272829303132333435363738394041424344//保存地图private void SaveMap_Click(object sender, EventArgs e)&#123; try &#123; string sMxdFileName = mainMapControl.DocumentFilename; IMapDocument pMapDocument = new MapDocumentClass(); if (sMxdFileName!=null &amp;&amp; mainMapControl.CheckMxFile(sMxdFileName)) &#123; if (pMapDocument.get_IsReadOnly(sMxdFileName)) &#123; MessageBox.Show(\"本地图文档是只读的，不能保存!\"); pMapDocument.Close(); return; &#125; &#125; else &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = \"请选择保存路径\"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = \"ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt\"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; sMxdFileName = pSaveFileDialog.FileName; &#125; else &#123; return; &#125; &#125; pMapDocument.New(sMxdFileName); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(pMapDocument.UsesRelativePaths, true); pMapDocument.Close(); MessageBox.Show(\"保存地图文档成功!\"); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125;&#125; 地图文档另存为实例程序实现思路 (1) 地图文档的另存为与保存的方法类似，保存前需判断保存的路径里是否存在相同的文件； (2) 另存为需要用 IMapDocument 接口的 New 方法创建新的路径。 123456789101112131415161718192021222324252627282930//地图另存为private void btnSaveAsMap_Click(object sender, EventArgs e)&#123; try &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = \"另存为\"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = \"ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt\"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; string sFilePath = pSaveFileDialog.FileName; IMapDocument pMapDocument = new MapDocumentClass(); pMapDocument.New(sFilePath); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(true, true); pMapDocument.Close(); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; //也可以使用 ArcGIS Engine 中封装好的类库资源 ControlsSaveAsDocCommandClass 实现地图文档的另存为： //ICommand command = new ControlsSaveAsDocCommandClass(); //command.OnCreate(mainMapControl.Object); //command.OnClick();&#125;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"Hexo+Github 搭建个人博客（小白版图文教程）","slug":"Hexo-Github-build-blog-so-easy","date":"2017-06-09T15:13:15.000Z","updated":"2017-11-20T02:33:27.406Z","comments":true,"path":"posts/Github/Hexo/2017-06-09-Hexo-Github-build-blog-so-easy.html","link":"","permalink":"http://yoursite.com/posts/Github/Hexo/2017-06-09-Hexo-Github-build-blog-so-easy.html","excerpt":"本人技术小白，折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了个人博客。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。有过经历，才知道好的教程的重要性。因而我将自己的经验分享出来~","text":"本人技术小白，折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了个人博客。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。有过经历，才知道好的教程的重要性。因而我将自己的经验分享出来~ 写在前面最近兴趣使然，想要搭建一个个人博客。每次看到别人拥有自己的个人主页都特别羡慕，一直想着自己有一个博客该有多好啊。就这样折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。由于自己是技术小白，很多大神写的教程看了依旧操作错误。多么希望有人能手把手的教你每一步做什么。有过经历，才知道好的教程的重要性。因而我将自己建站的步骤详细记录下来，以供参考。希望后面想要建站的人不要走弯路了哦~ 搭建环境配置 Node.js 环境下载 Node.js 安装文件，根据自己电脑的位数，选择下载32位或者64位的：http://nodejs.cn/download/然后安装下载的文件，保持默认设置就好了，一路点 Next ，很快就安装完成了。接着检查一下 Node 是否安装好，打开运行窗口，输入 cmd ，打开命令行： 在命令行分别输入以下命令：12node -vnpm -v 如果出现下图界面，则说明 node 安装正确。可以进入下一步了。 配置 Git 环境去官网下载 Git 安装文件: https://git-scm.com/downloads 接着进行安装，如下图，在 Windows Explorer integration 这一项及下边的两项都打上勾： 然后一直 Next 就可以了，安装完成后同样检查一下 Git 是否正确安装。 Github账户的注册和代码库的创建Github帐号注册，打开链接：https://github.com/，申请一个 Github 帐号；注册好之后还需要确认邮箱，打开注册的邮箱，确认注册，然后进入下一步；点击页面右上角自己的头像，点击下拉菜单的New repository，创建一个新的代码库：代码库的名字最好与你的用户名相同，格式为 yourname.github.io ，比如我的用户名是 renkaitest，那我的代码库名即为 renkaitest.github.io创建成功后出现下图所示界面，点击右边的复制按钮，复制这个地址： 配置 Github pages随便找一个目录，右击鼠标，选择Git Bash Here，打开一个类似命令行的界面，输入以下代码：1$ git clone https://github.com/username/username.github.io clone 后面的链接即就是上一步复制的那个链接，比如我的就是下面的代码： 1$ git clone https://github.com/renkaitest/renkaitest.github.io 然后输入 cd 你的代码库名 ，例如 cd renkaitest.github.io ，也可以直接进入该目录下的一个名为 renkaitest.github.io 的文件夹。1$ cd renkaitest.github.io 然后输入： 1$ echo \"Hello World\" &gt; index.html 接着输入：12$ git add --all$ git commit -m \"Initial commit\" 这里会出现一个错误，是因为我们没有设置Git的 user name 和 email ，此时输入以下代码： 12$ git config --global user.email \"541638321@qq.com\"$ git config --global user.name \"renkaitest\" 注意：上面的 name 和 email 都要换成自己的邮箱和用户名 此时继续执行以下代码： 1$ git commit -m \"Initial commit\" 下面 push 到你的代码库，输入代码：1$ git push -u origin master 可能会弹出以下界面让你登录，使用 Github 帐号登录即可。 此时你的 Github Pages 已经配置好了，打开 yourname.github,io 这个网址就能看到你的博客了，yourname 替换成你自己的用户名。 Hexo安装找一个目录，我是在 d:\\Hexo 目录下，鼠标右击打开 Git Bash Here，输入：1$ npm install hexo-cli -g 可能会看到一个 WARN，但是没关系的，进入下一步。输入：1$ npm install hexo --save 等一段时间，他安装完之后检查一下是否安装成功，输入： 1$ hexo -v 看到相关的版本信息则说明安装成功。 Hexo配置初始化 Hexo，首先需要找一个目录，这个目录即就是你的博客的所有文件存放的目录，最好路径不要太深，我选择的是 D:\\Hexo\\blog 。在这个路径下打开 Git Bash Here ，输入代码：1$ hexo init 然后输入：1$ npm install 这里 npm 会自动帮你安装你需要的组件。继续输入：1$ hexo g 生成博客。输入：1$ hexo s 启动服务，会提示以下信息：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器打开 http://localhost:4000/ ，将会看到自己的 hexo 博客： 关联 Hexo 与 Github Page配置Git个人信息如果你之前已经配置好git个人信息，请跳过这一个步骤，直接来到步骤2设置Git的user name和email：（如果是第一次的话）12$ git config --global user.name \"renkaitset\"$ git config --global user.email \"541638321@qq.com\" 生成密钥1$ ssh-keygen -t rsa -C \"541638321@qq.com\" 输入代码后一直按回车就好了，不用自己定义目录，生成的 ssh 会存放在 C:\\Users\\用户名\\.ssh 目录下，如果找不到 .ssh 目录，请在文件夹选项中显示隐藏的项目。 配置 SSH 密匙进入 Github 网页，点击右上角自己的头像，选择 Settings ：配置 SSH and GPG keys ，点击 New SSH key：用 txt 打开刚才生成的 Key，复制到下图所示区域，点击 Add SSH key： 配置 Deployment打开博客目录下的站点配置文件 _config.yml ，比如我的博客目录是 D:\\Hexo\\blog，找到该目录下的 _config.yml。打开他，在最末尾找到 Deployment ，然后按照如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 上面的 yourname 都要替换成自己的用户名，以我的为例：1234deploy: type: git repo: git@github.com:renkaitest/renkaitest.github.io.git branch: master 这样就配置好了，接下来就可以写博客了。 发布博文新建一篇博文，在博客存放的目录里面 Git Bash Here ，执行命令：1$ hexo new post \"我的第一篇博文\" 然后就会在电脑的目录下 D:\\Hexo\\blog\\source\\_posts 看到一个 我的第一篇博文.md 文件，使用 MarkDown 编辑这篇文章就可以了。文章编辑好后，运行生成、部署命令。但是此时还缺少一个扩展，因而不能部署，先要执行以下命令：1$ npm install hexo-deployer-git --save 如果没有执行这个命令，将会提醒： deloyer not found:git 现在开始执行：12$ hexo g // 生成$ hexo d // 部署 也可以将这两个命令一起执行：1$ hexo d -g //在部署前先生成 若出现如下图所示的信息 INFO Deploy done: git ，则表示部署成功，已经上传到你的代码库。此时访问你的地址 https://yourname.github.io ，将会看到刚才写的文章了。注：我的主题是自己换过的，可能与你的显示结果有所不同，做到这一步，你已经成功搭建了自己的博客。已经大功告成了！恭喜你~ 总结以后发布博文，就是以下的步骤： 写博文： 1$ hexo new post \"博文名字\" 生成博文： 1$ hexo g 部署博文： 1$ hexo d 由于网络原因，进入你的网页可能不会立即显示最新的信息。过几分钟就好了~","categories":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"},{"name":"Hexo","slug":"Github/Hexo","permalink":"http://yoursite.com/categories/Github/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]},{"title":"ArcGIS Engine 地图操作基础——数据加载","slug":"ArcGIS-Engine-map-basic-load-data","date":"2017-06-05T04:47:44.000Z","updated":"2017-06-13T14:27:20.221Z","comments":true,"path":"posts/ArcGIS/2017-06-05-ArcGIS-Engine-map-basic-load-data.html","link":"","permalink":"http://yoursite.com/posts/ArcGIS/2017-06-05-ArcGIS-Engine-map-basic-load-data.html","excerpt":"数据加载是 ArcGIS Engine 中最基础的操作，AE 支持的数据广泛，包含矢量数据、栅格数据、CAD 数据、Excel数据等等，这些数据的加载有助于我们使用 AE 做进一步的数据处理与分析。","text":"数据加载是 ArcGIS Engine 中最基础的操作，AE 支持的数据广泛，包含矢量数据、栅格数据、CAD 数据、Excel数据等等，这些数据的加载有助于我们使用 AE 做进一步的数据处理与分析。 加载地图文档地图文档可以是一个ArcMap文档（*.mxd）或者ArcMap模版（*.mxt）或ArcReader文件（*.pmf）。 加载地图文档的方式有三种： 使用 IMapControl 接口的 LoadMxFile 方法加载； 通过 IMapDocument 接口加载; 使用 ArcGIS Engine 中封装好的类库资源 ControlsOpenDocCommandClass 加载。 LoadMxFile 方法加载地图文档文件1234567891011121314151617181920212223242526272829303132333435private void BtnLoadMxFile_Click(object sender, EventArgs e)&#123; //加载数据前如果有数据则清空 try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开地图文档\"; pOpenFileDialog.Filter = \"ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf\"; pOpenFileDialog.Multiselect = false; //不允许多个文件同时选择 pOpenFileDialog.RestoreDirectory = true; //存储打开的文件路径 if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == \"\") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; ClearAllData(); mainMapControl.LoadMxFile(pFileName); &#125; else &#123; MessageBox.Show(pFileName + \"是无效的地图文档!\", \"信息提示\"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(\"打开地图文档失败\" + ex.Message); &#125;&#125; 关于 ClearAllData 函数: 1234567891011121314151617private void ClearAllData()&#123; if (mainMapControl.Map != null &amp;&amp; mainMapControl.Map.LayerCount &gt; 0) &#123; //新建mainMapControl中Map IMap dataMap = new MapClass(); dataMap.Name = \"Map\"; mainMapControl.DocumentFilename = string.Empty; mainMapControl.Map = dataMap; //新建EagleEyeMapControl中Map IMap eagleEyeMap = new MapClass(); eagleEyeMap.Name = \"eagleEyeMap\"; EagleEyeMapControl.DocumentFilename = string.Empty; EagleEyeMapControl.Map = eagleEyeMap; &#125;&#125; IMapDocument 方法加载 Mxd 文档文件123456789101112131415161718192021222324252627282930313233343536373839private void BtnIMapDocument_Click(object sender, EventArgs e)&#123; try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开地图文档\"; pOpenFileDialog.Filter = \"ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf\"; pOpenFileDialog.Multiselect = false; pOpenFileDialog.RestoreDirectory = true; if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == \"\") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; //将数据载入pMapDocument并与Map控件关联 IMapDocument pMapDocument = new MapDocument();//using ESRI.ArcGIS.Carto; pMapDocument.Open(pFileName, \"\"); //获取Map中激活的地图文档 mainMapControl.Map = pMapDocument.ActiveView.FocusMap; mainMapControl.ActiveView.Refresh(); &#125; else &#123; MessageBox.Show(pFileName + \"是无效的地图文档!\", \"信息提示\"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(\"打开地图文档失败\" + ex.Message); &#125;&#125; ControlsOpenDocCommandClass 加载地图123456private void BtncontrolsOpenDocCommandClass_Click(object sender, EventArgs e)&#123; ICommand command = new ControlsOpenDocCommandClass(); command.OnCreate(mainMapControl.Object); command.OnClick();&#125; 加载 Shapefile 数据加载 Shapefile 数据的方式有两种： 通过工作空间加载； 通过 MapControl 空间的 AddShapefile 方法加载 通过工作空间加载实例程序实现思路： (1) 创建 ShapefileWorkspaceFactory 实例 pWorkspaceFactory ，使用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 pFeatureWorkspace 中存储的基于 Shapefile 的工作区。 (2) 创建 FeatureLayer 的实例 pFeatureLayer ，并定义数据集。 (3) 使用 IMap 接口的 AddLayer 方法加载 pFeatureLayer 到当前地图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void AddShp_Click(object sender, EventArgs e)&#123; //ClearAllData(); try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Shape文件\"; pOpenFileDialog.Filter = \"Shape文件（*.shp）|*.shp\"; pOpenFileDialog.ShowDialog(); ////获取文件路径,此即为第二种方法 //FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName); //string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); //mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 获取文件路径 IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") return; int pIndex = pFullPath.LastIndexOf(\"\\\\\"); //lastIndexOf是从字符串末尾开始检索，检索到子字符，则返回子字符在字符串中的位置，（位置从前向后数，最小位为0，也就是从第0位开始算起）未检测到则返回-1。 string pFilePath = pFullPath.Substring(0, pIndex); //文件路径 string pFileName = pFullPath.Substring(pIndex + 1); //文件名 /*substring(参数)是java中截取字符串的一个方法 有两种传参方式 一种是 public String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 另一种是 public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 */ //实例化ShapefileWorkspaceFactory工作空间，打开Shape文件 pWorkspaceFactory = new ShapefileWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //创建并实例化要素集 IFeatureClass pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName); pFeatureLayer = new FeatureLayer(); pFeatureLayer.FeatureClass = pFeatureClass; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName;//获取别名 ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer);//加载图层 mainMapControl.ActiveView.Refresh(); //同步鹰眼.可有可无 SynchronizeEagleEye(); &#125; catch (Exception ex) &#123; MessageBox.Show(\"图层加载失败！\" + ex.Message); &#125;&#125; 通过 MapControl 空间的 AddShapefile 方法加载 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。 1234567891011121314private void AddShp2_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Shape文件\"; pOpenFileDialog.Filter = \"Shape文件（*.shp）|*.shp\"; pOpenFileDialog.ShowDialog(); //获取文件路径 FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName);//FileInfo需要using system.IO string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。&#125; 加载栅格数据实例程序实现思路： 在加载栅格文件时，需引用 ESRI.ArcGIS.DataSourcesRaster 命名空间。 (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得栅格文件的工作区； (2) 用 IRasterWorkspace 接口的 OpenRasterDataset 方法获得栅格文件的数据集，实例化栅格文件对象，并对栅格数据集是否具有金字塔进行判断（这里栅格文件如果不具有金字塔则创建金字塔，可以提高大数据量图像的显示效率）； (3) 创建 RasterLayer 类的实例 pRasterLayer ，并定义其数据集； (4) 使用 MapControl 控件的 AllLayer 方法将 pRasterLayer 添加至当前地图。 123456789101112131415161718192021222324252627282930313233343536373839private void AddRaster_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Raster文件\"; pOpenFileDialog.Filter = \"栅格文件 (*.*)|*.bmp;*.tif;*.jpg;*.img|(*.bmp)|*.bmp|(*.tif)|*.tif|(*.jpg)|*.jpg|(*.img)|*.img\"; pOpenFileDialog.ShowDialog(); string pRasterFileName = pOpenFileDialog.FileName; if (pRasterFileName == \"\") &#123; return; &#125; string pPath = System.IO.Path.GetDirectoryName(pRasterFileName); string pFileName = System.IO.Path.GetFileName(pRasterFileName); IWorkspaceFactory pWorkspaceFactory = new RasterWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(pPath, 0); IRasterWorkspace pRasterWorkspace = pWorkspace as IRasterWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pFileName); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRaster pRaster; pRaster = pRasterDataset.CreateDefaultRaster(); IRasterLayer pRasterLayer; pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromRaster(pRaster); mainMapControl.Map.AddLayer(pLayer);//加载shp文件时是这样弄得，经过尝试这样也是可以的，具体有什么区别不可知 //mainMapControl.AddLayer(pLayer, 0);//这是书上的源代码&#125; 加载 CAD 数据对于 ArcGIS Engine 来说，有两种不同的方式使用 CAD 数据：① 作为要素图层，以矢量数据来使用；② 作为地图背景，以栅格数据来使用。对于前者， ArcGIS Engine 使用与 FeatureLayer 一样的方法来管理，对于后者则采用 CadLayer 对象来管理。 CAD 文件作为矢量图层加载分图层加载实例程序实现思路： (1) CAD 图可以分为点、线、面、标注，它们可以分别被加载到 MapControl 中。与加载其他数据一样，首先定义一个工作空间，用 CadWorkspaceFactoryClass 实例化工作空间，并打开相应的工作空间； (2) 创建 FeatureLayer 的实例，定义数据集，使用 IMap 接口的 AddLayer 方法将要素图层添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435363738394041private void AddCADByLayer_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureClass pFeatureClass; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pWorkspaceFactory = new CadWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //加载CAD文件中的线文件 pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":polyline\"); //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":polygon\");//打开多边形 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":point\");//打开点 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":multipatch\");//打开多面体 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":annotation\");//打开标注是这样吗？自己尝试失败，打开的是点，什么鬼？搞不懂。。。 pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFileName; pFeatureLayer.FeatureClass = pFeatureClass; ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer); mainMapControl.ActiveView.Refresh(); //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; 整幅图加载实例程序实现思路： 将 CAD 作为整幅图加载时，在得到相应的工作空间之后对 CAD 文件中的要素进行遍历，并判断是否为注记图层，如果是注记则需要使用 CadAnnotationLayer 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void AddWholeCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureDataset pFeatureDataset; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); //打开CAD数据集 pWorkspaceFactory = new CadWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesFile; pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //打开一个要素集 pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pFileName); //IFeatureClassContainer可以管理IFeatureDataset中的每个要素类 IFeatureClassContainer pFeatClassContainer = (IFeatureClassContainer)pFeatureDataset; ClearAllData(); //新增删除数据 //对CAD文件中的要素进行遍历处理 for (int i = 0; i &lt; pFeatClassContainer.ClassCount; i++) &#123; IFeatureClass pFeatClass = pFeatClassContainer.get_Class(i); //如果是注记，则添加注记层 if (pFeatClass.FeatureType == esriFeatureType.esriFTCoverageAnnotation) &#123; pFeatureLayer = new CadAnnotationLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; else //如果是点、线、面则添加要素层 &#123; pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; mainMapControl.ActiveView.Refresh(); &#125; //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; CAD 文件作为栅格图层加载实例程序实现思路： (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得 CAD 文件的工作区； (2) 用 ICadDrawingWorkspace 接口的 OpenCadDrawingDataset 方法获得 CAD 文件的数据集，并将其赋值给 CadLayerClass 类的实例对象 pCadLayer 的 CadDrawingDataset 属性； (3) 使用 IMap 接口的 AddLayer 方法将 pCadLayer 添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435private void AddRasterByCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pCadWorkspaceFactory; IWorkspace pWorkspace; ICadDrawingWorkspace pCadDrawingWorkspace; ICadDrawingDataset pCadDrawingDataset; ICadLayer pCadLayer; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pCadWorkspaceFactory = new CadWorkspaceFactoryClass(); pWorkspace = pCadWorkspaceFactory.OpenFromFile(pFilePath, 0); pCadDrawingWorkspace = (ICadDrawingWorkspace)pWorkspace; //获得CAD文件的数据集 pCadDrawingDataset = pCadDrawingWorkspace.OpenCadDrawingDataset(pFileName); pCadLayer = new CadLayerClass(); pCadLayer.CadDrawingDataset = pCadDrawingDataset; pCadLayer.Name = pFileName;//书中代码没有这一句，打开的结果是TOC面板里面没有文件的名字，故而自己添上了这一句 mainMapControl.Map.AddLayer(pCadLayer); mainMapControl.ActiveView.Refresh();&#125; 加载个人地理数据库个人地理数据库（Personal Geodatabase）使用 Micorosoft Access 文件（*.mdb）进行空间数据的存储与管理，它将不同的数据同一纳入 Access 文件中，便于数据的管理与迁移，容量限制为2GB。个人地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 创建 AccessWorkspaceFactory 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 *.mdb 数据集的工作空间，对工作空间里面的数据进行加载。 1234567891011121314151617181920212223private void AddPersonGDB_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pAccessWorkspaceFactory; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"Personal Geodatabase(*.mdb)|*.mdb\"; pOpenFileDialog.Title = \"打开PersonGeodatabase文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; pAccessWorkspaceFactory = new AccessWorkspaceFactory(); //using ESRI.ArcGIS.DataSourcesGDB; //获取工作空间 IWorkspace pWorkspace = pAccessWorkspaceFactory.OpenFromFile(pFullPath, 0); ClearAllData(); //新增删除数据 //加载工作空间里的数据 AddAllDataset(pWorkspace, mainMapControl);&#125; 这里对加载工作空间中数据的方法进行了封装，自定义了 AddAllDataset 函数，以便对其他空间数据库（文件地理数据库、ArcSDE 空间数据库）加载时可直接调用。 以上代码主要介绍矢量和栅格数据的加载（其实不止这两种数据格式，加载其他类型的数据也是采用相同的方法，只是采用不同的工作空间而已）。 自定义函数 AddAllDataset 核心代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// 加载工作空间里面的要素和栅格数据/// &lt;/summary&gt;/// &lt;param name=\"pWorkspace\"&gt;&lt;/param&gt;private void AddAllDataset(IWorkspace pWorkspace, AxMapControl mapControl)&#123; IEnumDataset pEnumDataset = pWorkspace.get_Datasets(ESRI.ArcGIS.Geodatabase.esriDatasetType.esriDTAny); pEnumDataset.Reset(); //将Enum数据集中的数据一个个读到DataSet中 IDataset pDataset = pEnumDataset.Next(); //判断数据集是否有数据 while (pDataset != null) &#123; if (pDataset is IFeatureDataset) //要素数据集 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureDataset pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pDataset.Name); IEnumDataset pEnumDataset1 = pFeatureDataset.Subsets; pEnumDataset1.Reset(); IGroupLayer pGroupLayer = new GroupLayerClass(); pGroupLayer.Name = pFeatureDataset.Name; IDataset pDataset1 = pEnumDataset1.Next(); while (pDataset1 != null) &#123; if (pDataset1 is IFeatureClass) //要素类 &#123; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset1.Name); if (pFeatureLayer.FeatureClass != null) &#123; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; pGroupLayer.Add(pFeatureLayer); mapControl.Map.AddLayer(pFeatureLayer); &#125; &#125; pDataset1 = pEnumDataset1.Next(); &#125; &#125; else if (pDataset is IFeatureClass) //要素类 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset.Name); pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; mapControl.Map.AddLayer(pFeatureLayer); &#125; else if (pDataset is IRasterDataset) //栅格数据集 &#123; IRasterWorkspaceEx pRasterWorkspace = (IRasterWorkspaceEx)pWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pDataset.Name); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRasterLayer pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromDataset(pRasterDataset); ILayer pLayer = pRasterLayer as ILayer; mapControl.AddLayer(pLayer, 0); &#125; pDataset = pEnumDataset.Next(); &#125; mapControl.ActiveView.Refresh(); //同步鹰眼 SynchronizeEagleEye();&#125; 加载文件地理数据库数据文件地理数据库（File Geodatabase）是以文件夹形式存储各种类型的 GIS 数据集，可以存储、查询和管理空间数据和非空间数据，支持的地理数据库的大小最大为 1 TB。文件地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 由于文件地理数据库是以文件夹的形式存在的，因此可以使用 FolderBrowserDialog 选择文件夹进行加载。首先创建 FileGDBWorkspaceFactoryClass 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开文件地理数据库的工作空间，对工作空间里面的数据进行加载。 12345678910111213141516171819202122#region 加载文件地理数据库数据private void AddFileDatabase_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pFileGDBWorkspaceFactory; FolderBrowserDialog dlg = new FolderBrowserDialog(); if (dlg.ShowDialog() != DialogResult.OK) return; string pFullPath = dlg.SelectedPath; if (pFullPath == \"\") &#123; return; &#125; pFileGDBWorkspaceFactory = new FileGDBWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesGDB; ClearAllData(); //新增删除数据 //获取工作空间 IWorkspace pWorkspace = pFileGDBWorkspaceFactory.OpenFromFile(pFullPath, 0); AddAllDataset(pWorkspace, mainMapControl);&#125;#endregion 加载 ArcSDE 空间数据库数据ArcSDE（Spatial Database Engine，空间搜索引擎）是在现有的关系型数据库上进行的空间扩展，它使空间数据能保存在关系数据库中（如 Oracle、SQLServer等）。ArcSDE 空间数据库的一个重要特点是支持多用户并发操作，并且可以通过版本来表现空间数据编辑的状态。 ArcSDE 的组成： ArcSDE 服务器管理进程负责维护 ArcSDE 和监听来自客户端的连接请求。ArcSDE 启动就是启动 ArcSDE 服务器管理进程，利用管理员账户管理 ArcSDE 与 RDBMS 的连接，处理客户端的连接请求。 专用服务器进程由 ArcSDE 服务器管理进程穿件，用于每一个特定的客户端应用程序与数据库的连接。 ArcSDE 客户端通过 ArcSDE 服务器管理进程和专用服务器进程建立和 RDBMS 的连接，实现对数据库的操作。 ArcSDE 提供了应用服务器连接和直接连接两种连接方式。当服务器性能较好时可采用应用服务器连接，否则采用直接连接。为了减轻服务器的压力，建议采用直接连接的方式进行连接。 两种连接方式的异同：直接连接就是通过 ArcSDE 访问数据表，并在本地完成对数据的各种操作（如空间分析、编辑等）；而应用服务器连接就是通过 ArcSDE 访问数据表后，在服务器端完成对数据的各种操作，再把操作结果返回客户端。 实例程序实现思路： (1) 创建 SDEWorksapceFactoryClass 类的实例； (2) 通过 SDE 连接的连接属性打开 SDE 数据库的工作空间，对工作空间里面的数据进行加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 这里以基于 Oracle 11g 的 ArcSDE 10.0 连接为例对两种连接方式进行说明。#region 加载 ArcSDE 数据库/// &lt;summary&gt;/// 服务器连接/// &lt;/summary&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"e\"&gt;&lt;/param&gt;private void AddSDEByService_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; pWorkspace = arcSDEWorkspaceOpen(\"192.168.70.110\", \"esri_sde\", \"sde\", \"sde\", \"\", \"SDE.DEFAULT\"); //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 直连/// &lt;/summary&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"e\"&gt;&lt;/param&gt;private void AddSDEByDirect_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 通过SDE连接打开SDE数据库/// &lt;/summary&gt;/// &lt;param name=\"server\"&gt;服务器IP&lt;/param&gt;/// &lt;param name=\"instance\"&gt;数据库实例，应用服务器连接为：5151或esri_sde，直连为sde:oracle11g:orcl(orcl为服务名)&lt;/param&gt;/// &lt;param name=\"user\"&gt;SDE用户名&lt;/param&gt;/// &lt;param name=\"password\"&gt;用户密码&lt;/param&gt;/// &lt;param name=\"database\"&gt;数据库&lt;/param&gt;/// &lt;param name=\"version\"&gt;SDE版本，缺省为\"SDE.DEFAULT\"&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private IWorkspace arcSDEWorkspaceOpen(string server, string instance, string user, string password, string database, string version)&#123; IWorkspace pWorkSpace = null; //创建和实例化数据集 IPropertySet pPropertySet = new PropertySetClass(); pPropertySet.SetProperty(\"SERVER\", server); pPropertySet.SetProperty(\"INSTANCE\", instance); pPropertySet.SetProperty(\"USER\", user); pPropertySet.SetProperty(\"PASSWORD\", password); pPropertySet.SetProperty(\"DATABASE\", database); pPropertySet.SetProperty(\"VERSION\", version); IWorkspaceFactory2 pWorkspaceFactory = new SdeWorkspaceFactoryClass(); try &#123; pWorkSpace = pWorkspaceFactory.Open(pPropertySet, 0); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; return pWorkSpace;&#125;#endregion 加载文本文件数据野外测量的数据通常为含有 X、Y 坐标的 Excel 文件或者文本文件。实例程序实现思路： (1) 根据 Excel 或者 *.txt 文件等获取点的坐标信息； (2) 根据点的坐标创建 Shapefile 图层； (3) 加载该 Shapefile 图层。 坐标信息的提取 (1) 创建一个点结构，进行点信息的存储。 123456struct CPoint&#123; public string Name; public double X; public double Y;&#125; (2) 创建并实例化一个 CPoint 类型的数组，将所有的点信息进行存储。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647List&lt;string&gt; pColumns = new List&lt;string&gt;();private List&lt;CPoint&gt; GetPoints(string surveyDataFullName)&#123; try &#123; List&lt;CPoint&gt; pList = new List&lt;CPoint&gt;(); char[] charArray = new char[] &#123; ',', ' ', '\\t' &#125;; //常用的分隔符为逗号、空格、制表符 //文本信息读取 FileStream fs = new FileStream(surveyDataFullName, FileMode.Open); StreamReader sr = new StreamReader(fs, Encoding.Default); string strLine = sr.ReadLine(); if (strLine != null) &#123; string[] strArray = strLine.Split(charArray); if (strArray.Length &gt; 0) &#123; for (int i = 0; i &lt; strArray.Length; i++) &#123; pColumns.Add(strArray[i]); &#125; &#125; while ((strLine= sr.ReadLine())!=null) &#123; //点信息的读取 strArray = strLine.Split(charArray); CPoint pCPoint = new CPoint(); pCPoint.Name = strArray[0].Trim(); pCPoint.X = Convert.ToDouble(strArray[1]); pCPoint.Y = Convert.ToDouble(strArray[2]); pList.Add(pCPoint); &#125; &#125; else &#123; return null; &#125; sr.Close(); return pList; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); return null; &#125;&#125; 根据点坐标创建 Shapefile 图层 (1) 创建表的工作空间，通过 IFields、IFieldsEdit、IField 等接口创建属性字段，添加到要素集中。 (2) 根据获得的点坐标信息为属性字段赋值，进而得到图层的要素集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private IFeatureLayer CreateShpFromPoints(List&lt;CPoint&gt; cPointList, string filePath)&#123; int index = filePath.LastIndexOf('\\\\'); string folder = filePath.Substring(0, index);//路径切分得到文件夹名 string shapeName = filePath.Substring(index + 1); //路径切分得到文件名 IWorkspaceFactory pWSF = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pFWS = (IFeatureWorkspace)pWSF.OpenFromFile(folder, 0); IFields pFields = new FieldsClass(); IFieldsEdit pFieldsEdit; pFieldsEdit = (IFieldsEdit)pFields; IField pField = new FieldClass(); IFieldEdit pFieldEdit = (IFieldEdit)pField; pFieldEdit.Name_2 = \"Shape\"; pFieldEdit.Type_2 = esriFieldType.esriFieldTypeGeometry; IGeometryDef pGeometryDef = new GeometryDefClass(); IGeometryDefEdit pGDefEdit = (IGeometryDefEdit)pGeometryDef; pGDefEdit.GeometryType_2 = esriGeometryType.esriGeometryPoint; //定义坐标系 ISpatialReferenceFactory pSRF = new SpatialReferenceEnvironmentClass(); ISpatialReference pSpatialReference = pSRF.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_Beijing1954); pGDefEdit.SpatialReference_2 = pSpatialReference; pFieldEdit.GeometryDef_2 = pGeometryDef; pFieldsEdit.AddField(pField); IFeatureClass pFeatureClass; pFeatureClass = pFWS.CreateFeatureClass(shapeName, pFields, null, null, esriFeatureType.esriFTSimple, \"Shape\", \"\"); IPoint pPoint = new PointClass(); for (int j = 0; j &lt; cPointList.Count; j++) &#123; pPoint.X = cPointList[j].X; pPoint.Y = cPointList[j].Y; IFeature pFeature = pFeatureClass.CreateFeature(); pFeature.Shape = pPoint; pFeature.Store(); &#125; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = shapeName; pFeatureLayer.FeatureClass = pFeatureClass; return pFeatureLayer;&#125; Shapefile 图层的加载1234567891011121314151617private void btnCreate_Click(object sender, EventArgs e)&#123; if (ValidateTxtbox()) &#123; List&lt;CPoint&gt; pCPointList = GetPoints(txtSource.Text); if (pCPointList == null) &#123; MessageBox.Show(\"所选文件为空，请重新选择！\"); &#125; else &#123; IFeatureLayer pFeatureLayer = CreateShpFromPoints(pCPointList, txtSave.Text); buddyMap.Map.AddLayer(pFeatureLayer); this.Close(); &#125; &#125;&#125; 总结根据上述 ArcGIS Engine 加载几种常用的数据源的方法，可以看出 ArcGIS Engine 加载空间数据一般具有以下五个步骤： 创建数据对应的工作空间工厂（WorkspaceFactory）； 使用 WorkspaceFactory 创建要加载数据的工作空间（Workspace）; 使用 Workspace 打开并得到图层的数据集 DataSet ; 将 DataSet 赋值给新建图层的数据源； 添加图层到 MapControl。","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"2014年赴中科院安塞水土保持综合试验站三下乡视频","slug":"video-for-ansai-practical-activity","date":"2014-08-24T08:23:31.000Z","updated":"2017-11-20T02:06:45.273Z","comments":true,"path":"posts/Mine/2014-08-24-video-for-ansai-practical-activity.html","link":"","permalink":"http://yoursite.com/posts/Mine/2014-08-24-video-for-ansai-practical-activity.html","excerpt":"搬运旧时视频。","text":"搬运旧时视频。 配音：王亚利同学","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"时间都去哪了","slug":"i-love-dad-and-mom","date":"2014-03-01T03:55:24.000Z","updated":"2017-08-24T14:46:02.899Z","comments":true,"path":"posts/Mine/2014-03-01-i-love-dad-and-mom.html","link":"","permalink":"http://yoursite.com/posts/Mine/2014-03-01-i-love-dad-and-mom.html","excerpt":"搬运旧时文章。 以前太感性，太矫情。现在的我，更偏向于理性。但于父母，爱大于一切。 ——2017.08","text":"搬运旧时文章。 以前太感性，太矫情。现在的我，更偏向于理性。但于父母，爱大于一切。 ——2017.08 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间真的过得好快啊，眨眼，寒假就过完了，眨眼，我已是奔三的年纪。时间都去了哪儿，将我身边的人慢慢变老。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看着爸妈对我呵护备至，想起他们对我的一点一滴，再看到妈妈眼角的皱纹，我总是对自己说，我一定要对他们好，我一定不要再淘气了。因为我爱他们！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;妈妈总是要我隔三差五就给她打电话，因为她想我，她想我过得好不好，有没有生病，有没有什么不顺，只想和我说说话，就足够了。这便是爱，我们谁都不愿意说出口，但却能从只言片语中深切感受得到。我想，再也没有一个人像妈妈这样对我好的了，这世界上有妈妈在时刻想念着我，想念着他的儿子。我爱我的妈妈，但我不说出来，我能做到的就是不惹她生气，不给她添麻烦。去年暑假妈妈让我把一周岁的照片给她的手机做屏保，还给我讲很多我小时候的事，或许只有妈妈才能记得我小时候的每一个瞬间吧，即使我自己已经渐渐遗忘了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总是听到妈妈从百里之外的家中电话告诉我，我不想你回家，我不要你回家。因为你回一次家，我的心就会痛一次。她总是不忍分别的那一刻，她告诉我，她在看到我坐上去往西安的高客后，心就一阵一阵的痛，一直看到车驶出视野，才一路哭着回了家。晚上到我的房间，一摸被子没有人，再摸还是没有人，整间屋子空荡荡的，就又开始流泪。我听到她讲，总是不以为然的，我不懂这样的爱，但有一天我应该会懂。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我总是在别人面前提起我的妈妈怎么怎么样，却从来没有提到过爸爸。都说了，父爱是伟大的，严厉的，但我却总是不觉得，因为我和爸爸接触很少，我只是非常非常听他的话，我和妈妈犟好久的事只要他开口，我绝对执行。我继承了爸爸的性格，都是言语特别少的人，我们没有认真谈过心，也没有通过电话，只是坐在一起看看电视，爬爬山。但爸爸对我的好，我看在眼里。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我爱我的爸爸妈妈！ 记忆中的小脚丫，肉嘟嘟的小嘴巴，一生把爱交给他，只为那一声爸妈。”","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Emotion","slug":"Emotion","permalink":"http://yoursite.com/tags/Emotion/"}]},{"title":"蓝天净土（Video）","slug":"video-for-lantianjingtu","date":"2014-01-01T08:05:54.000Z","updated":"2017-11-20T02:06:16.615Z","comments":true,"path":"posts/Mine/2014-01-01-video-for-lantianjingtu.html","link":"","permalink":"http://yoursite.com/posts/Mine/2014-01-01-video-for-lantianjingtu.html","excerpt":"搬运旧时视频。 2014年一手策划的 蓝天净土 视频，当时制作视频的水平很 low，用的软件是会声会影，当然现在的水平还不及那时吧！现在再回顾，感触颇深。对这个大家庭还是有很深的感情的，虽然后面我主动退出了，虽然现在她可能已经被“领导们”取缔了……——2017.08","text":"搬运旧时视频。 2014年一手策划的 蓝天净土 视频，当时制作视频的水平很 low，用的软件是会声会影，当然现在的水平还不及那时吧！现在再回顾，感触颇深。对这个大家庭还是有很深的感情的，虽然后面我主动退出了，虽然现在她可能已经被“领导们”取缔了……——2017.08","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"【书评】穆斯林的葬礼","slug":"view-of-muslim-funeral","date":"2013-08-03T03:10:45.000Z","updated":"2017-08-29T15:58:46.240Z","comments":true,"path":"posts/Mine/2013-08-03-view-of-muslim-funeral.html","link":"","permalink":"http://yoursite.com/posts/Mine/2013-08-03-view-of-muslim-funeral.html","excerpt":"搬运旧时文章。年轻时的我，还是个文艺小青年。 ——2017.08 速葬、薄葬，是穆斯林的美德，伊斯兰教的葬礼是世界上各种族、各宗教中最简朴的葬礼，没有精美的棺木，没有华贵的寿衣，没有花里胡哨的纸车、纸轿、纸人、纸马，没有旗、锣、伞、扇的仪仗，没有吹吹打打的乐队，也没有漫天抛撒的纸钱……一心向主的穆斯林，不需要任何身外之物来粉饰自己。","text":"搬运旧时文章。年轻时的我，还是个文艺小青年。 ——2017.08 速葬、薄葬，是穆斯林的美德，伊斯兰教的葬礼是世界上各种族、各宗教中最简朴的葬礼，没有精美的棺木，没有华贵的寿衣，没有花里胡哨的纸车、纸轿、纸人、纸马，没有旗、锣、伞、扇的仪仗，没有吹吹打打的乐队，也没有漫天抛撒的纸钱……一心向主的穆斯林，不需要任何身外之物来粉饰自己。 “一个穆斯林家族，六十年间的兴衰，三代人命运的沉浮，两个发生在不同时代、有着不同内容却又交错扭结的爱情悲剧。”两根故事线，一大家子人的悲欢离合，就这样交织重叠地，从作者笔下娓娓流出。“一道门，隔着两个世界。”——一个是玉的世界，一个是月的世界。 这是一本非常值得一读的书，精彩与感动交织……曲终掩卷，荡气回肠，久久地沉浸在书中故事情节当中，为书中人物的喜而乐，为他们的忧而愁。 【人物】梁亦清：“玉器梁”的传人，人性善良，安分守己，虔诚的信奉着真主，一生酷爱琢玉，玉相伴其一生，生于玉，也死于玉，如此固执又如此爱玉的一个人最终还是一口鲜血喷在了未完成的“宝船”上。一代琢玉高手，玉殒人亡，千古遗恨啊。 梁君壁：年轻时的君壁是多么善良，多么单纯，多么害羞的女孩儿，还记得她很娇羞地喊着“奇哥哥”的样子，然后遭遇了父亲的变故后，子奇忍辱负重三年学艺归来，两人潦草地结为连理。当然也一直是贤妻良母，但性情变了，变暴躁了，尤其是日军侵华时与妹妹和子奇因是否逃往英国还大吵了一番，后又因为逃亡归来的子奇和冰玉有了一个女儿，而彻底将冰玉赶出家门。作为姨妈的她，对新月冷言冷语，不曾给过一分关怀，同时，毁了新月，亦毁了天星的爱情，当然也逼着子奇一步一步走向毁灭。 梁冰玉：冰玉和女儿新月一样，都是有文化、有修养的知识分子，敢爱敢恨，最终在英国和姐夫子奇产生了所谓的爱情，觉得家中容不得她便弃身而去。待到三十多年后，人老珠黄的她归来时，却已物是人非，她所牵挂的所有人都死了，姐姐死了，奇哥哥死了，她最最心爱却又不曾给过母爱的女儿新月也死去了…… 韩子奇：易卜拉欣初到梁家，便被璀璨的珠玉所吸引，立志献身于迷人的玉器。拜梁亦清为师，改名韩子奇，两人亲如父子。然后师父死在了玉上，自己偷学技艺三年，与君壁结婚，因战乱跑到英国与冰玉产生了真正的爱情，产有一女名为新月。非常心疼小女新月，却因为自己做了对不起君壁的事而心存悔恨，低声下气的，想爱可怜的新月却是那么的难啊！最后的最后，自己守了一辈子的美玉被红卫兵们搬走了，毫无音信。临死前给心爱的冰玉写了一封信（被天星烧了），他要在死之前，对未了的情、未熄的火、未还的债、未赎的罪得以清算，要求得到那个不能忘怀的人的宽恕。精彩、神奇却又悲惨的一生就这样在疾病中结束了…… 韩天星：知道新月的身世，待新月极好了。可怜自己的爱情被妈妈从中拆散，为了家庭却只能忍气吞声。他看不惯妈妈对新月的态度，却也无可奈何。 陈淑彦：多么好的一位姑娘，新月的好朋友，天星的好妻子。对韩家劳心劳力，深爱着木讷的天星。 楚雁潮：如此如此深深地爱着新月，为了新月，他愿意做任何事情。在新月生病住院的时候，不舍昼夜地守候在她的身边，给她带来活下去的希望，激励她勇敢地活下去。可是却未能见到新月最后一面，新月就离他而去了。二十多年后的他，在新月生日这天，依旧在新月的坟前，为她拉着那曲《梁山伯与祝英台》，想念着那个他心心念念想着的人儿…… 姑妈：她在文中一直扮演着和事佬，就像韩家的奴仆一样为这个家操劳着、奉献着自己的一生。她早年遭遇悲惨，丈夫和儿子都被日军抓走，所幸自己得以被韩家收留，并将天星视为自己的儿子一样看待，对新月也如同亲生女儿一样疼爱有加。她也是一位心脏病人啊，可是韩家哪个人真正关心和注意过她呢，最后可怜的她在新月追问自己的生母的哭声中死于急性心肌梗塞。她从来没有心疼过自己，血肉耗尽了，心操碎了，终于倒下去了，再也没有起来。 韩新月：新月，我有太多的词来形容你。你感动了我，你便是整篇文章的精魂，我宁愿相信《穆斯林的葬礼》其实便说的是你的葬礼。给我最多感动的新月，愿真主祥助你！（有太多话想说，却不知道从何说起，此处略去一千字） 【书评】《穆斯林的葬礼》，书中对穆斯林的生活细节详细的加以描述，不仅仅以极重的笔墨描写穆斯林的葬礼，也详细的描述了穆斯林的婚礼。我固执的以为这场葬礼说的是新月的葬礼，这个可怜的姑娘的葬礼。 但这场葬礼却并非那么简单，书的最后韩子奇说出了一个天大的秘密 “我……不是回回！” 这也许才是真正的穆斯林的葬礼，一直虔诚信奉真主的梁家（韩家）后代身上竟然流着回、汉两族的血液啊！这可谓是对这个穆斯林家族及其沉重的打击。 看过这本书，就好像陪主人公走过了那段岁月，心灵仿佛受到了一次的洗礼。 什么是善？什么是恶？什么是丑？什么是美？什么是爱？什么是恨？ 当这些与我们的心灵碰撞的时候，我们能说得清吗? 【精彩段落】 楚雁潮痴痴地凝望着新月……他看见新月走进燕园，穿着白色的衬衫，蓝色的长裤，手里提着沉重的皮箱和网袋……他看见在未名湖畔迷路的新月，正惊喜地朝他跑来……他看见在红枫掩映的湖心小岛上，新月朝他蓦然回首……他看见了那锁住新月的病床，听见了那刻骨铭心的话语：“老师，我们之间是……爱情吗？”“告诉你，新月！几乎可以这样说，自从见到你的第一天，我就在悄悄地爱着你！”“啊，那是命运，让您等着我，让我遇到您！”“我们付出了爱，也得到了爱，爱得深沉，爱得强烈，爱得长久……”“正因为爱得太深，才惟恐它不能长久，总有一天我会把您丢下……”“任何时候我都不会丢下你，两个生命合在一起该有多大的力量？我扶着你、背着你、拖着你，也要向前走，走出‘阿拉斯加’，我们就有美好的明天！”“‘人生得一知己足矣’，我已经可以死而无憾！”“楚老师，不要为我悲伤，您对我说过：自知是一种幸运，现在我终于自知了，也算是一个幸运的人了。感谢您过去所给予我的全部关怀，但愿我今后不再打扰您了！”他似乎也看见了新月在最后的时刻嘴唇艰难地嚅动，听见了她痛苦的呼唤：“楚……”“新月！我在这儿呢，在你身边！”他痴痴地回答，凝望着新月的遗体。新月再也没有任何回应。她静静地躺在这最后的归宿，低垂的眼睑仿佛还在苦思，紧闭的嘴唇似乎蕴含着万语千言。谁也不知道她的灵魂在想什么，要说什么。她的脸朝向西&gt; 方，她的主宰、她的祖先召唤着她，告别尘世的一切，到该去的地方去……","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"游革命圣地延安","slug":"travel-to-yanan","date":"2013-04-07T08:35:06.000Z","updated":"2017-12-29T09:42:34.120Z","comments":true,"path":"posts/Mine/2013-04-07-travel-to-yanan.html","link":"","permalink":"http://yoursite.com/posts/Mine/2013-04-07-travel-to-yanan.html","excerpt":"游记篇——朝花夕拾。","text":"游记篇——朝花夕拾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“清明时节雨纷纷，路上行人欲断魂”，仿佛是为了迎合这句古诗，在清明这天，三秦大地上落下了一场小雨，它洗去污浊，褪去铅华，平息了城市的喧哗。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这场春雨并不能浇灭人们出游的热情。清明，万物都开始焕发生机，此正是外出踏青的好时节。而我，则邀好友一同去往红色革命圣地延安。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延安，这个从小到大“耳熟”得不能再熟的地方，我终于见到了它的庐山真面目。延安依群山傍延河，宝塔山、清凉山、凤凰山三山鼎峙，黄河支流从这里流过。无论站在这个城市的哪个地方，都可以看见那座著名的“宝塔山”，以及山上随处可见的一个个圆拱形的窑洞。这里的每个角落都透露着一股宁静、幽雅、古朴而又不失厚重的气息。走在灯红酒绿的繁华市区，虽然天空中仍有小雨在淅淅沥沥地飘落，但我依旧能从中感受到这座城市的勃勃生机，它真不愧是中国革命圣地。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清明假期，我游历了杨家岭革命旧址、枣园革命旧址、延安革命纪念馆、凤凰山革命旧址等地，我进入了曾经召开过第七次党代会的中央大礼堂，我参观了毛泽东、周恩来、朱德、杨尚昆、任弼时等重要革命人曾经居住过的窑洞，我目睹了神奇的非物质文化遗产——剪纸艺术。身处圣地延安，任红色春风肆意吹拂，身临其境的我仿佛依稀可见革命人艰苦奋斗的岁月，心中不由升起浓浓的敬意。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一片净土，曾孕育了光照千秋的延安精神。我也终于在这片红色热土上悟得了延安精神，其实就是艰苦奋斗的精神。待到坐上返程的列车，心中只有不舍，舍不得离开这里，而更多的是舍不得和朋友分开。这一别，不知下次到延安，会是以什么原因，以什么目的，又是以什么心情，更重要的是要找寻什么样的人儿？ 2013年4月7日记任凯","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://yoursite.com/tags/Travel/"}]},{"title":"乐在西农的日子","slug":"happy-in-nwsuaf","date":"2012-12-30T04:46:37.000Z","updated":"2017-11-20T02:06:02.138Z","comments":true,"path":"posts/Mine/2012-12-30-happy-in-nwsuaf.html","link":"","permalink":"http://yoursite.com/posts/Mine/2012-12-30-happy-in-nwsuaf.html","excerpt":"搬运旧时文章。","text":"搬运旧时文章。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;站在2012的尾巴上，我仿佛已看到2013的轨迹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;九月份，我体会了大学的生活。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纪律严明的军训，坑爹的各种面试，轻松愉快的团组织活动，冷死人的工程训练，集体补高数作业的星期天晚上…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有看着别人整天满课而偷笑，为各种强迫去做的事而抱怨，为时间总是不能合理安排而头痛…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最最重要的事是，我在漫长的三个月里和我的伙伴们用汗水和辛劳学会了舞狮，感谢我们的队长高金龙，陪我们走过每一个夜晚，感谢他悉心地指导我们的每一个动作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，2012年即将结束，我们舞狮队联合腰鼓秧歌共给动医学院、理学院、林学院的元旦晚会上演出了三场。至此，2012年的所有演出已经告一段落。虽有缺陷和失误，但台上的掌声和尖叫告诉我们，我们的演出很成功，期待下一年的更多演出，我们会越做越好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，虽坐落在杨凌这个小城镇里，但她自身就相当于一个城市一样，她包容了一切，在这里，只有你想不到的，没有她办不到的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我很快乐。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我拥有可以陪伴去自习的人，我拥有五个奇葩的舍友，我还有蓝天净土的广阔天地…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，有很多的高中同学们，有很多帮助我的学长学姐们，有很多很多的人…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，汇聚了来自全国各地的同学。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，有各种不同的习俗文化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，她神奇的在五台山上，在南校就可以看到高大的八号楼。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，她拥有亚洲第一的葡萄酒学院。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，我们生活的地方。我们另外一个家。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期待我明天在校元旦晚会开场舞上的表演。虽然只是拿着“糖葫芦”打酱油，但我感到很荣幸。 2013年，迎新年，祝福西农！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"成长","slug":"grow-up-18th","date":"2011-04-28T14:27:07.000Z","updated":"2017-11-20T02:05:20.027Z","comments":true,"path":"posts/Mine/2011-04-28-grow-up-18th.html","link":"","permalink":"http://yoursite.com/posts/Mine/2011-04-28-grow-up-18th.html","excerpt":"搬运旧时文章。谨以此文纪念我的十八岁","text":"搬运旧时文章。谨以此文纪念我的十八岁 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匆匆，太匆匆。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时光流逝，岁月无痕。一眨眼，一晃神，才发现十八个年头已经过去了。从呱呱坠地咿呀学语到逐渐趋于成熟，我经历了很多很多。渐渐地，看惯了花开花败；渐渐地，看惯了阴晴圆缺；渐渐地，看惯了悲欢离合……总之，我已经在这人世间走过一遭，却来得干净，亦活得干净，没有在已逝的岁月里留下一丝痕迹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个人都喜欢恋旧，都会将现在和过去比较，然后在记忆中搜寻已渐渐丢失的记忆碎片浅浅的怀念。我也不例外，时常陷在回忆的漩涡中无法自拔，时至今日，亦未完全成熟，毕竟还未入世，还未真正领略到社会的残酷、人心的险恶……但我喜欢做单纯的自己，很单纯地喜欢一个人，很单纯地迷恋一首歌，很单纯地行走于暗夜中…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;禁不住想起自己成长的每个细节，虽已渐渐模糊，却也常常想起感伤满怀。隐隐记得，小学时期的自己是很淘气的男孩儿，像每个男生的童年一样活泼好动，总是三五成群的下河去捉鱼，或相约去打电玩，优哉游哉的生活，乐得自由，乐得童真！然而随着渐渐的长大，我的性格也变得内敛，沉默，不善于别人沟通，更不愿去与任何人交谈，尤其面对女生更是显得不知所措。升入高中，初期时我还和一群大男生疯玩，预计着和他们一起“混迹天涯”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许嵩说：“我满意于自己依旧那么的不会做人。对喜欢的人笑脸相待。对厌烦的人敷衍了事。”我想，我是和他一样，爱憎分明，不会娇柔做作，更不会虚伪的伪装自己。全倩曾经说我和邓很相像，原因是我们两个人对每个人都很好，甚至是那些极其让人厌恶的人…我只能说，这很对，但不完全对，我也有讨厌的人。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天是我的十八岁生日，度过今日，便已不再年轻，人生还有多少个十八年容得我去荒废？今日如我所愿，没有太多人知道，悄悄地过18岁，妈妈为我买了两个蛋糕，高兴的我合不拢嘴，还有那些记得我生日的朋友们，谢谢啊！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今最大的愿望就是在即将到来的高考中我能取得让自己满意的成绩，我绝不会让我的十二年学习生涯悲剧结尾。Believe me！我我定会创造奇迹，让自己的人生绽放光彩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我是有富裕的家底，还是有帅气的外表，还是有非凡的才华？呜呼！我什么都没有。但我有的是信心决心耐心，加油！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，祝我生日快乐！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"『我不恨你们』——感巴以战争","slug":"novel-about-israeli-palestinian-war","date":"2009-01-18T03:33:09.000Z","updated":"2017-08-24T14:46:09.213Z","comments":true,"path":"posts/Mine/2009-01-18-novel-about-israeli-palestinian-war.html","link":"","permalink":"http://yoursite.com/posts/Mine/2009-01-18-novel-about-israeli-palestinian-war.html","excerpt":"搬运旧时文章。 高中时期随便写的一个小说。 ——2017.08 背景资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴以（巴勒斯坦和以色列）冲突(The Israeli Palestinian Conflict)是中东地区冲突的热点之一，冲突的背后隐藏着深刻的历史根源，既有宗教的、文化的、民族的因素，更重要的是大国干预等外部因素，各种因素互相影响、激化，使得巴以冲突的复杂性非同一般。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008年的平安夜，当哈马斯组织发射的50多枚火箭弹划破夜空，落在以色列南部后，几乎没有人会否认以色列将使用武力，但恐怕没人想到竟会是这样的规模：以色列对加沙地区发动大规模空袭和地面攻击造成数千人的伤亡。而以军也在战争中损失巨大。战争就在你攻我守的循环中持续到了2009年，原本就处于“冷对峙”状态的巴以局势，发展成全面的“热冲突”。这场战争，给巴以双方造成了难以估量的损失，尤其是两国人民所遭受的痛苦，一时是难以消除的。","text":"搬运旧时文章。 高中时期随便写的一个小说。 ——2017.08 背景资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴以（巴勒斯坦和以色列）冲突(The Israeli Palestinian Conflict)是中东地区冲突的热点之一，冲突的背后隐藏着深刻的历史根源，既有宗教的、文化的、民族的因素，更重要的是大国干预等外部因素，各种因素互相影响、激化，使得巴以冲突的复杂性非同一般。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008年的平安夜，当哈马斯组织发射的50多枚火箭弹划破夜空，落在以色列南部后，几乎没有人会否认以色列将使用武力，但恐怕没人想到竟会是这样的规模：以色列对加沙地区发动大规模空袭和地面攻击造成数千人的伤亡。而以军也在战争中损失巨大。战争就在你攻我守的循环中持续到了2009年，原本就处于“冷对峙”状态的巴以局势，发展成全面的“热冲突”。这场战争，给巴以双方造成了难以估量的损失，尤其是两国人民所遭受的痛苦，一时是难以消除的。 “这不过是政府间的矛盾罢了，何苦连累人民呢？”“这儿没有水，没有电，没有面包，我们只有靠呼吸空气活着。”——题 记 普尔和他的同伴被派遣出来搜索加沙附近村庄，呼啸而过的炮火随时可能威胁到他们的性命。但他们是军人，上战场是他们的职责。 普尔不过是以色列的一名普通士兵。他此时正端着重型机枪和同伴在丛林中行走，时不时有炮弹在这附近炸开，依旧无法阻挠他们行进的脚步。 因为战争的原因，普尔已经有好几个夜晚没有睡觉了，她想念妻子和孩子，他没有尽到做丈夫和爸爸的责任。他讨厌战争，他想要一个和睦的家。 可他现在却在战场上。 丛林中的鸟儿在唱歌，树叶沙沙的在风中摇摆，炮火一如既往的在加沙地区轰隆作响。炸飞了鸟儿，扰乱了林中的宁静。 穿行在丛林中，感受到树叶刮在脸上辣辣的疼，他为自己的行为愧疚。为了所谓的国家的荣誉，出卖了人格。以色列对加沙的数天轰炸，已造成近千人死亡，可是以色列政府依旧打着和平主义的旗号面对其他国家的劝战。 走出了这大片的丛林，是一座小村庄。普尔笑了笑，他终于可以歇息一下了，他已经很累了。 他们走到一户已被炸成废墟的房内，随地躺下。他们有的在聊天，有的在翻看随身携带的杂志，有的紧张的望着外面，而普尔则眯上眼睛，开始休息。 第二天清早，和煦的阳光挥洒下来，照亮了四周。他们又要继续进行搜索工作了。 普尔架着抢，跟着同伴进入一处比较完好的住所。他发现墙角有两个人影闪动。走近一瞧，是一位老妇人和一个孩子。 普尔看着那个孩子渴望的眼神，想到了自己的两个仍在襁褓中的女儿，他们还都没有断奶。在他离开她们时，她们也刚学会叫他一声爸爸。 作为父亲的他，趁着同伴不注意，将他们藏在角落里，装作什么也没有发生的样子，就走开了。他们一家一户的搜索着可能存活的加沙人，而空中盘旋着的飞机仍在不停地空袭加沙城。 普尔仰起头，看天。浓烟包裹了四周，明媚蔚蓝的天空不复存在。忽然，他看到一架战斗机投下一枚火箭弹，而坠落的地方正是他们现在站立的地方。普尔急忙对同伴们呼喊：“快趴下。” “轰隆”的响声已经压住了他的话语，火箭弹在他们中央炸开了。空中飞舞着人的断肢残臂，地上熊熊大火燃着了他们的衣服，猎猎作响。普尔只感到脑袋快要涨裂了，胸中沉闷得像压了几石重石。 迷迷糊糊间看到有一个人影向他走来，飘飘忽忽……… 头依旧痛得厉害，普尔缓缓睁开眼睛，轻微的挪动身体，可左胳膊完全没了知觉，使不上劲。 普尔发现自己现在正在一间破败的房间内，旁边站着一个小女孩。女孩蓝色的眼珠滴溜溜转着，脸上是茫然和无知，还夹杂着孩子共有的天真。 普尔微笑的看着她，眼中是说不尽的慈爱。右手颤抖的抚在女孩的脸上，温柔的抚摸着，就像丈夫抚摸妻子的脸一般。不同的是，这完全是父爱。 这使普尔再一次想到了自己的女儿，那两个只有四岁的女儿。她们也是这样的可爱，普尔经常会带她们去屋后的花园中去捉蝴蝶，她们一左一右在普尔身边，奶声奶气地喊着不太正确的发音，“爸爸……爸爸………” 那声音似乎响在耳边。 女孩看到身边的普尔醒了，连忙对着已经没了玻璃的窗子，喜悦地喊，“奶奶，这位叔叔醒了。” 从外面蹒跚地走进一位老妇人，他手中捧着一碗冒着热气的水，走到普尔身边，递过手中的碗，平静地说，“你好，先生，我是贝恩·劳德拉，谢谢你今天使我和孙女躲过了他们的搜索。你身上的伤不是很严重，但你最好不要乱动，你的胳膊大片被烧伤……和你一起来的战友都死了……唉，惨不忍睹！” 普尔试着抬起左手，可左手就是不受他的控制。普尔无奈地摇了摇头，转而笑着说：“没关系的，上帝保佑，我还活着。是你救了我吧？真不知道该怎么感谢你，劳德拉女士。”说着，他一口气喝掉了碗中的热水，温热的感觉滋养了他残损的心。 普尔忽然想起了自己的职责，面带愧疚的低声说，“真对不起，劳德拉女士。我也不想这样，我很讨厌战争。这不过是政府间的矛盾罢了，何苦连累人民呢？” 老妇人转过身，喃喃地说，“这儿没有水，没有电，没有面包，我们只有靠呼吸空气活着。你刚才喝的那杯水，也是我跑到几里外取来的。” 普尔连忙拽过身后的背包，取出两块面包递给老人和孩子。只见她们狼吞虎咽的很快就吃完了。女孩吃完后，可怜兮兮的望着普尔。普尔耸肩，示意已经没有了。 老妇人嗫懦地说，“谢谢你的面包，小伙子。我不恨你们，这只能怪领导人，是他们发起了战争，你和我们一样也是受害者。” 普尔忍痛站起身来，搀扶住老人，“劳德拉女士，感谢您能饶恕我的罪过。不过，我要走了。” 说着，脚一跛一跛的走向外面，老妇人和女孩一直望着他。 普尔走了一段，转过头深深的向这里鞠躬。然后眼睛落在了那个女孩身上，她正在喜滋滋地把玩着手中的玩具。 普尔继续向前走。身边的炮火声不间断。 突然，他的心中一震，他明显地听到有一声熟悉的炮声在身后响开了。普尔的眼睛湿润了，脑中女孩的可爱模样和老妇人的慈祥关爱一一浮现出来。 他转过身，身后的废墟在冒着浓烟，空气中散发着浓重的血腥味。普尔的眼泪似决堤的洪水，不停的流。他重重地跪在地上，手中的拳头发出叭叭的骨节磨动的轻响。 “我不恨你们……”老妇人的话语，响在耳边。普尔悔恨的用完好的右手捶着地面。 这位战场上无比坚强的军人又一次痛哭起来。","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"http://yoursite.com/tags/Novel/"}]}]}