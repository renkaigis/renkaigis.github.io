{"meta":{"title":"秋月春风等闲度","subtitle":"要有最朴素的生活，与最遥远的梦想。即使明日天寒地冻，路远马亡。","description":"一枚想成为技术控的菜鸟","author":"RenKai","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-09-14T20:51:18.025Z","updated":"2017-06-07T11:38:16.652Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"","date":"2019-09-14T20:51:18.030Z","updated":"2017-08-22T13:51:55.781Z","comments":true,"path":"baidu_verify_r1mSIrNf8h.html","permalink":"http://yoursite.com/baidu_verify_r1mSIrNf8h.html","excerpt":"","text":"r1mSIrNf8h"},{"title":"","date":"2019-09-14T20:51:18.050Z","updated":"2017-08-22T13:46:36.912Z","comments":true,"path":"google9d855e13918129b9.html","permalink":"http://yoursite.com/google9d855e13918129b9.html","excerpt":"","text":"google-site-verification: google9d855e13918129b9.html"},{"title":"About","date":"2017-06-07T05:18:23.000Z","updated":"2018-12-19T07:05:16.612Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"要有最朴素的生活，与最遥远的梦想。即使明日天寒地冻，路远马亡。 var NexT = window.NexT || {}; var CONFIG = { root: '/', scheme: 'Mist', sidebar: {\"position\":\"left\",\"display\":\"hide\",\"offset\":12,\"offset_float\":0,\"b2t\":false,\"scrollpercent\":false}, fancybox: true, motion: true, duoshuo: { userId: '0', author: 'Author' }, algolia: { applicationID: '', apiKey: '', indexName: '', hits: {\"per_page\":10}, labels: {\"input_placeholder\":\"Search for Posts\",\"hits_empty\":\"We didn't find any results for the search: ${query}\",\"hits_stats\":\"${hits} results found in ${time} ms\"} } }; About me Name：RenKai 现居：江苏南京 爱好：跑步、乒乓球、旅游、爬山 学历： 本科 / 西北农林科技大学资源环境学院（地理信息系统 2012/09～2016/06）硕士研究生 / 南京师范大学虚拟地理环境教育部重点实验室（地图学与地理信息系统 2016/09～2019/06） 进行中的计划： &nbsp;&nbsp;KeepCoding&nbsp;&nbsp;KeepEveryDay 更多我的个人信息可查看简历：&nbsp;&nbsp;http://resume.renkaigis.com Contact me &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18851138358 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;541638321 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renkaigis@foxmail.com &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://github.com/renkaigis &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.renkaigis.com &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://weibo.com/renkai123 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://photo.renkaigis.com &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://resume.renkaigis.com About future现在还太菜，想要继续提升自己，不断学习新知识，同时捡起以前学过又忘掉的知识。 用 Blog 来做笔记，分享经验。 借助 Blog 这个平台，督促自己！"},{"title":"Categories","date":"2017-06-07T05:18:02.000Z","updated":"2017-07-28T11:19:42.665Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-07T13:05:24.000Z","updated":"2017-07-28T11:19:50.249Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot 整合 HttpClient，后端调用远程接口","slug":"SpringBoot-HttpClient1","date":"2019-12-05T01:56:12.000Z","updated":"2019-12-16T07:01:06.241Z","comments":true,"path":"SpringBoot-HttpClient1.html","link":"","permalink":"http://yoursite.com/SpringBoot-HttpClient1.html","excerpt":"SpringBoot 整合 HttpClient","text":"SpringBoot 整合 HttpClient 添加 HttpClient 依赖在 SpringBoot 项目中的 pom.xml 文件中添加 HttpClient 的起步依赖： 12345&lt;!-- HttpClient 起步依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;/dependency&gt; HttpClient 发送 GET 请求先尝试通过 HttpClient 发送 GET 请求： 12345678910111213141516171819202122232425262728293031@RestControllerpublic class HttpClientController &#123; @GetMapping(\"/testGet\") public String httpClientTestGet() throws IOException &#123; String result = \"\"; // 要请求的远程连接（此为我本地另开的一个服务，即：http://localhost:8082/queryUser） String url = \"http://172.20.10.2:8082/queryUser\"; // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建GET方式请求对象 HttpGet httpGet = new HttpGet(url); // 设置请求头信息 // httpGet.setHeader(\"Cookie\", \"JSESSIONID=xxxxxxx\"); // 执行请求操作，并拿到结果（同步阻塞） CloseableHttpResponse response = httpClient.execute(httpGet); // 获取结果实体 // 判断网络连接状态码是否正常(0--200都数正常) if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; // 释放链接 response.close(); return result; &#125;&#125; 通过访问：http://localhost:8080/testGet 测试该远程 GET 请求是否成功。 HttpClient 发送 POST 请求1234567891011121314151617181920212223242526272829303132333435@GetMapping(\"/testPost\")public String httpClientTestPost() throws IOException &#123; String result = \"\"; // json数据：&#123;\"username\": \"testPost\",\"password\": \"1234\",\"realname\": \"post 测试\"&#125; String json=\"&#123;\\\"username\\\": \\\"testPost\\\",\\\"password\\\": \\\"1234\\\",\\\"realname\\\": \\\"post 测试\\\"&#125;\"; // 若传入的是个对象，可使用 fastjson 工具包将其转为json字符串 // 要请求的远程连接 String url = \"http://172.20.10.2:8088/addUser\"; // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建post方式请求对象 HttpPost httpPost = new HttpPost(url); // 设置参数到请求对象中，这里内容类型设为json StringEntity stringEntity = new StringEntity(json, ContentType.APPLICATION_JSON); stringEntity.setContentEncoding(\"utf-8\"); httpPost.setEntity(stringEntity); // 执行请求操作，并拿到结果（同步阻塞） CloseableHttpResponse response = httpClient.execute(httpPost); // 获取结果实体 // 判断网络连接状态码是否正常(0--200都属正常) if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; System.out.println(response.getStatusLine().getStatusCode()); // 释放链接 response.close(); return result;&#125; 通过访问：http://localhost:8080/testGet 测试该远程 POST 请求是否成功。 查询数据库，添加成功。 PUT 和 DELETE 同理可以这样进行请求，不一一赘述。 下面将这常用的四个请求方法整合为一个工具类，以使得大部分的请求都能直接调用工具类中的方法实现。 整合 HttpClient 请求方法编写 CommonMethod.java 工具类，该类为静态类，可直接通过类名调用里面的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.rk.utils;import org.apache.http.HttpStatus;import org.apache.http.client.methods.*;import org.apache.http.entity.ContentType;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;public class CommonMethod &#123; // GET 请求 public static String commonGet(String url) throws IOException &#123; String result = \"\"; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response = httpClient.execute(httpGet); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; return result; &#125; // POST 请求 public static String commonPost(String url, String json) throws IOException &#123; String result = \"\"; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); StringEntity stringEntity = new StringEntity(json, ContentType.APPLICATION_JSON); stringEntity.setContentEncoding(\"utf-8\"); httpPost.setEntity(stringEntity); CloseableHttpResponse response = httpClient.execute(httpPost); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; return result; &#125; // PUT 请求 public static String commonPut(String url, String json) throws IOException &#123; String result = \"\"; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPut httpPut = new HttpPut(url); StringEntity stringEntity = new StringEntity(json, ContentType.APPLICATION_JSON); stringEntity.setContentEncoding(\"utf-8\"); httpPut.setEntity(stringEntity); CloseableHttpResponse response = httpClient.execute(httpPut); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; return result; &#125; // DELETE 请求 public static String commonDelete(String url) throws IOException &#123; String result = \"\"; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpDelete httpDelete = new HttpDelete(url); CloseableHttpResponse response = httpClient.execute(httpDelete); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), \"utf-8\"); &#125; return result; &#125;&#125; 该工具类的调用： 12345678// 调用 GETCommonMethod.commonGet(url);// 调用 POSTCommonMethod.commonPost(url, json);// 调用 PUTCommonMethod.commonPut(url, json);// 调用 DELETECommonMethod.commonDelete(url); 常用的请求是 GET、POTS、PUT 和 DELETE 这四个请求方法。其中 GET 和 DELETE 一般只需要传入请求路径 url 就可完成调用，简单的 POST 和 PUT 方法也只需传入 url 和 body 数据就可调用成功。 这是学习工作中整理的，有参考网上别人的教程。只是简单的远程调用接口，复杂的可以设置请求头参数，POST 的时候传入 Map 或者 form 表单数据等。这些我暂时用不到，暂不深究。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://yoursite.com/tags/HttpClient/"}]},{"title":"只要平凡，却不甘平凡","slug":"view-ordinary-world","date":"2019-12-01T09:35:21.000Z","updated":"2019-12-03T00:59:03.877Z","comments":true,"path":"view-ordinary-world.html","link":"","permalink":"http://yoursite.com/view-ordinary-world.html","excerpt":"一个平平常常的日子，细蒙蒙的雨丝，夹着一星半点的雪花，正纷纷淋淋地向大地飘洒着。时令已快到惊蛰，雪当然再不会存留，往往还没等落地，就已经消失得无踪无影了。黄土高原严寒而漫长的冬天，看来就要过去，但那真正温暖的春天，还远远地没有到来……","text":"一个平平常常的日子，细蒙蒙的雨丝，夹着一星半点的雪花，正纷纷淋淋地向大地飘洒着。时令已快到惊蛰，雪当然再不会存留，往往还没等落地，就已经消失得无踪无影了。黄土高原严寒而漫长的冬天，看来就要过去，但那真正温暖的春天，还远远地没有到来…… 少年时，畅读了《平凡的世界》，一本对我影响非常深远的书。 大学时，一部同名电视剧播出，本以为会毁了原作，不成想改编的恰到好处，故事情节丰富，人物刻画饱满，矛盾更加突出。这本书我不知道反反复复看了多遍，这部剧我也不知道刷了多少遍。 这是一部讲述黄土地上的人们在时代改革的洪流中的苦难、奋斗和爱情故事的长篇小说。对于我这样一个生长在三秦大地上的人来说，这一个个场景、语言、人物、故事都显得尤为亲切。 毕竟是荣获矛盾文学奖的小说，《平凡的世界》在中国现代长篇小说文学史上的地位与水准是非常之高的。 我喜欢一遍一遍的读这本书，我喜欢书中每一个淳朴又善良的人物，仿佛就是隔壁的邻居一样亲切，我仿佛可以切身体会到他们生活的熬煎、不易，我为少平和少安永不遏止的奋斗感到高兴且热血沸腾，我又为这俩兄弟的所遭遇的爱情上的坎坷感到惋惜且羡慕。 我承认电视剧的表达与演绎和小说有很大出入，但文学作品影视化本就有很多局限性，同时为了故事情节发展连贯有序，做适当改编无可厚非。至少故事核心情节还在，故事所要表达的情感和主旋律都没有变。 小说与电视剧存在差异，且分开讨论。 《平凡的世界》小说我尚在初中时就听过这本书的名字，《平凡的世界》，啊，多么普通的一本书的名字，“平凡”二字透着简单、快乐，“世界”二字却又给人一种大胸怀、包罗万象的感觉。 那时只喜欢看什么修仙、玄幻和言情小说，对文学作品精读甚少。直到高中毕业，有了充足的时间去审视这本书。于是在网上下载了盗版的txt，我就深陷其中不能自拔了。 全篇故事以少平这个小人物徐徐展开，这是一个普普通通的少年，家境贫寒，在学校里只能吃得起最便宜的黑面馍馍。他虽然穷，但是他有自己的尊严。他会在大家都吃完饭的时候，默默的一个人出来拿走自己那两个难看的“黑疙瘩”。 上高中期间，他认识了地主出身的郝红梅，身体缺陷爱打小报告的侯玉英，还有家境优越的顾养民。当然，最重要的是他认识了田晓霞，她就是少平的冬妮娅，这是一个带他重新认识世界的奇女子，为他打开了新世界的大门，他不甘于只做一个平凡的农民，他要为了自己的理想、为了去看外面广阔的世界而奋斗。 而少安则是一个土生土长的农民，小学文化却深知读书的重要性，就算自己再苦再累都要供弟弟少平和妹妹兰香上学。在感情方面，少安与润叶青梅竹马，彼此互生情愫，奈何家境贫寒，福堂支书等从中干涉，最终遗憾收场。好在他遇见了秀莲，这是多么贤惠多么温柔体贴的女子，她不要彩礼，她不怕这个家穷苦，她深深爱着这个“烂包”的家和自己的男人。有了秀莲“温柔乡”的抚慰，少安开办窑厂，烂包的日子慢慢过得红火起来，成为了村里甚至是县上名声大噪的人物。 润叶与少安青梅竹马，从小在一个被窝里玩到大。他们一起玩耍，一起上学，一起长大。从童真时代一路走来，村里的老人们都说她是少安的“媳妇”。在女大当嫁的年纪，来自家庭的逼迫和少安哥对命运的妥协，她心灰意冷。同时又听闻少安结婚了，和一个山西姑娘一块过光景了。“如果少安没有结婚，不论有多少人进攻，她感情的阵地仍然会固若金汤。想不到，她在前方的战壕里拼命抵挡，但她为之而战的后方却自己烧成了一片火海…” 这年轻时的失恋，爱情的悲剧沉重的打击着她。迫于各方无奈她嫁给了不喜欢的李向前，这又是一次婚姻上的悲剧，她在婚姻里受着水深火热的煎熬，向前的日子也不好过，感情上的失意和妻子的冷漠令他终日酗酒，最后失去了自己的一条腿。润叶这时才发现了深爱自己的人是李向前，在向前出事后她也慢慢生出了感情，虽然这是不完美的爱情或者婚姻，但也算是有了一个美好的结局。 书中不仅仅讲山沟沟里穷苦农民的故事，更涉及国家政策、国家体制变化、土地革命等宏大历史背景。尤其是以田福军为首的改革派，体察民情，以农民吃饱肚子为己任，尽职尽责，永远扑在改革的前列。同时也对官员腐败，思想固化等社会现状进行抨击。 全书最令人惋惜的是晓霞的离去和秀莲的病倒。晓霞属于那个时代追求浪漫追求自由的女性，而秀莲则是更现实更适合踏踏实实过日子的女性。这两个完美的女子在这平凡的世界里显得那么格格不入。 我喜欢秀莲，凡是看过书的人都希望有秀莲这样的女子做自己的媳妇吧。这个女子在孙家最困难的时候，也是在少安决定彻底放弃与润叶的感情的煎熬时刻来到了孙家，她不要彩礼，她悉心照顾奶奶、照顾妹妹兰香，撑起这个烂包的家，给少安内心与肉体上最温暖的呵护。她爱这个男人，也爱这个家，她始终如一的听少安的话。她心疼少安，给少安盛饭捞稠的，把奶奶吃的白面馍给少安吃。少安开办窑厂，有她在背后鼎力支持，在窑厂面临空前大危机的时候，是她从娘家借来钱为少安减轻压力。啊，这是一个多么美好多么贤淑的妻子，孙家的光景越过越好了，可是秀莲却累倒了，她查出了肺癌。这平凡的世界里哪里容得下这么完美的女子啊，这样的女子在当时的时代背景下也许是不存在的吧，或者是极其极其稀少的吧。 原书作者是这样描写的：“我们无比沉痛的获悉，原西县医院对秀莲的诊断结果是：肺癌。”感谢作者到此戛然而止，尽管知道以当时的医疗水平和条件，秀莲活下去的几率很低，但我们还是要对这个世界抱一点美好的幻想。 我也喜欢晓霞，自由、浪漫、敢说、敢做，美丽大方，才华出众。她仿佛不属于那个年代，她应该像一只鸟儿一样，飞向更广阔的天地，拥有属于自己的一片天。是她带着少平养成了看《参考消息》的好习惯，是她唤醒了少平胸中的热血，在她的推动和帮助下，少平渴望通过自己的努力来改变苦难的生活，改变这不公的命运，甚至改变世界。他们两个人从友谊到爱情，是感情上的升华，亦是心与心更近的沟通。正因为她的正直勇敢，敢闯敢拼，尤其是对工作认真对待的态度，身为一个报社记者，在大洪灾袭城时，她有着向广大民众传达灾区最新消息的责任。洪水无情似凶猛野兽，美丽的花朵凋谢了，看到这里我抑制不住的悲伤。我相信，美丽的花朵凋谢了也是美丽的。田晓霞太完美了，完美到作者也觉得她不适合在这个故事里。在网络上看到一句话 “爱情败给命运总比爱情败给世俗要好”，也许他们将是下一对少安与润叶，也许作者不忍再看到他们的爱情败给世俗，也许这才是最好的结局吧。 这平凡的世界里，只有平凡的人和事。这两个格格不入的完美女性不属于这个时代，也不属于这个世界。 书中每一个角色都是鲜活的，每个人都有自己的故事。就连双水村的田二都被作者描写的活灵活现。留下深刻印象的角色太多了，且不一一评说了。 《平凡的世界》电视剧剧版在保留原著核心的基础上进行二次创作，还原度之高令我惊讶。唯一不满意之处是晓霞死后，少平赴杜梨树下之约时居然出现了外星人，这过度改编让人很不舒服。 剧版似乎淡化了少平的主角，反观少安更像这部剧的主角。也许这与演员的演技和张力有关，王雷的少安深入人心，但袁弘的少平总觉得缺少点什么。 虽然我不是生长在黄土高原上的，但对剧中出现的一些民风民俗还是倍感亲切的。 “我们原是自由飞翔的鸟，飞去吧！飞到那乌云背后明媚的山峦，飞到那里，到那蓝色的海角。只有风在欢舞，还有我作伴。” 这是晓霞在铁轨上念给少平的诗歌，是对自由的渴望，对外面世界的追求，更是对少平的爱慕。他们的爱情充满了浪漫和现实主义，他们的交流是心灵与心灵的沟通。她爱他那掏碳的男人，他们相约会在古塔山后的杜梨树下见面，她要他带自己回村子里，以少平未婚妻的名义回去。 然而善良的她为救一个小女孩被洪水卷走了，抗洪指挥部的老父亲田福军一夜白头，只留下一句：“她是我女儿”。晓霞的离去配上凄凉的信天游，连老天都在哭泣，晓霞变成了一只自由飞翔的鸟，飞向了她一直追求的那一方天地。作者何其忍心写死晓霞，我多么希望电视剧对这里进行改编，她其实没有死，她在洪水的下游城市被人救了。 秀莲依旧是那么可爱和贤惠，在穷苦的家里任劳任怨。一心一意爱着这个庄稼汉，她给少安捞稠的饭，给少安拿奶奶吃的白面馍，她苦口婆心央求少安箍个新窑，然后却只得到了少安的回复：“额捶你啊…”看到这里，连弹幕都笑了，这么好的媳妇，打着灯笼都找不到，天天喊“捶”。如今不懂得珍惜，待到失去的时候后悔莫及啊。 最感动的是秀莲说，“少安哥，你命短，我给你延上。只要你愿意娶我，我就心甘情愿地跟你走，只要是我秀莲愿意，我不嫌穷，谁也不能说啥，这再说了，这穷怕什么，这穷又扎不下跟，将来我来帮你家过光景”。她包容他，嫁过去的第一天就说过：“你笑，我陪你笑，你流啥泪，我都替你抹”。她用自己的一生，在践行这句话。 感谢电视剧在最后一集留下了一个看似“完美”的结局，全村上下沉浸在临近过年的喜气洋洋的氛围中，以喜衬哀、笑中带泪的表现手法运用的淋漓尽致。最后桥上的那一段秀莲闭上眼后又缓缓苏醒看哭了我个男儿，他们的幸福生活来之不易，他们受了多少苦难和艰辛。时代在缓慢进步，人民生活在逐步变好，正是源于这一批勤劳的劳动人民和像田福军一样的改革先驱者的共同努力。 如尾声时的旁白所言，“双水村沉浸在一片欢腾和喜悦中，天真的孩子们欢快地笑着，有的大人却悄悄抹泪，哭、笑都是因为欢乐，哭的人知道，而笑的人不知道。” 至此，掩卷叹息。 我的心灵得以净化，灵魂得以洗涤，我对自己有了更准确的定位。 平凡的世界，正因为它的悲剧，体现了它的平凡，也造就了它的不平凡。 那是一个改革和奋斗的时代。而如今我们身处于一个人才泛滥，经济蓬勃发展，物质生活丰富却又精神迷惘混沌的时代，在这个时代里如何才能更好的体现出自己的价值，这正是我们值得思考的问题。 但我相信，提升自我能力是最正确的选择。在这平凡的世界里，我们只是一个平凡的普通人，但是一个平凡的人，也可以过得不平凡！ 只要平凡，却不甘于平凡。","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"SpringBoot 整合 Mybatis","slug":"SpringBoot-Mybatis1","date":"2019-09-28T06:32:56.000Z","updated":"2019-11-21T07:55:21.053Z","comments":true,"path":"SpringBoot-Mybatis1.html","link":"","permalink":"http://yoursite.com/SpringBoot-Mybatis1.html","excerpt":"SpringBoot 整合 Mybatis","text":"SpringBoot 整合 Mybatis 在 idea 按步骤新建 SpringBoot 项目。 若只选择了 Web 这个起步依赖，则需要进行 第 1、2 步。若勾选了 Mybatis 依赖和 MySQL Driver 依赖，则从 第 3 步 开始。 1. 添加 Mybatis 的起步依赖123456&lt;!-- mybatis 起步依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 2. 添加数据库驱动坐标123456&lt;!-- MySQL 连接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 此时的 pom.xml 文件为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.rk&lt;/groupId&gt; &lt;artifactId&gt;springboot_mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot_mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3. 添加数据库连接信息在 application.properties 中添加数据库的连接信息： 12345#DB Configuration:spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=root 4. 创建 user 表在 test 数据库中创建 user 表： 1234567891011121314151617-- ------------------------------ Table structure for `user`-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', 'zhangsan', '123', '张三');INSERT INTO `user` VALUES ('2', 'lisi', '123', '李四'); 表如下所示： 5. 创建实体 Bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.rk.domain;public class User &#123; // 主键 private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 6. 编写 Mapper1234567891011package com.rk.dao;import com.rk.domain.User;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface UserMapper &#123; public List&lt;User&gt; queryUserList();&#125; 注意：@Mapper 标记该类是一个 mybatis 的 mapper 接口，可以被 spring boot 自动扫描到 spring 上下文中。 7. 配置 Mapper 映射文件在 src\\main\\resources\\mapper 路径下加入 UserMapper.xml 配置文件： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.rk.dao.UserMapper\"&gt; &lt;select id=\"queryUserList\" resultType=\"com.rk.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 8. 在 application.properties 中添加 mybatis 配置信息12345#spring集成Mybatis环境#pojo别名扫描包mybatis.type-aliases-package=com.rk.domain#加载Mybatis映射文件mybatis.mapper-locations=classpath:mapper/*Mapper.xml 9. 编写测试 Controller123456789101112131415161718192021222324package com.rk.controller;import com.rk.dao.UserMapper;import com.rk.domain.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;@Controllerpublic class MapperController &#123; @Autowired private UserMapper userMapper; @ResponseBody @RequestMapping(\"/queryUser\") public List&lt;User&gt; queryUser()&#123; List&lt;User&gt; users = userMapper.queryUserList(); return users; &#125;&#125; 10. 测试结果链接：http://localhost:8080/queryUser 结果：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot 配置文件","slug":"SpringBoot-config","date":"2019-08-17T02:56:19.000Z","updated":"2019-08-28T16:34:02.911Z","comments":true,"path":"SpringBoot-config.html","link":"","permalink":"http://yoursite.com/SpringBoot-config.html","excerpt":"Spring Boot 配置文件","text":"Spring Boot 配置文件 配置文件 SpringBoot 使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language）: YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言 标记语言： 以前的配置文件；大多都使用的是 xxxx.xml 文件； ​YAML：以数据为中心，比 json、xml 等更适合做配置文件； YAML：配置例子 12server: port: 8081 ​XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML 语法 基本语法k:(空格)v：表示一对键值对（空格必须有）； 以 空格 的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感。 值的写法字面量：普通的值（数字，字符串，布尔）​- k: v：字面量直接来写； ​- 字符串默认不用加上单引号或者双引号； ​&quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 123​name: &quot;zhangsan \\n lisi&quot;输出：zhangsanlisi &#39;&#39;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 123name: ‘zhangsan \\n lisi’输出：zhangsan \\n lisi 对象、Map（属性和值）（键值对）k: v：在下一行来写对象的属性和值的关系；注意缩进。 ​对象还是 k: v 的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法： 1pets: [cat,dog,pig] 配置文件值注入 配置文件： 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了： 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; properties 配置文件在 idea 中默认 utf-8 可能会乱码设置： idea 配置乱码 @Value 获取值和 @ConfigurationProperties 获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用 @Value； 如果说，我们专门编写了一个 javaBean 来和配置文件进行映射，我们就直接使用 @ConfigurationProperties。 配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @PropertySource &amp; @ImportResource &amp; @Bean@PropertySource：加载指定的配置文件。 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效。 Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别。 想让 Spring 的配置文件生效，将其加载进来；使用 @ImportResource 标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)// 导入Spring的配置文件让其生效 不来编写 Spring 的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot 推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类 @Configuration ——&gt; Spring 配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; 配置文件占位符 随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 占位符获取之前配置的值，如果没有可以使用 指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 Profile 多 Profile 文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用 application.properties 的配置。 yml 支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定 profile​1、在配置文件中指定 spring.profiles.active=dev ​2、命令行： 1​java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev； ​可以直接在测试的时候，配置传入命令行参数： 配置传入命令行参数 ​3、虚拟机参数（JVM）； 1-Dspring.profiles.active=dev 配置虚拟机参数 配置文件加载位置 Spring boot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件。 file:./config/ file:./ classpath:/config/ classpath:/ 其中 file 表示当前项目文件路径下（项目/），classpath 表示类路径（项目/src/main/resources）。 优先级 由高到底，高优先级的配置会覆盖低优先级的配置； Spring Boot 会从这四个位置全部加载主配置文件；互补配置 我们还可以通过 spring.config.location 来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定的配置文件和默认加载的这些配置文件共同起作用形成互补配置。 1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=D:/application.properties 外部配置加载顺序 Spring Boot 也可以从以下位置加载配置,优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。 1） 命令行参数 所有的配置都可以在命令行上进行指定： 1java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc 多个配置用空格分开； --配置项=值 2） 来自 java:comp/env 的 JNDI 属性 3） Java 系统属性（System.getProperties()） 4） 操作系统环境变量 5） RandomValuePropertySource 配置的 random.* 属性值 由 jar 包外向 jar 包内进行寻找； 优先加载带 profile 的配置 6） jar 包外部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 ★ 7） jar 包内部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 ★ 再来加载不带profile 8） jar 包外部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 ★ 9） jar 包内部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 ★ 10） @Configuration 注解类上的外部配置文件 @PropertySource 11） 通过 SpringApplication.setDefaultProperties 指定的默认属性。 所有支持的配置加载来源参考官方文档： 参考官方文档 自动配置原理配置文件到底能写什么？怎么写？自动配置原理是什么？ 配置文件能配置的属性参照 自动配置原理：1）、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration 2）、@EnableAutoConfiguration 作用： 利用 EnableAutoConfigurationImportSelector 给容器中导入一些组件？ 可以查看 selectImports() 方法的内容； List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); 获取候选的配置。 SpringFactoriesLoader.loadFactoryNames()，扫描所有 jar 包类路径下（META-INF/spring.factories），把扫描到的这些文件的内容包装成 properties 对象，从 properties 中获取到 EnableAutoConfiguration.class 类（类名）对应的值，然后把他们添加在容器中. 将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置。 3）、每一个自动配置类进行自动配置功能； 4）、以 HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理； 123456789101112131415161718192021222324252627282930@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)//判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的。 5）、所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类。 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： 1）、SpringBoot 启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：是做自动配置的类，会给容器中添加组件。 xxxxProperties：封装配置文件中相关的属性。 细节@Conditional 派生注解（Spring 注解版原生的 @Conditional 作用）作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional 扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的 java 版本是否符合要求 @ConditionalOnBean 容器中存在指定 Bean； @ConditionalOnMissingBean 容器中不存在指定 Bean； @ConditionalOnExpression 满足 SpEL 表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的 Bean，或者这个 Bean 是首选 Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是 web 环境 @ConditionalOnNotWebApplication 当前不是 web 环境 @ConditionalOnJndi JNDI 存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true 属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot 快速入门","slug":"SpringBoot-abc","date":"2019-08-14T10:34:21.000Z","updated":"2019-08-28T01:46:09.267Z","comments":true,"path":"SpringBoot-abc.html","link":"","permalink":"http://yoursite.com/SpringBoot-abc.html","excerpt":"Spring Boot 快速入门","text":"Spring Boot 快速入门 SpringBoot 简介 简化 Spring 应用开发的一个框架； 整个 Spring 技术栈的一个大整合； J2EE 开发的一站式解决方案； 优点： 快速创建独立运行的 Spring 项目以及与主流框架集成 使用嵌入式的 Servlet 容器，应用无需打成 war 包 starters 自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置 XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 微服务 2014 年，martin fowler 发表了一篇关于微服务的文章。 微服务：是一种架构风格（服务微化） 一个应用应该是一组小型服务；可以通过 HTTP 的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元。 详细参照微服务文档 环境准备 环境约束： jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_131” maven3.x：maven 3.3以上版本；Apache Maven 3.6.1 IntelliJ IDEA 2018：IntelliJ IDEA 2018.3.6 x64 SpringBoot 2.1.7.RELEASE：2.1.7； 统一环境；1、MAVEN设置；给 maven 的 settings.xml 配置文件的 profiles 标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合 maven 进来； idea 设置 4、Spring Boot 入门程序（HelloWorld）一个功能： 浏览器发送 hello 请求，服务器接受请求并处理，响应 Hello World 字符串； 1、创建一个maven工程；（jar）2、导入 spring boot 相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动 Spring Boot 应用12345678910/** * @SpringBootApplication 来标注一个主程序类，说明这是一个 Spring Boot 应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的 Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789 &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 将这个应用打成 jar 包，直接使用 java -jar 的命令进行执行； Hello World 探究 POM 文件父项目123456789101112131415&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;!-- 他的父项目是 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;&lt;!-- 他来真正管理 Spring Boot 应用里面的所有依赖版本；--&gt; Spring Boot 的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在 dependencies 里面管理的依赖自然需要声明版本号） 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： spring-boot-starter：spring-boot 场景启动器；帮我们导入了 web 模块正常运行所依赖的组件； Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters （启动器），只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot 应用标注在某个类上说明这个类是 Spring Boot 的主配置类，Spring Boot 就应该运行这个类的 main 方法来启动 Spring Boot 应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration: Spring Boot 的配置类； 标注在某个类上，表示这是一个 Spring Boot 的配置类； @Configuration:配置类上来标注这个注解； 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 以前我们需要配置的东西，Spring Boot 会帮我们自动配置；@EnableAutoConfiguration告诉 SpringBoot 开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​@AutoConfigurationPackage：自动配置包 ​@Import(AutoConfigurationPackages.Registrar.class)： ​Spring 的底层注解 @Import，给容器中导入一个组件；导入的组件由 AutoConfigurationPackages.Registrar.class； 将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； ​@Import(EnableAutoConfigurationImportSelector.class)； ​给容器中导入组件？ ​EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； Spring Boot在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们配置了； J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-2.1.7.RELEASE.jar； 使用 Spring Initializer 快速创建Spring Boot项目 IDEA：使用 Spring Initializer快速创建项目IDE 都支持使用 Spring 的项目创建向导快速创建一个 Spring Boot 项目； 选择我们需要的模块；向导会联网创建 Spring Boot 项目； 默认生成的 Spring Boot 项目； 主程序已经生成好了，我们只需要编写自己的业务逻辑就行了 resources 文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置；","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"欢迎来到任凯的个人博客~","slug":"notice","date":"2019-06-01T04:07:46.000Z","updated":"2019-12-02T02:28:46.498Z","comments":true,"path":"notice.html","link":"","permalink":"http://yoursite.com/notice.html","excerpt":"","text":"因求职和写毕业论文，精力不足，停更大半年！","categories":[],"tags":[]},{"title":"WebGIS：Tomcat 离线部署 ArcGIS API for JavaScript（v4.9）","slug":"WebGIS-tomcat-arcgis_js_api49","date":"2018-10-10T08:23:45.000Z","updated":"2018-10-10T08:42:29.522Z","comments":true,"path":"WebGIS-tomcat-arcgis_js_api49.html","link":"","permalink":"http://yoursite.com/WebGIS-tomcat-arcgis_js_api49.html","excerpt":"","text":"下载 API 和 SDK 文件下载地址：https://developers.arcgis.com/downloads/apis-and-sdks?product=javascript 注：需要登录。 选择自己需要的版本下载对应的 API 和 SDK 包。这里以 4.9 版本为例。 部署Tomcat 下解压Tomcat 服务器 webapps 文件夹下建立一个你的项目文件夹用来放置 api 和 sdk 。 例如我新建一个 api49 文件夹：D:\\apache-tomcat-7.0.52\\webapps\\api49 将下载的 api 和 sdk 解压到这个目录下（目录结构如下图）： 修改文件注：Tomcat 默认端口为：localhost:8080 找到 D:\\apache-tomcat-7.0.52\\webapps\\api49\\arcgis_js_api\\library\\4.9\\init.js 文件，将 [HOSTNAME_AND_PATH_TO_JSAPI] 修改为 /localhost:8080/api49/arcgis_js_api/library/4.9/ 。注意把原来的 https 改为 http 。 即 init.js 里面变为：baseUrl:&quot;http://localhost:8080/api49/arcgis_js_api/library/4.9/dojo&quot; 找到 D:\\apache-tomcat-7.0.52\\webapps\\api49\\arcgis_js_api\\library\\4.9\\dojo\\dojo.js 文件，将 [HOSTNAME_AND_PATH_TO_JSAPI] 修改为 /localhost:8080/api49/arcgis_js_api/library/4.9/ 。注意把原来的 https 改为 http 。 即 dojo.js 里面变为：baseUrl:&quot;http://localhost:8080/api49/arcgis_js_api/library/4.9/dojo&quot; 测试部署在 api49 目录下新建一个 test.html : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1,user-scalable=no\" /&gt; &lt;title&gt;Test Map&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://localhost:8080/api49/arcgis_js_api/library/4.9/dijit/themes/claro/claro.css\" /&gt; &lt;link rel=\"stylesheet\" href=\"http://localhost:8080/api49/arcgis_js_api/library/4.9/esri/css/main.css\" /&gt; &lt;style&gt; html, body, #viewDiv &#123; margin: 0; padding: 0; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;script src=\"http://localhost:8080/api49/arcgis_js_api/library/4.9/dojo/dojo.js\"&gt;&lt;/script&gt; &lt;script&gt; var myMap, view; require([ \"esri/Basemap\", \"esri/layers/TileLayer\", \"esri/Map\", \"esri/views/MapView\", \"dojo/domReady!\" ], function (Basemap, TileLayer, Map, MapView)&#123; // -------------------------------------------------------------------- // If you do not have public Internet access then use the Basemap class // and point this URL to your own locally accessible cached service. // // Otherwise you can just use one of the named hosted ArcGIS services. // https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer // -------------------------------------------------------------------- var layer = new TileLayer(&#123; url: \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer\" &#125;); var customBasemap = new Basemap(&#123; baseLayers: [layer], title: \"Custom Basemap\", id: \"myBasemap\" &#125;); myMap = new Map(&#123; basemap: customBasemap &#125;); view = new MapView(&#123; center: [-111.87, 40.57], // long, lat container: \"viewDiv\", map: myMap, zoom: 6 &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body class=\"claro\"&gt; &lt;div id=\"viewDiv\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 启动 Tomcat 服务器，浏览器访问：http://localhost:8080/api49/test.html 若显示下图，则说明部署成功！","categories":[{"name":"WebGIS","slug":"WebGIS","permalink":"http://yoursite.com/categories/WebGIS/"}],"tags":[{"name":"WebGIS","slug":"WebGIS","permalink":"http://yoursite.com/tags/WebGIS/"}]},{"title":"JavaWeb 之 SSH 框架整合","slug":"JavaWeb-SSH01","date":"2018-08-14T06:51:00.000Z","updated":"2018-08-13T13:52:33.027Z","comments":true,"path":"JavaWeb-SSH01.html","link":"","permalink":"http://yoursite.com/JavaWeb-SSH01.html","excerpt":"SSH 框架整合","text":"SSH 框架整合 SSH 框架整合的环境准备 SSH 三大框架需要的 jar包Struts2 框架 struts-2.3.24\\apps\\struts2-blank\\WEB-INF\\lib\\*.jar————Struts2 需要的所有 jar 包struts2-spring-plugin-2.3.24.jar————Struts2 整合 Spring 的插件包 Hibernate 框架 hibernate-release-5.0.7.Final\\lib\\required\\*.jar————Hibernate 框架需要的 jar 包slf4j-api-1.6.1.jar————日志接口slf4j-log4j12-1.7.2.jar————日志实现mysql-connector-java-5.1.7-bin.jar————MySQL 的驱动包 Spring 框架 IoC 核心包（6个）AOP 核心包（4个）JDBC 模板和事务核心包（2个）Spring 整合 JUnit 测试包Spring 整合 Hibernate 核心包Spring 整合 Struts2 核心包 SSH 三大框架需要的配置文件Struts2 框架 在 web.xml 中配置核心的过滤器 12345678910&lt;!--配置 Struts2 框架核心的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在 src 目录下创建 struts.xml，用来配置 Action Hibernate 框架 在 src 目录创建 hibernate.cfg.xml 配置文件 123456789101112131415161718192021&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须配置 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///ssh01&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;541638&lt;/property&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 配置C3P0的连接池 --&gt; &lt;property name=\"connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 映射配置文件 --&gt; &lt;mapping resource=\"com/renkaigis/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 在 JavaBean 所在的包下编写 映射的配置文件：JavaBean类名.hbm.xml Spring 框架 在 web.xml 配置整合 WEB 的监听器 12345678&lt;!--配置 Spring 框架整合 WEB 的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 在 src 目录下创建 applicationContext.xml 在 src 目录下加入 log4j.proerties Spring 框架整合 Struts2 框架 表单访问 Action 导入 CRM 项目的 UI 页面，找到添加客户的页面，修改 form 表单，访问 Action。 编写 CustomerAction 接收请求，在 struts.xml 中完成 Action 的配置12345&lt;!--先配置包结构--&gt;&lt;package name=\"crm\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--配置客户的 Action--&gt; &lt;action name=\"customer_*\" class=\"com.renkaigis.web.action.CustomerAction\" method=\"&#123;1&#125;\"/&gt;&lt;/package&gt; 模型驱动封装数据编写好客户的 JavaBean，在 Action 中使用模型驱动来封装数据。 12345678910111213141516171819202122/** * 客户的控制层 */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; // 不要忘记自己手动 new private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; /** * 保存客户的方法 * * @return */ public String add() &#123; System.out.println(\"WEB 层：保存客户…\"); System.out.println(customer); return NONE; &#125;&#125; 在 Action 中获取到 service（开发不会使用，因为麻烦）可以通过 WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext()); 来获取，但是这种方式编写代码太麻烦了！ Spring 整合 Struts2 框架的第一种方式（Action 由 Struts2 框架来创建） 因为导入的 struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml ，该配置文件中有如下代码 1&lt;constant name=\"struts.objectFactory\" value=\"spring\" /&gt; 开启一个常量，如果该常量开启，那么下面的常量就可以使用 struts.objectFactory.spring.autoWire = name，该常量是可以让 Action 的类来自动装配 Bean 对象！ CustomerService.java： 123456// 提供 service 的成员属性，提供 set 方法private CustomerService customerService;public void setCustomerService(CustomerService customerService) &#123; this.customerService = customerService;&#125; Spring 整合 Struts2 框架的第二种方式（Action 由 Spring 框架来创建）（强烈推荐） 把具体的 Action 类配置到 applicatonContext.xml 的配置文件中，但是注意 struts.xml 需要做修改： applicationContext.xml 12345678&lt;!--配置客户模块--&gt;&lt;!--强调：配置 Aciton，必须是多例的--&gt;&lt;bean id=\"customerAction\" class=\"com.renkaigis.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;property name=\"customerService\" ref=\"customerService\"/&gt;&lt;/bean&gt;&lt;bean id=\"customerService\" class=\"com.renkaigis.service.CustomerServiceImpl\"&gt;&lt;/bean&gt; struts.xml 中的修改，把全路径修改成 ID 值 1234&lt;package name=\"crm\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--配置客户的 Action，如果 Action 是由 Spring 框架来管理，class 标签只需要去编写 id 值就ok了--&gt; &lt;action name=\"customer_*\" class=\"customerAction\" method=\"&#123;1&#125;\"/&gt;&lt;/package&gt; 第二种方式需要有两个注意的地方 Spring 框架默认生成 CustomerAction 是单例的，而 Struts2 框架是多例的。所以需要配置 scope=&quot;prototype&quot;CustomerService 现在必须自己手动注入了。 Spring 框架整合 Hibernate 框架 Spring 框架整合 Hibernate 框架（有配置文件）（带有 hibernate.cfg.xml 的配置文件。强调：不能加绑定当前线程的配置） 编写 CustomerDaoImpl 的代码，加入配置并且在 CustomerServiceImpl 中完成注入CustomerDaoImpl.java： 1234567891011121314/** * 持久层 */public class CustomerDaoImpl implements CustomerDao &#123; /** * 保存客户 * * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户…\"); &#125;&#125; CustomerServiceImpl.java： 1234567891011121314151617181920/** * 客户的业务层 */public class CustomerServiceImpl implements CustomerService &#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; /** * 保存客户 * * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"业务层：保存客户…\"); customerDao.save(customer); &#125;&#125; 实现步骤：Action 调用 Service ，Service 调用 Dao 编写映射的配置文件Customer.hbm.xml： 12345678910111213141516&lt;hibernate-mapping&gt; &lt;class name=\"com.renkaigis.domain.Customer\" table=\"cst_customer\"&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"cust_name\" column=\"cust_name\"/&gt; &lt;property name=\"cust_user_id\" column=\"cust_user_id\"/&gt; &lt;property name=\"cust_create_id\" column=\"cust_create_id\"/&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在 hibernate.cfg.xml 的配置文件中引入映射的配置文件 12&lt;!-- 映射配置文件 --&gt;&lt;mapping resource=\"com/renkaigis/domain/Customer.hbm.xml\"/&gt; 在 applicationContext.xml 中配置加载 hibernate.cfg.xml1234&lt;!--编写 Bean，名称都是固定的，加载 hibernate.cfg.xml 配置文件--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\"/&gt;&lt;/bean&gt; Dao 继承 HibernateDaoSupport 的工具类在 CustomerDaoImpl 中想完成数据的添加，Spring 框架提供了一个 HibernateDaoSupport 的工具类，以后 DAO 都可以继承该类！ CustomerDaoImpl.java： 12345678910111213141516/** * 持久层 */public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao &#123; /** * 保存客户 * * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户…\"); // 把数据保存到数据库 this.getHibernateTemplate().save(customer); &#125;&#125; applicationContext.xml： 1234&lt;!--以后开发：Dao 都需要继承 HibernateDaoSupport，注入 sessionFactory--&gt;&lt;bean id=\"customerDao\" class=\"com.renkaigis.dao.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 开启事务的配置 先配置事务管理器，注意现在使用的是 Hibernate 框架，所以需要使用 Hibernate 框架的事务管理器 1234&lt;!--配置平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 开启注解事务 12&lt;!--开启事务的注解--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 在 Service 类中添加事务注解 1234567891011121314151617181920/** * 客户的业务层 */@Transactionalpublic class CustomerServiceImpl implements CustomerService &#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; /** * 保存客户 * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"业务层：保存客户…\"); customerDao.save(customer); &#125;&#125; Spring 框架整合 Hibernate 框架（无配置文件）（不带有 hibernate.cfg.xml 的配置文件） 整合要不带有 hibernate.cfg.xml 的配置文件，则需要将 hibernate.cfg.xml 中的配置移植到 applicationContext.xml 中。具体操作如下： Hibernate 配置文件中的配置 数据库连接基本参数（4 大参数） Hibernate 相关的属性 连接池 映射文件 开始进行配置 先配置连接池相关的信息 1234567&lt;!--配置 C3P0 连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssh01\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"541638\"/&gt;&lt;/bean&gt; 修改 LocalSessionFactoryBean 的属性配置，因为已经没有了 hibernate.cfg.xml 配置文件，所以需要修改该配置，注入连接池： &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 继续在 LocalSessionFactoryBean 中配置，使用 hibernateProperties 属性继续来配置其他的属性，注意值是 properties 属性文件： applicationContext.xml： 1234567891011121314151617181920&lt;!--LocalSessionFactoryBean 加载配置文件--&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!--加载连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--加载方言，加载可选项--&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--加载映射配置文件--&gt; &lt;property name=\"mappingResources\"&gt; &lt;list&gt; &lt;value&gt;com/renkaigis/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 延迟加载问题no session 异常使用延迟加载的时候，在 WEB 层查询对象的时候程序会抛出异常！ 原因是延迟加载还没有发生 SQL 语句，在业务层 session 对象就已经销毁了，所以查询到的 JavaBean 对象已经变成了托管态对象！ 注意：一定要先删除 javassist-3.11.0.GA.jar 包（jar包冲突了） 解决方法解决办法非常简单，Spring 框架提供了一个过滤器，让 session 对象在 WEB 层就创建，在 WEB 层销毁。只需要配置该过滤器即可。 但是：要注意需要在 struts2 的核心过滤器之前进行配置： 123456789&lt;!-- 解决延迟加载的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 终极版 SSH 整合 配置文件web.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--配置 Spring 框架整合 WEB 的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 解决延迟加载的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置 Struts2 框架核心的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; struts.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"crm\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--配置客户的 Action--&gt; &lt;action name=\"customer_*\" class=\"customerAction\" method=\"&#123;1&#125;\"/&gt; &lt;/package&gt;&lt;/struts&gt; application.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--配置 C3P0 连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssh01\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"541638\"/&gt; &lt;/bean&gt; &lt;!--LocalSessionFactoryBean 加载配置文件--&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!--加载连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--加载方言，加载可选项--&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--加载映射配置文件--&gt; &lt;property name=\"mappingResources\"&gt; &lt;list&gt; &lt;value&gt;com/renkaigis/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--先配置平台事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt; &lt;!--开启事务的注解--&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;!--配置客户模块--&gt; &lt;!--强调：配置 Aciton，必须是多例的--&gt; &lt;bean id=\"customerAction\" class=\"com.renkaigis.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;property name=\"customerService\" ref=\"customerService\"/&gt; &lt;/bean&gt; &lt;bean id=\"customerService\" class=\"com.renkaigis.service.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"/&gt; &lt;/bean&gt; &lt;!--以后开发：Dao 都需要继承 HibernateDaoSupport，注入 sessionFactory--&gt; &lt;bean id=\"customerDao\" class=\"com.renkaigis.dao.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; log4j.properties123456789101112131415### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c\\:mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###log4j.rootLogger=info, stdout WEB 项目控制层CustomerAction.java ，继承 ActionSupport 类，使用 模型驱动 封装数据（记得手动 new，手动实例化 JavaBean）。 123456789101112131415161718192021222324252627282930313233343536package com.renkaigis.web.action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.renkaigis.domain.Customer;import com.renkaigis.service.CustomerService;/** * 客户的控制层 */public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; // 不要忘记自己手动 new private Customer customer = new Customer(); @Override public Customer getModel() &#123; return customer; &#125; // 提供 service 的成员属性，提供 set 方法 private CustomerService customerService; public void setCustomerService(CustomerService customerService) &#123; this.customerService = customerService; &#125; /** * 保存客户的方法 * * @return */ public String add() &#123; System.out.println(\"WEB 层：保存客户…\"); customerService.save(customer); return NONE; &#125;&#125; 业务层CustomerServiceImpl.java，添加事务注解，处理业务逻辑，调用持久层。 1234567891011121314151617181920212223242526272829303132package com.renkaigis.service;import com.renkaigis.dao.CustomerDao;import com.renkaigis.domain.Customer;import org.springframework.transaction.annotation.Transactional;/** * 客户的业务层 */@Transactionalpublic class CustomerServiceImpl implements CustomerService &#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; /** * 保存客户 * * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"业务层：保存客户…\"); customerDao.save(customer); &#125; @Override public void update(Customer customer) &#123; customerDao.update(customer); &#125;&#125; 持久层CustomerDaoImpl.java，继承 HibernateDaoSupport 类，使用 Hibernate 模板类实现 Java 类与数据库之间的转换和访问。 12345678910111213141516171819202122232425package com.renkaigis.dao;import com.renkaigis.domain.Customer;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;/** * 持久层 */public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao &#123; /** * 保存客户 * @param customer */ @Override public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户…\"); // 把数据保存到数据库 this.getHibernateTemplate().save(customer); &#125; @Override public void update(Customer customer) &#123; this.getHibernateTemplate().update(customer); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"}]},{"title":"JavaWeb 之 Spring 事务管理","slug":"JavaWeb-Spring05","date":"2018-08-11T14:12:50.000Z","updated":"2018-08-13T02:26:33.228Z","comments":true,"path":"JavaWeb-Spring05.html","link":"","permalink":"http://yoursite.com/JavaWeb-Spring05.html","excerpt":"Spring 事务管理","text":"Spring 事务管理 事务 概念事务：指的是逻辑上的一组操作，组成这个事务的各个执行单元，要么一起成功，要么一起失败！ 事务的特性 原子性 一致性 隔离性 持久性 安全性问题如果不考虑隔离性,引发安全性问题 读问题: 脏读不可重复读虚读 写问题: 丢失更新 如何解决安全性问题 读问题解决，设置数据库隔离级别 写问题解决可以使用 悲观锁 和 乐观锁 的方式解决 Spring 框架的事务管理 Spring 框架的事务管理相关的类和 API接口 PlatformTransactionManager接口————平台事务管理器。（真正管理事务的类）。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类！ TransactionDefinition接口————事务定义信息。（事务的隔离级别，传播行为，超时，只读） TransactionStatus接口————事务的状态 总结：上述对象之间的关系：平台事务管理器真正管理事务对象。根据事务定义的信息 TransactionDefinition 进行事务管理，在管理事务中产生一些状态，将状态记录到 TransactionStatus 中。 PlatformTransactionManager 接口中实现类和常用的方法 接口的实现类 如果使用的 Spring 的 JDBC 模板或者 MyBatis 框架，需要选择 DataSourceTransactionManager 实现类如果使用的是 Hibernate 的框架，需要选择 HibernateTransactionManager 实现类 该接口的常用方法 void commit(TransactionStatus status)TransactionStatus getTransaction(TransactionDefinition definition)void rollback(TransactionStatus status) TransactionDefinition 接口中实现类和常用的方法 事务隔离级别的常量 static int ISOLATION_DEFAULT————采用数据库的默认隔离级别static int ISOLATION_READ_UNCOMMITTEDstatic int ISOLATION_READ_COMMITTEDstatic int ISOLATION_REPEATABLE_READstatic int ISOLATION_SERIALIZABLE 事务的传播行为常量（不用设置，使用默认值） 事务的传播行为：解决的是业务层之间的方法调用！ PROPAGATION_REQUIRED（默认值）————A 中有事务，使用 A 中的事务。如果没有，B 就会开启一个新的事务，将 A 包含进来。（保证 A，B 在同一个事务中），默认值！PROPAGATION_SUPPORTS————A 中有事务，使用 A 中的事务。如果 A 中没有事务，那么 B 也不使用事务。PROPAGATION_MANDATORY————A 中有事务，使用 A 中的事务。如果 A 没有事务，抛出异常。 PROPAGATION_REQUIRES_NEW（记）————A 中有事务，将 A 中的事务挂起。B 创建一个新的事务。（保证 A，B 没有在一个事务中）PROPAGATION_NOT_SUPPORTED————A 中有事务，将 A 中的事务挂起。PROPAGATION_NEVER————A 中有事务，抛出异常。 PROPAGATION_NESTED（记）————嵌套事务。当 A 执行之后，就会在这个位置设置一个保存点。如果 B 没有问题，执行通过。如果 B 出现异常了，运行客户根据需求回滚（选择回滚到保存点或者是最初始状态） 搭建事务管理转账案例的环境（强调：简化开发，以后 DAO 可以继承 JdbcDaoSupport 类） 步骤一：创建 WEB 工程，引入需要的 jar 包 IoC 的 6 个包AOP 的 4 个包C3P0 的 1 个包MySQL 的驱动包JDBC 模板 2 个包整合 JUnit 测试包 步骤二：引入配置文件 引入配置文件 引入 log4j.properties 引入 applicationContext.xml 1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;/beans&gt; 步骤三：创建对应的包结构和类 com.itheima.demo2 AccountServiceAccountServlceImplAccountDaoAccountDaoImpl 步骤四：引入 Spring 的配置文件，将类配置到 Spring 中12345&lt;bean id=\"accountService\" class=\"com.renkaigis.demo2.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"accountDao\" class=\"com.renkaigis.demo2.AccountDaoImpl\"&gt;&lt;/bean&gt; 步骤五：在业务层注入 DAO ,在 DAO 中注入 JDBC 模板（强调：简化开发，DAO 可以继承 JdbcDaoSupport 类） 1234567&lt;bean id=\"accountService\" class=\"com.renkaigis.demo2.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt;&lt;/bean&gt;&lt;bean id=\"accountDao\" class=\"com.renkaigis.demo2.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 步骤六：编写 DAO 和 Service 中的方法Service： 12345678910111213141516public class AccountServiceImpl implements AccountService &#123; @Resource(name = \"accountDao\") private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void pay(String out, String in, double money) &#123; // 先扣钱 accountDao.outMoney(out, money); // 后加钱 accountDao.inMoney(in, money); &#125;&#125; DAO： 123456789101112public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; // 扣钱 @Override public void outMoney(String out, double money) &#123; this.getJdbcTemplate().update(\"update t_account set money = money - ? where name = ?\", money, out); &#125; // 加钱 @Override public void inMoney(String in, double money) &#123; this.getJdbcTemplate().update(\"update t_account set money = money + ? where name = ?\", money, in); &#125;&#125; 步骤七：编写测试程序1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1 &#123; @Resource(name = \"accountService\") private AccountService accountService; @Test public void run1() &#123; accountService.pay(\"小关\", \"小西\", 1000); &#125;&#125; Spring 框架事务管理的分类 Spring 的编程式事务管理（不推荐使用） 通过手动编写代码的方式完成事务的管理（不推荐） Spring 的声明式事务管理（底层采用 AOP 的技术） 通过一段配置的方式完成事务的管理（重点掌握注解的方式） Spring 框架事务管理之编程式事务管理（了解）说明：Spring 为了简化事务管理的代码：提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可！ 步骤一：配置一个事务管理器Spring 使用 PlatformTransactionManager 接口来管理事务，所以需要使用到他的实现类！ 1234&lt;!--配置平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 步骤二：配置事务管理的模板1234&lt;!--手动编码，提供了模板类，使用该类管理事务比较简单--&gt;&lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;&lt;/bean&gt; 步骤三：在需要进行事务管理的类中，注入事务管理的模板1234&lt;bean id=\"accountService\" class=\"com.renkaigis.demo2.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt; &lt;property name=\"transactionTemplate\" ref=\"transactionTemplate\"/&gt;&lt;/bean&gt; 步骤四：在业务层使用模板管理事务123456789101112131415161718192021222324252627public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; // 注入事务的模板类 private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; @Override public void pay(String out, String in, double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123; accountDao.outMoney(out, money); // 模拟异常 // int a = 10 / 0; accountDao.inMoney(in, money); &#125; &#125;); &#125;&#125; Spring 框架事务管理之声明式事务管理即通过配置文件来完成事务管理（AOP 思想） 声明式事务管理又分成两种方式 基于 AspectJ 的 XML 方式（重点掌握）基于 AspectJ 的注解方式（重点掌握） Spring 框架事务管理之基于 AspectJ 的 XML 方式（重点掌握）步骤一：恢复转账开发环境步骤二：引入 AOP 的开发包步骤三：配置事务管理器1234&lt;!--配置平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 步骤四：配置事务增强1234567&lt;!--先配置通知--&gt;&lt;tx:advice id=\"myAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!--aop:advisor，是 Spring 框架提供的通知--&gt; &lt;tx:method name=\"pay\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; name：绑定事务的方法名，可以使用通配符，可以配置多个。propagation：传播行为isolation：隔离级别read-only：是否只读timeout：超时信息rollback-for：发生哪些异常回滚no-rollback-for：发生哪些异常不回滚 步骤五：配置 AOP 的切面1234&lt;!--配置 AOP：如果是自己编写的 AOP，使用 aop:aspect 配置，使用的是 Spring 提供的通知用 aop:advisor--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"myAdvice\" pointcut=\"execution(public * com.renkaigis.demo3.AccountServiceImpl.pay(..))\"/&gt;&lt;/aop:config&gt; 注意：如果是自己编写的切面，使用 &lt;aop:aspect&gt; 标签，如果是系统提供的，使用 &lt;aop:advisor&gt; 标签。 步骤六：编写测试类1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo2 &#123; @Resource(name = \"accountService\") private AccountService accountService; @Test public void run1() &#123; accountService.pay(\"小关\", \"小西\", 1000); &#125;&#125; Spring 框架事务管理之基于 AspectJ 的注解方式（重点掌握，最简单的方式） 步骤一：恢复转账的开发环境步骤二：配置事务管理器同上。 步骤三：开启注解事务12&lt;!--开启事务的注解--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 步骤四：在业务层上添加一个注解：@Transactional123456789101112131415161718/** * Transactional 类上添加注解，类中的方法全部就都有了事务 */@Transactionalpublic class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void pay(String out, String in, double money) &#123; accountDao.outMoney(out, money); // 模拟异常 // int a = 10 / 0; accountDao.inMoney(in, money); &#125;&#125; 步骤五：编写测试类1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext3.xml\")public class Demo2 &#123; @Resource(name = \"accountService\") private AccountService accountService; @Test public void run1() &#123; accountService.pay(\"小关\", \"小西\", 1000); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaWeb 之 Spring JDBC 模板技术","slug":"JavaWeb-Spring04","date":"2018-08-11T05:23:47.000Z","updated":"2018-08-12T12:51:19.276Z","comments":true,"path":"JavaWeb-Spring04.html","link":"","permalink":"http://yoursite.com/JavaWeb-Spring04.html","excerpt":"Spring JDBC 模板技术","text":"Spring JDBC 模板技术 Spring 框架的 JDBC 模板技术 Spring 框架的 JDBC 模板技术概述 Spring 框架中提供了很多持久层的模板类来简化编程，使用模板类编写程序会变的简单。 提供了 JDBC 模板，Spring 框架提供的 JdbcTemplate类 Spring 框架可以整合 Hibernate 框架，也提供了模板类 HibernateTemplate类 演示 JDBC 的模板类步骤一：创建数据库的表结构1234567create database spring04;use spring04;create table t_account( id int primary key auto_increment, name varchar(20), money double); 步骤二：引入开发的 jar 包 先引入 IoC 基本的 jar 包（6个），还有1个 test 的包 再引入 Spring-aop 的 jar 包（1个） 最后引入 JDBC模板 需要的 jar 包： MySQL 数据库的驱动包：mysql-connector-java-5.1.7-bin.jarSpring-jdbc.jar事务管理：Spring-tx.jar 一共 11 个包。 步骤三：编写测试代码（自己来 new 对象的方式）new 对象的方式： 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1 &#123; /** * 演示模板类 */ @Test public void run1() &#123; // Spring 框架提供了内置的连接池，不想使用内置，整合其他的连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql:///spring04\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"541638\"); // 创建模板类 JdbcTemplate template = new JdbcTemplate(); // 设置连接池 template.setDataSource(dataSource); // 完成操作 template.update(\"insert into t_account values (null,?,?)\", \"小西\", 10000); &#125;&#125; 使用 Spring 框架来管理模板类现在应该把这些类交给 Spring 框架来管理。 Spring 框架管理开源的连接池步骤一：Spring 配置内置的连接池1234567&lt;!--配置内置的连接池--&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring04\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"541638\"/&gt;&lt;/bean&gt; 步骤二：Spring 管理模板类1234&lt;!--配置 JDBC 的模板类--&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 步骤三：编写测试程序1234567891011121314/** * 测试 JDBC 的模板类，使用 IoC 的方式 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1_1 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test public void run1() &#123; jdbcTemplate.update(\"insert into t_account values (null,?,?)\", \"小关\", 10000); &#125;&#125; Spring 框架管理开源的连接池管理 DBCP 连接池 先引入 DBCP 的 2 个 jar 包 com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jarcom.springsource.org.apache.commons.pool-1.5.3.jar 编写配置文件： 1234567&lt;!--配置 DBCP 连接池--&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring04\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"541638\"/&gt;&lt;/bean&gt; 使用方法类似。 管理 C3P0 连接池 先引入 C3P0 的 jar 包 com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar 编写配置文件： 1234567&lt;!--配置 C3P0 连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring04\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"541638\"/&gt;&lt;/bean&gt; 使用方法类似。 Spring 框架的 JDBC 模板的简单操作增删改查的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.renkaigis.demo1;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;/** * 测试 JDBC 的模板类，使用 IoC 的方式 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1_1 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; // 插入操作 @Test public void run1() &#123; jdbcTemplate.update(\"insert into t_account values (null,?,?)\", \"小关\", 10000); &#125; // 修改操作 @Test public void run2() &#123; jdbcTemplate.update(\"update t_account set name = ? where id = ? \", \"小马\", 2); &#125; // 删除操作 @Test public void run3() &#123; jdbcTemplate.update(\"delete from t_account where id = ? \", 2); &#125; // 测试查询：通过主键查询一条记录 @Test public void run4() &#123; Account account = jdbcTemplate.queryForObject(\"select * from t_account where id = ?\", new BeanMapper(), 1); System.out.println(account); &#125; // 查询所有的数据 @Test public void run5() &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from t_account\", new BeanMapper()); System.out.println(list); &#125;&#125;/** * 自己手动封装数据（一行一行封装数据） */class BeanMapper implements RowMapper&lt;Account&gt; &#123; @Override public Account mapRow(ResultSet rs, int i) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getDouble(\"money\")); return account; &#125;&#125; 查询部分所需要的 JavaBean： 123456789101112131415161718192021222324252627282930313233343536package com.renkaigis.demo1;public class Account &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaWeb 之 Spring AOP 面向切面编程","slug":"JavaWeb-Spring03","date":"2018-08-07T04:36:23.000Z","updated":"2018-08-12T08:46:39.135Z","comments":true,"path":"JavaWeb-Spring03.html","link":"","permalink":"http://yoursite.com/JavaWeb-Spring03.html","excerpt":"Spring AOP 面向切面编程","text":"Spring AOP 面向切面编程 Spring 框架核心功能之 AOP 技术 AOP 的概述什么是 AOP 的技术？ 在软件业，AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程。 AOP 是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构。 AOP 最早由 AOP 联盟的组织提出的，制定了一套规范。Spring 将 AOP 思想引入到框架中，必须遵守 AOP 联盟的规范。 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP：面向切面编程。(思想————解决 OOP 遇到一些问题) AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存） 为什么要学习 AOP 可以在不修改源代码的前提下，对程序进行增强！ Spring 框架的 AOP 的底层实现代理方式Srping 框架的 AOP 技术底层也是采用的代理技术，代理的方式提供了两种 基于 JDK 的动态代理 必须是面向接口的，只有实现了具体接口的类才能生成代理对象 基于 CGLIB 动态代理 对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式 Spring 的传统 AOP 中根据类是否实现接口，来采用不同的代理方式 如果实现类接口，使用 JDK 动态代理完成 AOP 如果没有实现接口，采用 CGLIB 动态代理完成 AOP JDK 的动态代理（代码了解，理解原理）使用 Proxy 类来生成代理对象的一些代码如下： 注意：得有接口才能使用。 1234567891011121314151617181920212223/** * 使用 JDK 的方式生成代理对象 */public class MyProxyUtils &#123; public static UserDao getProcy(UserDao dao) &#123; // 使用 Proxy 生成代理对象 UserDao proxy = (UserDao) Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), new InvocationHandler() &#123; // 代理对象方法一执行，invoke 方法就会执行一次 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理增强方法 if(\"save\".equals(method.getName()))&#123; System.out.println(\"记录日志…\"); // 开启事务 &#125; // 提交事务 // 让 dao 类的 save 或者 update 方法正常的执行下去 return method.invoke(dao, args); &#125; &#125;); // 返回代理对象 return proxy; &#125;&#125; 测试： 123456789101112131415public class demo1 &#123; @Test public void run1() &#123; UserDao dao = new UserDaoImpl(); // 原始的调用方式 dao.save(); dao.update(); System.out.println(\"==================\"); // 使用工具类，获取到代理对象 UserDao procy = MyProxyUtils.getProcy(dao); // 调用代理对象的方法 procy.save(); procy.update(); &#125;&#125; CGLIB 的代理技术（了解） 引入 CBLIB 的开发包 如果想使用 CGLIB 的技术来生成代理对象，那么需要引入 CGLIB 的开发的 jar 包，在 Spring 框架核心包中已经引入了 CGLIB 的开发包了。所以直接引入 Spring 核心开发包即可！ 编写相关的代码1234567891011121314151617181920212223242526public class MyCglibUtils &#123; /** * 使用 CGLIB 方式生成代理对象 * * @return */ public static BookDaoImpl getProxy() &#123; Enhancer enhancer = new Enhancer(); // 设置父类 enhancer.setSuperclass(BookDaoImpl.class); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() &#123; // 代理对象的方法执行，回调函数就会执行 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; if (method.getName().equals(\"save\")) &#123; System.out.println(\"记录日志…\"); &#125; return methodProxy.invokeSuper(o, objects); &#125; &#125;); // 生成代理对象 BookDaoImpl proxy = (BookDaoImpl) enhancer.create(); return proxy; &#125;&#125; 测试： 1234567@Testpublic void run1() &#123; // 使用 CGLIB 生成代理对象 BookDaoImpl proxy = MyCglibUtils.getProxy(); proxy.save(); proxy.update();&#125; Spring 基于 AspectJ 的 AOP 的开发 AOP 的相关术语 Joinpoint(连接点)————所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点 Pointcut(切入点)————所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice(通知/增强)————所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Introduction(引介)————引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field Target(目标对象)————代理的目标对象 Weaving(织入)————是指把增强应用到目标对象来创建新的代理对象的过程 Proxy（代理）————一个类被 AOP 织入增强后，就产生一个结果代理类 Aspect(切面)————是切入点和通知的结合，需要自己来编写和配置的 具体点就是： 连接点：UserDaoImpl 中的所有方法都可以称为连接点。切入点：拦截哪些方法（对哪些方法进行增强）。通知/增强：具体做什么功能，比如记录日志。目标对象：UserDaoImpl 称为目标对象。织入：把增强添加到目标对象，生成代理对象的过程。代理：生成的代理对象。切面：切入点 + 通知，组合称为切面。通知需要自己来编写，切入点需要配置。 AspectJ 的 XML 方式完成 AOP 开发第一个案例步骤一：创建 JavaWEB 项目，引入具体的开发的 jar 包 先引入 Spring 框架开发的基本开发包（6个） 再引入 Spring 框架的 AOP 的开发包（4个） Spring 的传统 AOP 的开发的包 spring-aop-4.2.4.RELEASE.jarcom.springsource.org.aopalliance-1.0.0.jar aspectJ 的开发包 com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jarspring-aspects-4.2.4.RELEASE.jar 步骤二：创建 Spring 的配置文件，引入具体的 AOP 的 schema 约束123456&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 步骤三：创建包结构，编写具体的接口和实现类 com.renkaigis.demo4 CustomerDao – 接口CustomerDaoImpl – 实现类 步骤四：将目标类配置到 Spring 中12&lt;!--配置客户的 dao--&gt;&lt;bean id=\"customerDao\" class=\"com.renkaigis.demo4.CustomerDaoImpl\"/&gt; 步骤五：定义切面类1234567891011/** * 切面类：切入点 + 通知 */public class MyAspectXml &#123; /** * 通知（具体的增强） */ public void log()&#123; System.out.println(\"记录日志…\"); &#125;&#125; 步骤六：在配置文件中定义切面类12&lt;!--配置切面类--&gt;&lt;bean id=\"myAspectXml\" class=\"com.renkaigis.demo4.MyAspectXml\"/&gt; 步骤七：在配置文件中完成aop的配置123456789&lt;!--配置 AOP--&gt;&lt;aop:config&gt; &lt;!--引入切面类，配置切面类的切入点 + 通知（类型）--&gt; &lt;aop:aspect ref=\"myAspectXml\"&gt; &lt;!--配置前置通知，save 方法执行之前，增强的方法会执行--&gt; &lt;!--定义通知类型：切面类的方法和切入点的表达式 execution(public void com.renkaigis.demo4.CustomerDaoImpl.save()) --&gt; &lt;aop:before method=\"log\" pointcut=\"execution(public void com.renkaigis.demo4.CustomerDaoImpl.save())\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 完成测试123456789101112131415/** * 测试 AOP 功能 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo4 &#123; @Resource(name = \"customerDao\") private CustomerDao customerDao; @Test public void run1()&#123; customerDao.save(); customerDao.update(); &#125;&#125; 切入点的表达式在配置切入点的时候，需要定义表达式，重点的格式如下：execution(public * *(..))，具体展开如下： 切入点表达式的格式如下： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 修饰符可以省略不写，不是必须要出现的。 返回值类型是不能省略不写的，根据你的方法来编写返回值。可以使用 * 代替。 包名例如：com.renkaigis.demo4.BookDaoImpl 首先 com 是不能省略不写的，但是可以使用 * 代替中间的包名可以使用 * 号代替如果想省略中间的包名可以使用 *..* 类名也可以使用 * 号代替，也有类似的写法：*DaoImpl 方法也可以使用 * 号代替，save*() 参数如果是一个参数可以使用 * 号代替，如果想代表任意参数使用 .. 1234567891011121314151617&lt;aop:aspect ref=\"myAspectXml\"&gt; &lt;!--切入点的表达式：--&gt; &lt;!--1. execution() 固定的，不能不写--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(public void com.renkaigis.demo4.CustomerDaoImpl.save())\"/&gt; &lt;!--2. pulbic 可以省略不写--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(void com.renkaigis.demo4.CustomerDaoImpl.save())\"/&gt; &lt;!--3. void，返回值写 * 表示任意的返回值，返回值类型不能不写--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(* com.renkaigis.demo4.CustomerDaoImpl.save())\"/&gt; &lt;!--4. 包名可以使用 * 来代替，com.renkaigis.*，简写 *..*，不能不写--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(* *..*.CustomerDaoImpl.save())\"/&gt; &lt;!--5. 类名也可以使用 * 号代替，也有类似的写法：*DaoIml--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(* *..*.*DaoImpl.save())\"/&gt; &lt;!--6. 方法也可以使用 * 号代替，save*()--&gt; &lt;aop:before method=\"log\" pointcut=\"execution(* *..*.*DaoImpl.save*())\"/&gt; &lt;!--7. 方法的参数：可以使用 * 号代替，如果想代表任意参数使用 .. --&gt; &lt;aop:before method=\"log\" pointcut=\"execution(* *..*.*DaoImpl.save*(..))\"/&gt;&lt;/aop:aspect&gt; AOP的通知类型 前置通知 在目标类的方法执行之前执行。配置文件信息：&lt;aop:after method=&quot;before&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt;应用：可以对方法的参数来做校验 最终通知 在目标类的方法执行之后执行，如果程序出现了异常，最终通知也会执行。配置文件信息：&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt;应用：例如像释放资源 后置通知 方法正常执行后的通知。出现异常，不会执行。配置文件信息：&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt;应用：可以修改方法的返回值 异常抛出通知 在抛出异常后通知配置文件信息：&lt;aop:after-throwing method=&quot;afterThorwing&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt;应用：包装异常的信息 环绕通知 方法的执行前后执行。配置文件信息：&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt;要注意：目标的方法默认不执行，需要使用 ProceedingJoinPoint 对来让目标对象的方法执行。 12345678910/*** 环绕通知：方法执行之前和方法执行之后进行通知* 默认的情况下，目标对象的方法不能执行，需要手动让目标对象的方法执行。*/public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"环绕通知1…\"); // 手动让目标对象的方法执行 joinPoint.proceed(); System.out.println(\"环绕通知2…\");&#125; Spring框架的AOP技术之注解方式第一个案例步骤一：创建 JavaWEB 项目，引入具体的开发的 jar 包同上。 步骤二：创建 Spring 的配置文件，引入具体的 AOP 的 schema 约束同上。 这里我引入一个最全的约束： 1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;/beans&gt; 步骤三：创建包结构，编写具体的接口和实现类 com.renkaigis.demo5 CustomerDao————接口CustomerDaoImpl————实现类 步骤四：将目标类配置到 Spring 中12&lt;!--配置客户的 dao--&gt;&lt;bean id=\"customerDao\" class=\"com.renkaigis.demo4.CustomerDaoImpl\"/&gt; 步骤四：将目标类配置到 Spring 中12&lt;!--配置目标对象--&gt;&lt;bean id=\"customerDao\" class=\"com.renkaigis.demo5.CustomerDaoImpl\"/&gt; 步骤五：定义切面类添加切面和通知的注解 @Aspect————定义切面类的注解 通知类型（注解的参数是切入点的表达式） @Before————前置通知@AfterReturing————后置通知@Around————环绕通知@After————最终通知@AfterThrowing————异常抛出通知 具体的代码如下12345678910/** * 注解方式的切面类 */@Aspectpublic class MyAspectAnno &#123; @Before(value = \"execution(public * com.renkaigis.demo5.CustomerDaoImpl.save())\") public void log() &#123; System.out.println(\"记录日志…\"); &#125;&#125; 步骤六：在配置文件中定义切面类12&lt;!--配置切面类--&gt;&lt;bean id=\"myAspectAnno\" class=\"com.renkaigis.demo5.MyAspectAnno\"/&gt; 步骤七：在配置文件中开启自动代理12&lt;!--开启自动代理--&gt;&lt;aop:aspectj-autoproxy/&gt; 步骤八：完成测试123456789101112131415/** * AOP 注解方式 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo5 &#123; @Resource(name = \"customerDao\") private CustomerDao customerDao; @Test public void run1()&#123; customerDao.save(); customerDao.update(); &#125;&#125; 通知类型通知类型 @Before————前置通知 @AfterReturing————后置通知 @Around————环绕通知（目标对象方法默认不执行的，需要手动执行） @After————最终通知 @AfterThrowing————异常抛出通知 配置通用的切入点 使用 @Pointcut 定义通用的切入点 123456789101112131415@Aspectpublic class MyAspectAnno &#123; // 引入自定义切入点 @Before(value = \"MyAspectAnno.fn()\") public void log() &#123; System.out.println(\"记录日志…\"); &#125; /** * 自定义切入点，@Pointcut */ @Pointcut(value = \"execution(public * com.renkaigis.demo5.CustomerDaoImpl.save())\") public void fn() &#123; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaWeb 之 Spring IoC 控制反转及整合 JUnit 单元测试","slug":"JavaWeb-Spring02","date":"2018-08-05T02:27:56.000Z","updated":"2018-08-11T02:18:30.631Z","comments":true,"path":"JavaWeb-Spring02.html","link":"","permalink":"http://yoursite.com/JavaWeb-Spring02.html","excerpt":"Spring IoC 控制反转 &amp; 整合 JUnit 单元测试。","text":"Spring IoC 控制反转 &amp; 整合 JUnit 单元测试。 Spring 框架 IoC 功能之配置文件方式 Spring 框架中 &lt;bean&gt; 标签的配置id 属性和 name 属性的区别 id————Bean 起个名字，在约束中采用 ID 的约束，唯一 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id：不能出现特殊字符 name————Bean 起个名字，没有采用 ID 的约束（了解） 取值要求：name 允许出现特殊字符，如果 &lt;bean&gt; 没有 id 的话，name 可以当做 id 使用Spring 框架在整合 Struts1 的框架的时候，Struts1 的框架的访问路径是以 / 开头的，例如：/bookAction class 属性Bean 对象的全路径：com.renkaigis.demo1.UserServiceImpl scope 属性scope 属性代表 Bean 的作用范围 singleton————单例（默认值）prototype————多例，在 Spring 框架整合 Struts2 框架的时候，Action 类也需要交给 Spring 做管理，配置把 Action 类配置成多例！！request————应用在 Web 项目中，每次 HTTP 请求都会创建一个新的 Beansession————应用在 Web 项目中，同一个 HTTP Session 共享一个 Beanglobalsession————应用在 Web 项目中，多服务器间的 session Bean 对象的创建和销毁的两个属性配置（了解）Spring 初始化 bean 或销毁 bean 时，有时需要作一些处理工作，因此 spring 可以在创建和销毁 bean 的时候调用 bean 的两个生命周期方法 init-method————当 bean 被载入到容器的时候调用 init-method 属性指定的方法 destroy-method————当bean从容器中删除的时候调用 destroy-method 属性指定的方法 想查看 destroy-method 的效果，有如下条件 ① scope = &quot;singleton&quot;有效② web 容器中会自动调用，但是 main 函数或测试用例需要手动调用（需要使用 ClassPathXmlApplicationContext 的 close() 方法） 依赖注入（DI）IoC 和 DI 的概念 IoC————Inverse of Control，控制反转，将对象的创建权反转给 Spring！！ DI————Dependency Injection，依赖注入，在 Spring 框架负责创建 Bean 对象时，动态的将依赖对象注入到 Bean 组件中！！ DI（依赖注入）： 例如：如果 UserServiceImpl 的实现类中有一个属性，那么使用 Spring 框架的 IoC 功能时，可以通过依赖注入把该属性的值传入进来！！ 具体的配置如下： 123&lt;bean id=\"userService\" class=\"com.renkaigis.demo1.UserServiceImpl\"&gt; &lt;property name=\"name\" value=\"小风\"/&gt;&lt;/bean&gt; Spring 框架的属性注入对于类成员变量，常用的注入方式有两种 构造函数注入 属性 setter 方法注入 构造方法的注入方式 编写 Java 类，提供构造方法 1234567891011121314public class Car1 &#123; private String cname; private Double price; public Car1(String cname, Double price) &#123; this.cname = cname; this.price = price; &#125; @Override public String toString() &#123; return \"Car1&#123;\" + \"cname='\" + cname + '\\'' + \", price=\" + price + '&#125;'; &#125;&#125; 编写配置文件 12345&lt;!--演示构造方法注入的方式--&gt;&lt;bean id=\"car1\" class=\"com.renkaigis.demo2.Car1\"&gt; &lt;constructor-arg name=\"cname\" value=\"奇瑞QQ\"/&gt; &lt;constructor-arg name=\"price\" value=\"25000\"/&gt;&lt;/bean&gt; 测试： 123456@Testpublic void run1() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Car1 c1 = (Car1) ac.getBean(\"car1\"); System.out.println(c1);&#125; setter 方法的注入方式 编写 Java 的类，提供属性和对应的 set 方法即可 编写配置文件 如果 Java 类的属性是另一个 Java 的类，那么需要怎么来注入值呢？ &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt; 例如： 1234&lt;bean id=\"person\" class=\"com.renkaigis.demo2.Person\"&gt; &lt;property name=\"pname\" value=\"美美\"/&gt; &lt;property name=\"car2\" ref=\"car2\"/&gt;&lt;/bean&gt; Spring 2.5 版本：p 名称空间的注入（了解）先引入 p 名称空间 在 schema 的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 使用 p 名称空间的语法 p:属性名 = “” p:属性名-ref = “” 测试12&lt;!--采用 p 名称空间注入的方式--&gt;&lt;bean id=\"car1\" class=\"com.renkaigis.demo2.Car1\" p:cname=\"保时捷\" p:price=\"1000000\"/&gt; Spring 3.0 版本：SpEL注入方式（了解）SpEL：Spring Expression Language 是 Spring 的表达式语言，有一些自己的语法。 语法 1#&#123;SpEL&#125; 12345&lt;!-- SpEL的方式 --&gt;&lt;bean id=\"person\" class=\"com.renkaigis.demo4.Person\"&gt; &lt;property name=\"pname\" value=\"#&#123;'小风'&#125;\"/&gt; &lt;property name=\"car2\" value=\"#&#123;car2&#125;\"/&gt;&lt;/bean&gt; 数组，集合（List,Set,Map），Properties 等的注入数组和 List 集合如果是数组或者List集合，注入配置文件的方式是一样的 12345678910111213141516171819202122/** * 演示集合注入的方式 */public class User &#123; // 数组 private String[] arrs; // 集合 private List&lt;String&gt; list; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setArrs(String[] arrs) &#123; this.arrs = arrs; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"arrs=\" + Arrays.toString(arrs) + \", list=\" + list + '&#125;'; &#125;&#125; 1234567891011121314151617&lt;bean id=\"user\" class=\"com.renkaigis.demo3.User\"&gt; &lt;!--注入数组--&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;value&gt;嘿嘿&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--注入集合--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;天哪&lt;/value&gt; &lt;value&gt;god&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 12345678910111213141516171819/** * 测试注入数组 */@Testpublic void run1() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) ac.getBean(\"user\"); System.out.println(user);&#125;/** * 测试注入集合 */@Testpublic void run2() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) ac.getBean(\"user\"); System.out.println(user);&#125; Set 集合如果是 Set 集合，注入的配置文件方式如下： 1234567&lt;!--注入 set 集合--&gt;&lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; Map 集合如果是 Map 集合，注入的配置方式如下： 1234567&lt;!--注入 map--&gt;&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aaa\" value=\"小瓜\"/&gt; &lt;entry key=\"bbb\" value=\"小宗\"/&gt; &lt;/map&gt;&lt;/property&gt; properties 属性文件如果是 properties 属性文件的方式，注入的配置如下： 1234567&lt;!--注入属性文件--&gt;&lt;property name=\"pro\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;1234&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; Spring 配置文件分开管理（了解）例如：在 src 的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！ 主配置文件中引入其他的配置文件: 12&lt;!-- 推荐使用 --&gt;&lt;import resource=\"applicationContext2.xml\"/&gt; 工厂创建的时候直接加载多个配置文件: 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\",\"applicationContext2.xml\"); Spring 框架 IoC 功能之注解方式 Spring框架 IoC 之注解方式快速入门步骤一：导入注解开发所有需要的 jar 包 引入IoC容器必须的6个jar包 spring-beans-4.2.4.RELEASE.jarspring-context-4.2.4.RELEASE.jarspring-core-4.2.4.RELEASE.jarspring-expression-4.2.4.RELEASE.jarcom.springsource.org.apache.commons.logging-1.1.1.jarcom.springsource.org.apache.log4j-1.2.15.jar 多引入一个：Spring框架的AOP的jar包，spring-aop的jar包 步骤二：创建对应的包结构，编写 Java 的类 UserService————接口 UserServiceImpl————具体的实现类 步骤三：引入约束在 src 的目录下，创建 applicationContext.xml 的配置文件，然后引入约束。注意：因为现在想使用注解的方式，那么引入的约束发生了变化。 需要引入context的约束，具体的约束如下： 123456&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 步骤四：在 applicationContext.xml 配置文件中开启组件扫描 Spring的注解开发：组件扫描 12&lt;!--开启注解的扫描--&gt;&lt;context:component-scan base-package=\"com.renkaigis.demo1\"/&gt; 注意：可以采用如下配置： 12&lt;!-- 这样是扫描com.renkaigis包下所有的内容 --&gt;&lt;context:component-scan base-package=\"com.renkaigis\"/&gt; 步骤五：在 UserServiceImpl 的实现类上添加注解 @Component(value=”userService”) – 相当于在XML的配置方式中 123456789101112/** * @Component(value = \"userService\") * 等价于 * &lt;bean id=\"userService\" class=\"com.renkaigis.demo1.UserServiceImpl\"/&gt; */@Component(value = \"userService\")public class UserServiceImpl implements UserService &#123; @Override public void sayHello() &#123; System.out.println(\"Hello Spring!\"); &#125;&#125; 步骤六：编写测试代码123456@Testpublic void run1() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService us = (UserService) ac.getBean(\"userService\"); us.sayHello();&#125; Spring 框架中 Bean 管理的常用注解类注解 @Component：组件。（作用在类上） Spring 中提供 @Component 的三个衍生注解：（功能目前来讲是一致的） @Controller————作用在WEB层@Service————作用在业务层@Repository————作用在持久层 说明：这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强 属性注解属性注入的注解（说明：使用注解注入的方式,可以不用提供 set 方法） 如果是注入的普通类型，可以使用 value 注解 @Value————用于注入普通类型 12345678910@Component(value = \"userService\")public class UserServiceImpl implements UserService &#123; @Value(value = \"小美\") private String name; @Override public void sayHello() &#123; System.out.println(\"Hello Spring!\" + name); &#125;&#125; 如果注入的是对象类型，使用如下注解 @Autowired————默认按类型进行自动装配，寻找实现类。缺点：实现类多的话就出错了 如果想按名称注入 @Qualifier————强制使用名称注入 12345678910111213@Component(value = \"userService\")public class UserServiceImpl implements UserService &#123; // 按类型自动装配 @Autowired @Qualifier(value = \"ud\") // 按名称注入 private UserDao userDao; @Override public void sayHello() &#123; System.out.println(\"Hello Spring!\"); userDao.save(); &#125;&#125; @Resource————相当于 @Autowired 和 @Qualifier 一起使用 强调：@Resource 是 Java 提供的注解属性使用 name属性 12@Resource(name = \"ud\")private UserDao userDao; Bean 的作用范围和生命周期的注解Bean 的作用范围注解 注解为 @Scope(value = &quot;prototype&quot;)，作用在类上。值如下： singleton————单例，默认值prototype————多例 Bean 的生命周期的配置（了解） 注解如下： @PostConstruct————相当于 init-method@PreDestroy————相当于 destroy-method Spring 框架整合 JUnit 单元测试 为了简化了 JUnit 的测试，使用 Spring 框架也可以整合测试。 具体步骤要求：必须先有 JUnit 的环境（即已经导入了 JUnit4 的开发环境）！！ 步骤一：在程序中引入：spring-test.jar 步骤二：在具体的测试类上添加注解 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(“classpath:applicationContext.xml”) 以后不用再自己 new 工厂了，配置文件会自动加载： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class demo2 &#123; @Resource(name = \"userService\") private UserService userService; @Test public void run1() &#123; userService.sayHello(); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaWeb 之 Spring 快速入门","slug":"JavaWeb-Spring01","date":"2018-08-03T07:46:23.000Z","updated":"2018-08-10T06:40:08.210Z","comments":true,"path":"JavaWeb-Spring01.html","link":"","permalink":"http://yoursite.com/JavaWeb-Spring01.html","excerpt":"Spring 快速入门。","text":"Spring 快速入门。 Spring 框架的概述和入门 什么是 Spring 框架Spring 框架的概述 Spring 是一个开放源代码的设计层面框架，他解决的是 业务逻辑层 和其他各层的松耦合问题。 Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，由 Rod Johnson 在其著作 《Expert One-On-One J2EE Development and Design》 中阐述的部分理念和原型衍生而来。 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 Spring 使用基本的 JavaBean 来完成以前只可能由 EJB 完成的事情。然而，Spring 的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。 Spring 的核心是 控制反转（IoC） 和 面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EEfull-stack（一站式） 轻量级开源框架。 Java EE 开发分成三层结构 WEB层 ———— Spring MVC业务层 ———— Bean管理：（IoC）持久层 ———— Spring 的 JDBC 模板。ORM 模板用于整合其他的持久层框架。 Spring 框架的特点 方便解耦，简化开发 Spring 就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理。 AOP 编程的支持 Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程。 方便程序的测试 Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序。 方便集成各种优秀框架 Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持。 降低 JavaEE API 的使用难度 Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。 Spring 框架的 IoC 核心功能快速入门 IoC 的功能 IoC（Inverse of Control），控制反转，将对象的创建权反转给 Spring ！！ 使用 IoC 可以解决的程序 耦合性高 的问题！！ IoC 快速入门步骤一：下载 Spring 框架的开发包 官网：http://spring.io/ 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring 解压：（Spring 目录结构） docs ———— API 和开发规范libs ———— jar 包和源码schema ———— 约束 步骤二：创建 JavaWEB 项目，引入 Spring 的开发包引入Spring框架IoC核心功能需要的具体的jar包 Spring 框架的 IoC 的功能，那么根据 Spring 框架的体系结构图能看到，只需要引入如下的 jar 包 BeansCoreContextExpression Language Spring 框架也需要引入日志相关的 jar 包 spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1 com.springsource.org.apache.commons.logging-1.1.1.jar 引入 log4j 的jar包 spring-framework-3.0.2.RELEASE-dependencies\\org.apache.log4j\\com.springsource.org.apache.log4j\\1.2.15 com.springsource.org.apache.log4j-1.2.15.jar 注意：记得在 src 目录下导入 log4j 的属性文件 log4j.properties 步骤三：编写 Java 类创建对应的包结构，编写 Java 的类。 注意：以后使用 Spring 框架做开发，都需要来编写接口与实现类！！ com.renkaigis.demo1 UserService ———— 接口UserServiceImpl ———— 具体的实现类 步骤四：编写配置文件 applicationContext.xml想把 UserServiceImpl 实现类的创建交给 Spring 框架来管理，需要创建 Spring 框架的配置文件，完成配置。 在 src 目录下创建 applicationContext.xml 的配置文件，名称是可以任意的，但是一般都会使用默认名称！ 引入 spring 的约束，需要先找到具体的约束头信息！ spring-framework-3.2.0.RELEASE\\docs\\spring-framework-reference\\html\\xsd-config.html 具体的约束如下： 12345&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 完成 UserService 的配置 12&lt;!-- Spring的快速入门 --&gt;&lt;bean id=\"userService\" class=\"com.renkaigis.demo1.UserServiceImpl\"/&gt; 步骤五：编写测试程序采用 Spring 框架的 工厂方式 来获取到 UserService 接口的具体实现类！！ 1234567891011121314151617181920212223242526272829303132package com.renkaigis.demo1;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试 IoC 的程序 */public class demo1 &#123; /** * 原来的方式 */ @Test public void run1() &#123; UserService usi = new UserServiceImpl(); usi.sayHello(); &#125; /** * 使用 Spring 框架的方式 */ @Test public void run2() &#123; // 创建工厂，加载核心配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 从工厂中获取对象 UserService us = (UserService) ac.getBean(\"userService\"); // 调用对象的方法执行 us.sayHello(); &#125;&#125; Spring 框架中的工厂（了解）ApplicationContext 接口 使用 ApplicationContext 工厂的接口，使用该接口可以获取到具体的 Bean 对象。 启动服务器的时候即创建好了对象。 该接口下有两个具体的实现类： ClassPathXmlApplicationContext————加载类路径下的 Spring 配置文件FileSystemXmlApplicationContext————加载本地磁盘下的 Spring 配置文件 BeanFactory工厂（过时）（是Spring框架早期的创建Bean对象的工厂接口） 启动服务器的时候不会创建对象，只有在第一次调用的时候才会创建。 使用 BeanFactory 接口也可以获取到 Bean 对象 12345public void run()&#123; BeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\")); UserService us = (UserService) factory.getBean(\"userService\"); us.sayHello();&#125; BeanFactory 和 ApplicationContext 的区别 BeanFactory————BeanFactory 采取延迟加载，第一次 1getBean 时才会初始化 Bean ApplicationContext————在加载 applicationContext.xml 时候就会创建具体的 Bean 对象的实例，还提供了一些其他的功能： 事件传递Bean 自动装配各种不同应用层的 Context 实现","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"JavaWeb 之 OGNL 表达式、Struts2 值栈与OGNL 特殊符号","slug":"JavaWeb-Struts203","date":"2018-08-01T01:32:15.000Z","updated":"2018-08-10T06:46:27.972Z","comments":true,"path":"JavaWeb-Struts203.html","link":"","permalink":"http://yoursite.com/JavaWeb-Struts203.html","excerpt":"OGNL 表达式 &amp; Struts2 值栈 &amp; OGNL 特殊符号","text":"OGNL 表达式 &amp; Struts2 值栈 &amp; OGNL 特殊符号 OGNL表达式 OGNL表达式概述（了解） OGNL 是 Object Graphic Navigation Language（对象图导航语言）的缩写 所谓对象图，即以任意一个对象为根，通过 OGNL 可以访问与这个对象关联的其它对象 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 Struts2 框架使用 OGNL 作为默认的表达式语言 OGNL 是一种比 EL 强大很多倍的语言xwork 提供 OGNL 表达式ognl-3.0.5.jar OGNL 提供五大类功能 支持对象方法调用支持类静态的方法调用和值访问访问 OGNL 上下文（OGNLcontext）和 ActionContext支持赋值操作和表达式串联操作集合对象 测试的代码 1234567891011121314151617181920212223242526272829// 访问对象的方法@Testpublic void run1() throws OgnlException&#123; OgnlContext context = new OgnlContext(); // 获取对象的方法 Object obj = Ognl.getValue(\"'helloworld'.length()\", context, context.getRoot()); System.out.println(obj);&#125;// 获取OGNL上下文件的对象@Testpublic void run3() throws OgnlException&#123; OgnlContext context = new OgnlContext(); context.put(\"name\", \"美美\"); // 获取对象的方法 Object obj = Ognl.getValue(\"#name\", context, context.getRoot()); System.out.println(obj);&#125;// 从root栈获取值@Testpublic void demo3() throws OgnlException&#123; OgnlContext context = new OgnlContext(); Customer c = new Customer(); c.setCust_name(\"haha\"); context.setRoot(c); String name = (String) Ognl.getValue(\"cust_name\", context, context.getRoot()); System.out.println(name);&#125; 自己测试的代码： 1234567891011121314151617181920212223242526272829package com.renkaigis;import ognl.Ognl;import ognl.OgnlContext;import ognl.OgnlException;import org.junit.Test;/** * 演示 OGNL 表达式 */public class demo1 &#123; /** * 测试 */ @Test public void run1() throws OgnlException &#123; // 上下文对象 OgnlContext context = new OgnlContext(); // 获取到根对象 Object root = context.getRoot(); // 存储数据 context.put(\"name\", \"美美\"); // 获取值，注意表达式写法 Object value = Ognl.getValue(\"#name\", context, root); // 调用方法 //Object value = Ognl.getValue(\"'haha'.length()\", context, root); System.out.println(value); &#125;&#125; 在 Struts2 框架中使用 OGNL 表达式1）. Struts2 引入了 OGNL 表达式，主要是在 JSP 页面中获取值栈中的值 2）. 具体在 Struts2 中怎么使用呢？如下步骤 需要先在 JSP 页面中引入 Struts2 的标签库 1&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt; 使用 Struts2 提供的标签中的标签 1&lt;s:property value=\"OGNL表达式\"/&gt; 3）. 在 JSP 页面使用 OGNL 表达式 访问对象方法 1&lt;s:property value=\"'hello'.length()\"/&gt; Struts2 框架的值栈 值栈的概述 值栈就相当于 Struts2 框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。 ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack —- 值栈对象 （OGNL 是从值栈中获取数据的 ） Action 是多例的，有一个请求，创建 Action 实例，创建一个 ActionContext 对象，代表的是 Action 的上下文对象，还会创建一个 ValueStack 对象。 每个 Action 实例都有一个 ValueStack 对象 （一个请求对应一个 ValueStack 对象 ） 在其中保存当前 Action 对象和其他相关对象 Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中，request 中 （值栈对象是 request 一个属性） 12// 不常用ValueStack vs = (ValueStack)request.getAttribute(\"struts.valueStack\"); 值栈的内部结构值栈由两部分组成 值栈由以下两部分组成： root ———— Struts 把动作和相关对象压入 ObjectStack 中–Listcontext ———— Struts 把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中 Struts 会默认把下面这些映射压入 ContextMap（context）中 注意：request 代表的是 Map 集合的 key 值，value 的值其实也是一个 Map 集合。 parameters：该 Map 中包含当前请求的请求参数 ?name=xxx&amp;password=123request：该 Map 中包含当前 request 对象中的所有属性session：该 Map 中包含当前 session 对象中的所有属性application：该 Map 中包含当前 application 对象中的所有属性attr：该 Map 按如下顺序来检索某个属性: request, session, application ValueStack 中存在 root 属性 (CompoundRoot) 、 context 属性 （OgnlContext ） CompoundRoot 就是 ArrayListOgnlContext 就是 Map context 对应 Map 引入 root 对象 context 中还存在 request、 session、application、 attr、 parameters 对象引用 操作值栈默认指操作 root 元素 OGNL 获取值如果从 root 栈中获取值，OGNL 表达式默认情况下不能写 # 号： 1&lt;s:property value=\"表达式\"/&gt; 如果从 context 栈中获取值，OGNL 表达式默认需要加 # 号（访问 request、 session、application、 attr、 parameters 对象数据必须写）： 1&lt;s:property value=\"#表达式\"/&gt; 值栈的创建和 ActionContext 对象的关系 值栈对象是 请求时创建 的 ActionContext 是绑定到当前的线程上，那么在每个拦截器或者 Action 中获取到的 ActionContext 是同一个。 ActionContext 中存在一个 Map 集合，该 Map 集合和 ValueStack 的 context 是同一个地址。 ActionContext 中可以获取到 ValueStack 的引用，以后再开发，使用 ActionContext 来获取到值栈对象 获取值栈对象 获得值栈对象，有三种方法： 1ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(\"struts.valueStack\"); 1ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); ★重要： 12// 获取值栈对象，首先要获取 ActionContext 对象ValueStack vs3 = ActionContext.getContext().getValueStack(); 向值栈中保存数据向值栈保存数据 （主要针对 root 栈） push 方法12// 向栈顶压入对象valueStack.push(Object obj); push 方法的底层调用 root 对象的 push 方法（把元素添加到 0 位置） set 方法12// 向栈顶压入 map 集合，把 key 和 obj 存入到 map 集合中valueStack.set(String key, Object obj); 源码获取 map 集合（map 有可能是已经存在的，有可能是新创建的），把 map 集合压入到栈顶，再把数据存入到 map 集合中。 在 jsp 中，通过 &lt;s:debug/&gt; 查看值栈的内容 从值栈中获取值一些小细节 访问 root 中的数据不需要 #访问 context 中的对象数据，要加 #如果向 root 中存入对象的话，优先使用 push 方法。如果向 root 中存入集合的话，优先要使用 set 方法。 在 OgnlContext 中获取数据12345request:&lt;s:property value=\"#request.username\"/&gt;session:&lt;s:property value=\"#session.username\"/&gt;application:&lt;s:property value=\"#application.username\"/&gt;attr:&lt;s:property value=\"#attr.username\"/&gt;parameters:&lt;s:property value=\"#parameters.cid\"/&gt; 代码演示前提 struts.xml： 12345678&lt;struts&gt; &lt;package name=\"demo2\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--压栈和取值--&gt; &lt;action name=\"save\" class=\"com.renkaigis.demo2.ValueStack1Action\" method=\"save\"&gt; &lt;result name=\"success\"&gt;/demo2/vs.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 注意：jsp 中首先要引入标签库 &lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;，在 jsp 中使用 &lt;s:debug&gt;&lt;/s:debug&gt; 可以查看值栈的内容。 以下代码演示 压栈和取值： push 字符串Action 代码： 12345// 获取值栈ValueStack vs = ActionContext.getContext().getValueStack();// 压栈vs.push(\"小灰\");return SUCCESS; jsp 代码： 12&lt;%--获取栈顶的值--%&gt;&lt;s:property value=\"[0].top\"/&gt; set 字符串Action 代码： 1vs.set(\"msg\", \"小瓜\"); jsp 代码： 12&lt;%--栈顶是 map 集合，通过 key 来获取值--%&gt;&lt;s:property value=\"[0].top.msg\"/&gt; 获取对象（push）首先需要创建一个 JavaBean： 123456789101112131415161718192021222324252627282930package com.renkaigis.demo2;public class User &#123; private String username; private String password; public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Action 代码： 1234// 创建 User 对象User user = new User(\"小雷\", \"123\");// 压栈vs.push(user); jsp 代码： 1234&lt;%--栈顶放 user 对象--%&gt;&lt;s:property value=\"[0].top.username\"/&gt;&lt;%--[0].top 是可以省略的--%&gt;&lt;s:property value=\"username\"/&gt; 获取对象（set）Action 代码： 1vs.set(\"user\", user); jsp 代码： 123&lt;s:property value=\"[0].top.user.username\"/&gt;&lt;%--省略关键字--%&gt;&lt;s:property value=\"user.username\"/&gt; List 集合（push）Action 代码： 123456ArrayList&lt;User&gt; ulist = new ArrayList&lt;&gt;();ulist.add(new User(\"张三\", \"123\"));ulist.add(new User(\"李四\", \"456\"));ulist.add(new User(\"王五\", \"789\"));// 把 ulist 压栈vs.push(ulist); jsp 代码： 12&lt;s:property value=\"[0].top[0].username\"/&gt;&lt;s:property value=\"[0].top[1].username\"/&gt; List 集合（set）Action 代码： 1vs.set(\"ulist\", ulist); jsp 代码： 1234567891011121314151617&lt;s:property value=\"ulist[0].username\"/&gt;&lt;%--迭代的标签 属性： vaule 表示要迭代的集合，需要从值栈中获取 var 迭代过程中，遍历的对象（可写可不写） * var 编写上，把迭代产生的对象默认压入到 context 栈中，取值要加 # * var 不编写，默认把迭代产生的对象压入到 root 栈中--%&gt;&lt;s:iterator value=\"ulist\" var=\"user\"&gt; &lt;s:property value=\"#user.username\"/&gt;&lt;/s:iterator&gt;&lt;%--不编写 var--%&gt;&lt;s:iterator value=\"ulist\"&gt; &lt;s:property value=\"username\"/&gt;&lt;/s:iterator&gt; 从 context 栈中获取值底层已经封装了 request、session 等对象，操作的就是 map 集合 requestAction 代码： 12HttpServletRequest request = ServletActionContext.getRequest();request.setAttribute(\"msg\", \"小鬼\"); jsp 代码： 1&lt;s:property value=\"#request.msg\"/&gt; sessionAction 代码： 1request.getSession().setAttribute(\"msg\", \"小卡\"); jsp 代码： 1&lt;s:property value=\"#session.msg\"/&gt; parameters路径传值： 1http://localhost:9090/save.action?id=10 jsp 代码： 1&lt;s:property value=\"#parameters.id\"/&gt; attrattr 从最小域开始找 jsp 代码： 1&lt;s:property value=\"#attr.msg\"/&gt; EL 表达式也能获取到值栈中的数据EL 获取值栈的值获取上面的 ulist： 首先导包：jstl.jar、standard.jar 引标签库：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 1234&lt;%--在 jsp 页面上使用 EL 和 JSTL 标签库来取值--%&gt;&lt;c:forEach items=&quot;$&#123;ulist&#125;&quot; var=&quot;user&quot;&gt; $&#123;user.username&#125; -- $&#123;user.password&#125;&lt;/c:forEach&gt; 为什么 EL 也能访问值栈中的数据？因为 Struts2 底层使用了装饰者模式，对 getAttribute() 方法进行了增强。 StrutsPreparedAndExecuteFilter 的 doFilter 代码中 request = prepare.wrapRequest(request); 对 Request对象进行了包装StrutsRequestWrapper 增强了 request 的 getAttribute() 方法 1234Object attribute = super.getAttribute(s);if (attribute == null) &#123; attribute = stack.findValue(s);&#125; 访问 request 范围的数据时，如果数据找不到，会去值栈中找request 对象具备访问值栈数据的能力（查找 root 的数据） OGNL 表达式的特殊符号 # 符号的用法 ★获得 contextMap 中的数据123456&lt;s:property value=\"#request.name\"/&gt;&lt;s:property value=\"#session.name\"/&gt;&lt;s:property value=\"#application.name\"/&gt;&lt;s:property value=\"#attr.name\"/&gt;&lt;s:property value=\"#parameters.id\"/&gt;&lt;s:property value=\"#parameters.name\"/&gt; # 可以构建一个 map 集合以构建表单为例： 123456789&lt;h3&gt;编写表单&lt;/h3&gt;&lt;form action=\"\" method=\"post\"&gt; 性别：&lt;input type=\"radio\" name=\"sex\"/&gt;男&lt;input type=\"radio\" name=\"sex\"/&gt;女&lt;/form&gt;&lt;h3&gt;使用 Struts2 UI 标签方式&lt;/h3&gt;&lt;s:form action=\"\" method=\"post\"&gt; 性别：&lt;s:radio name=\"sex\" list=\"&#123;'男','女'&#125;\"/&gt;&lt;/s:form&gt; 使用 # 构建 map 集合： 123456789&lt;h3&gt;编写表单&lt;/h3&gt;&lt;form action=\"\" method=\"post\"&gt; 性别：&lt;input type=\"radio\" name=\"sex\" value=\"1\"/&gt;男&lt;input type=\"radio\" name=\"sex\" value=\"2\"/&gt;女&lt;/form&gt;&lt;h3&gt;使用 Struts2 UI 标签方式&lt;/h3&gt;&lt;s:form action=\"\" method=\"post\"&gt; 性别：&lt;s:radio name=\"sex\" list=\"#&#123;'1':'男','2:':'女'&#125;\"/&gt;&lt;/s:form&gt; % 符号的用法强制字符串解析成 OGNL 表达式 例如：在 request 域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到 value 上。 1&lt;s:textfield value=\"%&#123;#request.msg&#125;\"/&gt; { } 中的值用 ‘’ 引起来，此时不再是 ognl 表达式，而是普通的字符串1&lt;s:property value=\"%&#123;'#request.msg'&#125;\"/&gt; $ 符号的用法 在配置文件中可以使用 OGNL 表达式，例如：文件下载的配置文件。 123456&lt;action name=\"download1\" class=\"com.renkaigis.demo2.DownloadAction\"&gt; &lt;result name=\"success\" type=\"stream\"&gt; &lt;param name=\"contentType\"&gt;$&#123;contentType&#125;&lt;/param&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=$&#123;downFilename&#125;&lt;/param&gt; &lt;/result&gt;&lt;/action&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"}]},{"title":"JavaWeb 之 Struts2 中的 Servlet API、封装数据、拦截器","slug":"JavaWeb-Struts202","date":"2018-07-22T09:56:43.000Z","updated":"2018-08-10T06:46:25.453Z","comments":true,"path":"JavaWeb-Struts202.html","link":"","permalink":"http://yoursite.com/JavaWeb-Struts202.html","excerpt":"Servlet API、封装数据、拦截器。","text":"Servlet API、封装数据、拦截器。 Struts2 框架中 Servlet API 的使用 Servlet 的 API在 Action 类中也可以获取到 Servlet 一些常用的 API 案例需求：提供 JSP 的表单页面的数据，在 Action 中使用 Servlet 的 API 接收到，然后保存到三个域对象中，最后再显示到 JSP 的页面上。 提供 JSP 注册的页面： 123456&lt;h3&gt;注册页面&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/xxx.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 完全解耦合的方式为了避免与 Servlet API 耦合在一起，方便 Action 类做单元测试，Struts2 对 HttpServletRequest、HttpSession 和 ServletContext 进行了封装，构造了三个 Map 对象来替代这三种对象，在 Action 中，直接使用 HttpServletRequest、HttpSession、ServletContext 对应的 Map 对象来保存和读取数据。 要获得这三个Map对象，可以使用 com.opensymphony.xwork2.ActionContext类 ActionContext ： 请求上下文 常用的方法如下: 12345static ActionContext getContext() -- 获取 ActionContext 对象实例java.util.Map&lt;java.lang.String,java.lang.Object&gt; getParameters() -- 获取请求参数，相当于 request.getParameterMap();java.util.Map&lt;java.lang.String,java.lang.Object&gt; getSession() -- 获取的代表 session 域的 Map 集合，就相当于操作 session 域。java.util.Map&lt;java.lang.String,java.lang.Object&gt; getApplication() -- 获取代表 application 域的 Map 集合void put(java.lang.String key, java.lang.Object value) -- 注意：向 request 域中存入值。 案例演示Demo1Action.java 1234567891011121314151617181920212223242526/** * 完全解耦合的方式，使用 Servlet 的 API */public class Demo1Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 完全解耦合的方式 ActionContext context = ActionContext.getContext(); // 获取到请求的参数，封装所有请求的参数 Map&lt;String, Object&gt; map = context.getParameters(); // 遍历获取数据 Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; // 通过 Key，来获取到值 String[] vals = (String[]) map.get(key); System.out.println(key + \":\" + Arrays.toString(vals)); &#125; // 向 request 域中存入值 context.put(\"msg\",\"小天\"); // 获取其他 map 集合，并存入数据 context.getSession().put(\"msg\",\"小明\"); context.getApplication().put(\"msg\",\"小红\"); return SUCCESS; &#125;&#125; JSP 输入页面： 123456&lt;h3&gt;完全解耦合方式&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/demo1Action.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; JSP 跳转页面： 1234&lt;h3&gt;使用 EL 表达式获取值&lt;/h3&gt;$&#123;requestScope.msg&#125;$&#123;sessionScope.msg&#125;$&#123;applicationScope.msg&#125; struts.xml 配置文件： 123456&lt;package name=\"demo1\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--完全解耦合的方式--&gt; &lt;action name=\"demo1Action\" class=\"com.renkaigis.demo1.Demo1Action\"&gt; &lt;result name=\"success\"&gt;/demo1/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 案例结果：输入信息： 跳转并取值： 控制台输出结果： 12password:[12345]username:[renkai] 使用原生 Servlet 的 API 的方式直接访问 Servlet API 将使 Action 类与 Servlet API 耦合在一起，Servlet API 对象均由 Servlet 容器来构造，与这些对象绑定在一起，测试过程中就必须有 Servlet 容器，这样不便于 Action 类的测试，但有时候，确实需要访问这些对象，Struts2 同样提供了直接访问 ServletAPI 对象的方式。 要直接获取 Servlet API 对象可以使用 org.apache.struts2.ServletActionContext 类，该类是 ActionContext 类的子类。 具体的方法如下 12345HttpServletRequest request=ServletActionContext.getRequest();HttpSession session=request.getSession();session.setAttribute(\"xxx\",xxx);HttpServletResponse response=ServletActionContext.getResponse();HttpServletContext application=ServletActionContext.getApplication(); 案例演示Demo2Action.java 123456789101112131415161718/** * 原生 Servlet API */public class Demo2Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 获取到 request 对象 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(\"msg\", \"天天\"); request.getSession().setAttribute(\"msg\", \"美美\"); ServletActionContext.getServletContext().setAttribute(\"msg\", \"园园\"); // 获取 response 对象，可以使用输出流，输出内容 HttpServletResponse response = ServletActionContext.getResponse(); return SUCCESS; &#125;&#125; JSP 输入页面： 123456&lt;h3&gt;ServletCActionContext 类&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/demo2Action.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; JSP 跳转页面： 1234&lt;h3&gt;使用 EL 表达式获取值&lt;/h3&gt;$&#123;requestScope.msg&#125;$&#123;sessionScope.msg&#125;$&#123;applicationScope.msg&#125; struts.xml 配置文件： 1234&lt;!--原生 Servlet API 方式--&gt;&lt;action name=\"demo2Action\" class=\"com.renkaigis.demo1.Demo2Action\"&gt; &lt;result name=\"success\"&gt;/demo1/success.jsp&lt;/result&gt;&lt;/action&gt; 案例结果：输入信息： 跳转并取值： 结果类型的跳转 结果页面存在两种方式 全局结果页面条件：如果 &lt;package&gt; 包中的一些 action 都返回 success，并且返回的页面都是同一个 JSP 页面，这样就可以配置全局的结果页面。 全局结果页面针对的 当前包 中的所有的 Action，但是如果局部还有结果页面，会 优先局部 的。使用的标签是： 123456&lt;package name=\"demo1\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--配置全局的结果页面--&gt; &lt;global-results&gt; &lt;result name=\"success\"&gt;/demo1/success.jsp&lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 局部结果页面也就是之前一直所使用的。 1&lt;result&gt;/demo1/success.jsp&lt;/result&gt; 结果页面的类型 结果页面使用 &lt;result&gt; 标签进行配置，包含两个属性 name – 逻辑视图的名称 type – 跳转的类型，需要掌握一些常用的类型。常见的结果类型去 struts-default.xml 中查找。 dispatcher – 转发，type的默认值。Action---&gt;JSP redirect – 重定向。 Action---&gt;JSP chain – 多个action之间跳转，从一个Action转发到另一个Action。 Action---Action redirectAction – 多个action之间跳转，从一个Action重定向到另一个Action。 Action---Action stream – 文件下载时候使用的 Struts2 框架的数据封装 数据的封装 作为 MVC 框架，必须要负责解析 HTTP 请求参数，并将其封装到 Model 对象中 封装数据为开发提供了很多方便 Struts2 框架提供了很强大的数据封装的功能，不再需要使用 Servlet 的 API 完成手动封装了！ Struts2 中提供了两类数据封装的方式： 第一种方式：属性驱动提供对应属性的 set 方法进行数据的封装。 表单的哪些属性需要封装数据，那么在对应的 Action 类中提供该属性的 set 方法即可。 表单中的数据提交，最终找到 Action 类中的 setXxx 的方法，最后赋值给全局变量。 注意0：Struts2 的框架采用拦截器完成数据的封装。 注意1：这种方式不是特别好：因为属性特别多，提供特别多的set方法，而且还需要手动将数据存入到对象中。 注意2：这种情况下，Action 类就相当于一个 JavaBean，就没有体现出 MVC 的思想，Action 类又封装数据，又接收请求处理，耦合性较高。 Action: 12345678910111213private String username;private String password;private Integer age;// 只需要提供 set 方法public void setUsername(String username) &#123; this.username = username;&#125;public void setPassword(String password) &#123; this.password = password;&#125;public void setAge(Integer age) &#123; this.age = age;&#125; struts.xml 1234&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--属性驱动的方式--&gt; &lt;action name=\"regist1\" class=\"com.renkaigis.demo2.Regist1Action\"/&gt;&lt;/package&gt; jsp页面 1234567&lt;h3&gt;属性驱动的方式&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/regist1.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"age\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 输出结果 1renkai 12 25 属性驱动：把数据封装到 JavaBean 对象中 在页面上，使用 OGNL 表达式进行数据封装。 在页面中使用 OGNL 表达式进行数据的封装，就可以直接把属性封装到某一个 JavaBean 的对象中。 在页面中定义一个 JavaBean，并且提供 set 方法：例如：private User user; 页面中的编写发生了变化，需要使用 OGNL 的方式，表单中的写法：&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt; 注意：只提供一个 set 方法还不够，必须还需要提供 user 属性的 get 和 set 方法！！！ 原理： 先调用 get 方法，判断一下是否有 user 对象的实例对象，如果没有，调用 set 方法把拦截器创建的对象注入进来。 Action: 12345678// 需要提供 get 和 set 方法private User user;public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; struts.xml 1234&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--属性驱动的方式，把数据封装到 JavaBean 的对象中--&gt; &lt;action name=\"regist2\" class=\"com.renkaigis.demo2.Regist2Action\"/&gt;&lt;/package&gt; jsp页面 12345678&lt;h3&gt;属性驱动的方式（把数据封装到 JavaBean 的对象中）&lt;/h3&gt;&lt;%--页面的编写发生了变化，使用的是 OGNL 表达式的写法--%&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/regist2.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"user.username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"user.password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"user.age\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 输出结果 1User&#123;username=&apos;renkai&apos;, password=&apos;12&apos;, age=25&#125; 第二种方式：模型驱动 使用模型驱动的方式，也可以把表单中的数据直接封装到一个 JavaBean 的对象中，并且表单的写法和之前的写法没有区别！ 编写的页面不需要任何变化，正常编写 name 属性的值 模型驱动的编写步骤： 手动实例化 JavaBean，即：private User user = new User(); 必须实现 ModelDriven&lt;T&gt; 接口，实现 getModel() 的方法，在 getModel() 方法中返回 user 即可！！ Action: 1234567891011121314151617181920/** * 模型驱动的方式 * 需要实现 ModelDriven 接口 * 必须要手动实例化对象（需要自己new好） */public class Regist3Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; // 必须要手动实例化 private User user = new User(); // 获取模型对象 @Override public User getModel() &#123; return user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; struts.xml 1234&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--模型驱动的方式--&gt; &lt;action name=\"regist3\" class=\"com.renkaigis.demo2.Regist3Action\"/&gt;&lt;/package&gt; jsp页面 1234567&lt;h3&gt;模型驱动的方式&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/regist3.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"age\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 输出结果 1User&#123;username=&apos;renkai&apos;, password=&apos;12&apos;, age=25&#125; Struts2 把数据封装到集合中（默认采用的是属性驱动的方式） 把数据封装到 List 集合中 因为 Collection 接口都会有下标值，所有页面的写法会有一些区别，注意： 1&lt;input type=\"text\" name=\"products[0].name\" /&gt; 在 Action 中的写法，需要提供 user 的集合，并且提供 get 和 set 方法。 Action: 12345678910111213141516171819/** * 属性驱动的方式，把数据封装到List集合中 */public class Regist4Action extends ActionSupport &#123; private List&lt;User&gt; list; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; @Override public String execute() throws Exception &#123; for (User user : list) &#123; System.out.println(user); &#125; return NONE; &#125;&#125; struts.xml 1234&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--把数据封装到List集合中--&gt; &lt;action name=\"regist4\" class=\"com.renkaigis.demo2.Regist4Action\"/&gt;&lt;/package&gt; jsp页面 1234567891011&lt;h3&gt;向List集合封装数据（默认情况下，采用的是属性驱动的方式）&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/regist4.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"list[0].username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"list[0].password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"list[0].age\" /&gt;&lt;br/&gt; 姓名:&lt;input type=\"text\" name=\"list[1].username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"list[1].password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"list[1].age\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 输出结果 12User&#123;username=&apos;renkai&apos;, password=&apos;12&apos;, age=25&#125;User&#123;username=&apos;xiaomei&apos;, password=&apos;34&apos;, age=22&#125; 把数据封装到 Ma 中 Map 集合是键值对的形式，页面的写法 1&lt;input type=\"text\" name=\"map['one'].name\" /&gt; 注意：里面的 key 值可以自定义。 Action中提供 map 集合，并且提供 get 和 set 方法 Action: 1234567891011121314151617/** * 属性驱动的方式，把数据封装到map集合中 */public class Regist5Action extends ActionSupport &#123; private Map&lt;String, User&gt; map; public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; System.out.println(map); return NONE; &#125;&#125; struts.xml 1234&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!--把数据封装到map集合中--&gt; &lt;action name=\"regist5\" class=\"com.renkaigis.demo2.Regist5Action\"/&gt;&lt;/package&gt; jsp页面：这里的 key 值自定义。 1234567891011&lt;h3&gt;向map集合封装数据（默认情况下，采用的是属性驱动的方式）&lt;/h3&gt;&lt;form action=\"$&#123; pageContext.request.contextPath &#125;/regist5.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"map['one'].username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"map['one'].password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"map['one'].age\" /&gt;&lt;br/&gt; 姓名:&lt;input type=\"text\" name=\"map['two'].username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"map['two'].password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"map['two'].age\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\" /&gt;&lt;/form&gt; 输出结果 1&#123;one=User&#123;username=&apos;renkai&apos;, password=&apos;12&apos;, age=25&#125;, two=User&#123;username=&apos;xiaomei&apos;, password=&apos;34&apos;, age=22&#125;&#125; Struts2 的拦截器技术 拦截器拦截器概述 拦截器就是 AOP（Aspect-Oriented Programming，面向切面编程）的一种实现。（AOP是指用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。） 过滤器：过滤从客服端发送到服务器端请求的。 拦截器：对目标 Action 中的某些方法进行拦截。 拦截器不能拦截JSP 拦截 Action 中某些方法 拦截器和过滤器的区别1）拦截器是基于 JAVA反射机制 的，而过滤器是基于 函数回调 的2）过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器3）拦截器 只能对Action请求 起作用（Action中的方法），而过滤器可以对 几乎所有的请求 起作用（CSS JSP JS）。 拦截器 采用 责任链 模式 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链 责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行 在 struts2 中可以定义很多个拦截器，将多个拦截器按照特定顺序组成拦截器栈（顺序调用栈中的每一个拦截器 ） Struts2 框架的核心是拦截器 自定义拦截器和配置编写拦截器需要实现 Interceptor 接口，实现接口中的三个方法 123456789protected String doIntercept(ActionInvocation invocation) throws Exception &#123; // 获取session对象 User user = (User) ServletActionContext.getRequest().getSession().getAttribute(\"existUser\"); if(user == null)&#123; // 说明，没有登录，后面就不会执行了 return \"login\"; &#125; return invocation.invoke(); &#125; 配置拦截器注意： 只要引用了自己的拦截器，Struts2 框架默认栈的拦截器就不执行了，必须要手动引入默认栈。 需要在 struts.xml 中进行拦截器的配置，配置一共有两种方式 第一种方式：直接引入 在 &lt;package&gt; 包中定义拦截器，出现在 &lt;package&gt; 包的上方 123&lt;interceptors&gt; &lt;interceptor name=\"DemoInterceptor\" class=\"com.renkaigis.interceptor.DemoInterceptor\"/&gt;&lt;/interceptors&gt; 在某个 action 中引入拦截器： 12345&lt;action name=\"userAction\" class=\"com.renkaigis.demo3.UserAction\"&gt; &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 --&gt; &lt;interceptor-ref name=\"DemoInterceptor\"/&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt;&lt;/action&gt; 第二种方式：定义拦截器栈1234567891011121314&lt;interceptors&gt; &lt;interceptor name=\"DemoInterceptor\" class=\"com.renkaigis.interceptor.DemoInterceptor\"/&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"DemoInterceptor\"/&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;action name=\"userAction\" class=\"com.renkaigis.demo3.UserAction\"&gt; &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 --&gt; &lt;interceptor-ref name=\"DemoInterceptor\"/&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt;&lt;/action&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"}]},{"title":"JavaWeb 之 Struts2 快速入门","slug":"JavaWeb-Struts201","date":"2018-06-27T13:39:05.000Z","updated":"2018-08-10T06:46:13.237Z","comments":true,"path":"JavaWeb-Struts201.html","link":"","permalink":"http://yoursite.com/JavaWeb-Struts201.html","excerpt":"Struts2 快速入门。","text":"Struts2 快速入门。 Struts2 框架的概述 Struts2 框架由来 Struts2 是 Struts1 的下一代产品，是在 struts1 和 WebWork 的技术基础上进行了合并的全新的 Struts2 框架。 其全新的 Struts2 的体系结构与 Struts1 的体系结构差别巨大。 Struts2 以 WebWork 为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与 ServletAPI 完全脱离开，所以 Struts2 可以理解为 WebWork 的更新产品。 虽然从 Struts1 到 Struts2 有着太大的变化，但是相对于 WebWork ，Struts2 的变化很小。 Struts2 设计模型Struts2 是一个基于 MVC 设计模式的 Web 层框架 MVC 和 JavaEE 的三层结构 MVC 设计模式：是由一些网站的开发人员提出来的（Model View Controller） JavaEE 三层结构：SUN 公司为 EE 开发划分的结构 常见的Web层的框架 Struts1 Struts2 ★ Webwork SpringMVC ★ Web层框架的特点 都是一个特点，前端控制器模式 记住：前端控制器（核心的控制器） Struts2 框架前端的控制器就是 过滤器 Struts2 快速入门 环境准备创建 WEB 项目编写 JSP 的页面，编写超链接，点击超链接发送请求，请求服务器，让服务器的方法去执行！！ 12&lt;h3&gt;Struts2的入门程序&lt;/h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/hello.action\"&gt;Struts2入门程序&lt;/a&gt; 下载 Struts2 的开发包 https://struts.apache.org/ – 官网地址 解压struts-2.3.24-all.zip包 解压后会看到有包和一些文件，大家需要掌握包相关的信息 apps – Struts2 框架提供了一些应用libs – Struts2 框架开发的 jar 包docs – Struts2 框架开发文档src – Struts2 框架源码 引入需要开发的 jar 包 Struts2 框架的开发 jar 包非常多，但是不是所有都是必须要引入的，有一些必须要导入的 jar 包，这些 jar 包可以从 Struts2 框架提供的应用中找到。 可以打开 apps 目录，然后找到 struts2-blank.war 应用。war 包和zip` 包的压缩格式是一样的，所以可以修改后缀名，解压。 找到解压后的应用，打开 WEB-INF/lib 目录下所以的 jar 包。复制到工程中，就可以了。 配置 Struts2 的前端控制器注意：这一步是必须要做的操作，这是 Struts2 核心的控制器。 Struts2 的前端控制器就是一个过滤器，那么过滤器相关知识咱们都学习过，需要在 web.xml 中进行配置。 前端控制器的类的路径和名称：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 具体配置如下 12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写 Action 类Action 类是动作类，是 Struts2 处理请求，封装数据，响应页面的核心控制器。需要自己编写。 123456789101112131415/** * Struts2 框架都是用 Action 类处理用户的请求 */public class HelloAction &#123; /** * Action 类中的方法签名是有要求的，必须这么做 * public 共有的 * 必须有返回值，必须 String 类型 * 方法名称可以是任意的，但是不能有参数列表 */ public String sayHello()&#123; System.out.println(\"Hello Struts2!\"); return \"OK\"; &#125;&#125; 编写 Struts 的配置文件 配置文件名称是 struts.xml（名称必须是 struts.xml） 在 src 下引入 struts.xml 配置文件（配置文件的路径必须是在 src 的目录下） 配置如下 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--配置 Action--&gt; &lt;action name=\"hello\" class=\"com.renkaigis.action.HelloAction\" method=\"sayHello\"/&gt; &lt;/package&gt;&lt;/struts&gt; 编写跳转12345678&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"hello\" class=\"com.renkaigis.action.HelloAction\" method=\"sayHello\"&gt; &lt;!--配置跳转的页面，路径的写法。在 Struts2 框架中，不管是转发还是重定向，都不用写项目名--&gt; &lt;result name=\"OK\"&gt;/demo1/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 总结 Struts2 执行流程执行的流程 编写的页面，点击超链接，请求提交到服务器端。 请求会先经过 Struts2 的核心过滤器（StrutsPrepareAndExecuteFilter） 过滤器的功能是完成了一部分代码功能就是一系列的拦截器执行了，进行一些处理工作。可以在 struts-default.xml 配置文件中看到有很多的拦截器。 拦截器执行完后，会根据 struts.xml 的配置文件找到请求路径，找到具体的类，通过反射的方式让方法执行。 总结 JSP页面 –&gt; StrutsPrepereAndExecuteFilter过滤器 –&gt; 执行一系列拦截器（完成了部分代码） –&gt; 执行到目标 Action –&gt; 返回字符串 –&gt; 结果页面（result） –&gt; 页面跳转 Struts2 框架配置文件加载的顺序Struts2 框架的核心是 StrutsPrepareAndExecuteFilter 过滤器该过滤器有两个功能 Prepare – 预处理，加载核心的配置文件 Execute – 执行，让部分拦截器执行 StrutsPrepareAndExecuteFilter 过滤器会加载哪些配置文件呢？通过源代码可以看到具体加载的配置文件和加载配置文件的顺序 init_DefaultProperties(); – 加载 org/apache/struts2/default.properties init_TraditionalXmlConfigurations(); – 加载 struts-default.xml,struts-plugin.xml,struts.xml init_LegacyStrutsProperties(); – 加载自定义的 struts.properties init_CustomConfigurationProviders(); – 加载用户自定义配置提供者 init_FilterInitParameters() ; – 加载 web.xml 重点了解的配置文件 default.properties – 在 org/apache/struts2/ 目录下，代表的是配置的是 Struts2 的常量的值 struts-default.xml – 在 Struts2 的核心包下，代表的是 Struts2 核心功能的配置（Bean、拦截器、结果类型等） struts.xml – 重点中的重点配置，代表 WEB 应用的默认配置，在工作中，基本就配置它就可以了！！（可以配置常量） web.xml – 配置前端控制器（可以配置常量） 注意： 前 3 个配置文件是 struts2 框架的默认配置文件，基本不用修改。 后 3 个配置文件可以允许自己修改 struts2 的常量。但是有一个特点：后加载的配置文件修改的常量的值，会覆盖掉前面修改的常量的值。 总结（重点掌握的配置文件） 先加载 default.properties 文件，在 org/apache/struts2/default.properties 文件，都是常量。 又加载 struts-default.xml 配置文件，在核心的 jar 包最下方，struts2 框架的核心功能都是在该配置文件中配置的。 再加载 struts.xml 的配置文件，在 src 的目录下，代表用户自己配置的配置文件 最后加载 web.xml 的配置文件 后加载的配置文件会覆盖掉之前加载的配置文件（在这些配置文件中可以配置常量） 注意一个问题哪些配置文件中可以配置常量？ default.properties – 默认值，是不能修改的！！ struts.xml – 可以配置，开发中基本上都在该配置文件中配置常量 struts.properties – 可以配置，基本不会在该配置文件中配置 web.xml – 可以配置，基本不会在该配置文件中配置 后加载的配置文件会覆盖掉之前加载的配置！！ struts.xml 配置文件 基本标签&lt;package&gt; 标签如果要配置 &lt;Action&gt; 的标签，那么必须要先配置 &lt;package&gt; 标签，代表的包的概念 包含的属性: name – 包的名称，要求是唯一的，管理 action配置 extends – 继承，可以继承其他的包，只要继承了，那么该包就包含了其他包的功能，一般都是继承 struts-default namespace – 名称空间，一般与 &lt;action&gt; 标签中的 name 属性共同决定访问路径（通俗话：怎么来访问 action），常见的配置如下 namespace=”/“ – 根名称空间namespace=”/aaa” – 带有名称的名称空间 abstract – 抽象的。这个属性基本很少使用，值如果是 true，那么编写的包是被继承的 &lt;action&gt; 标签代表配置 action 类，包含的属性 name – 和 &lt;package&gt; 标签的 namespace 属性一起来决定访问路径的 class – 配置 Action 类的全路径（默认值是 ActionSupport 类） method – Action 类中执行的方法，如果不指定，默认值是 execute &lt;result&gt; 标签action类中方法执行，返回的结果跳转的页面 name – 结果页面逻辑视图名称 type – 结果类型（默认值是转发，也可以设置其他的值） Struts2 配置常量Struts2 框架中的哪些配置文件中配置常量？struts.xml（必须要掌握，开发中基本上就在该配置文件中编写常量） 1* &lt;constant name=\"key\" value=\"value\"&gt;&lt;/constant&gt; web.xml 在 StrutsPrepareAndExecuteFilter 配置文件中配置初始化参数 注意：后加载的配置的文件的常量会覆盖之前加载的常量！！ 需要了解的常量 struts.i18n.encoding=UTF-8 – 指定默认编码集，作用于 HttpServletRequest 的 setCharacterEncoding 方法 struts.action.extension=action,, – 该属性指定需要 Struts 2 处理的请求后缀，该属性的默认值是 action，即所有匹配 *.action 的请求都由 Struts2 处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开 struts.serve.static.browserCache=true – 设置浏览器是否缓存静态内容,默认值为 true (生产环境下使用)，开发阶段最好关闭 struts.configuration.xml.reload=false – 当 struts 的配置文件修改后，系统是否自动重新加载该文件，默认值为 false(生产环境下使用) struts.devMode = false – 开发模式下使用，这样可以打印出更详细的错误信息 指定多个struts的配置文件（了解） 在大部分应用里，随着应用规模的增加，系统中 Action 的数量也会大量增加，导致 struts.xml 配置文件变得非常臃肿。 为了避免 struts.xml 文件过于庞大、臃肿，提高 struts.xml 文件的可读性，我们可以将一个 struts.xml 配置文件分解成多个配置文件，然后在 struts.xml 文件中包含其他配置文件。 可以在 &lt;package&gt; 标签中，使用 &lt;include&gt; 标签来引入其他的 struts_xx.xml 的配置文件。例如： 1234&lt;struts&gt; &lt;include file=\"struts-part1.xml\"/&gt; &lt;include file=\"struts-part2.xml\"/&gt;&lt;/struts&gt; 注意注意注意（重要的事情说三遍）： 1&lt;include file=\"com/renkaigis/demo2/struts-part1.xml\"/&gt; Action 类的三种写法Action类就是一个POJO类 什么是 POJO 类，POJO（Plain Ordinary Java Object）简单的 Java 对象，简单记：没有继承某个类，没有实现接口，就是 POJO 的类。 12345678910111213/** * 是 POJO 类：没有任何继承和实现 */public class Demo1Action &#123; /** * execute 是默认方法 * return null; 不会进行跳转 */ public String execute()&#123; System.out.println(\"Demo1Action 是一个 POJO 类…\"); return null; &#125;&#125; 配置文件： 12&lt;!--POJO 类的方式--&gt;&lt;action name=\"demo1Action\" class=\"com.renkaigis.action1.Demo1Action\"/&gt; Action 类可以实现 Action 接口Action 接口中定义了 5 个常量，5 个常量的值对应的是 5 个逻辑视图跳转页面（跳转的页面还是需要自己来配置），还定义了一个方法，execute 方法。 需要掌握5个逻辑视图的常量 SUCCESS – 成功 INPUT – 用于数据表单校验.如果校验失败,跳转 INPUT 视图 LOGIN – 登录 ERROR – 错误 NONE – 页面不转向 1234567891011/** * 实现 Action 接口，Action 是框架提供的接口 */public class Demo2Action implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Demo2Action 实现了 Action 的接口…\"); return SUCCESS; &#125;&#125; 配置文件： 1234&lt;!--实现 Action 接口的方式--&gt;&lt;action name=\"demo2Action\" class=\"com.renkaigis.action1.Demo2Action\"&gt; &lt;result name=\"success\"&gt;/demo1/success.jsp&lt;/result&gt;&lt;/action&gt; Action 类可以去继承 ActionSupport 类（开发中这种方式使用最多） 12345678910/** * 编写 Action 类继承 ActionSupport 类，ActionSupport 类已经实现了 Action 和一些其他的接口 */public class Demo3Action extends ActionSupport &#123; @Override public String execute() throws Exception &#123; System.out.println(\"Demo3Action 继承了 ActionSupport 类…\"); return NONE; &#125;&#125; 配置文件： 12&lt;!--继承 ActionSupport 类的方式--&gt;&lt;action name=\"demo3Action\" class=\"com.renkaigis.action1.Demo3Action\"/&gt; Action 的访问传统的配置方式通过 &lt;action&gt; 标签中的 method 属性，访问到 Action 中的具体的方法。 传统的配置方式，配置更清晰更好理解！但是扩展需要修改配置文件等！ 具体的实例如下： 页面代码 123&lt;H3&gt;传统的配置文件的方式&lt;/H3&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/saveCust.action\"&gt;保存客户&lt;/a&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/updCust.action\"&gt;修改客户&lt;/a&gt; 配置文件的代码 123&lt;!--传统方式--&gt;&lt;action name=\"saveCust\" class=\"com.renkaigis.action2.CustomerAction\" method=\"save\"/&gt;&lt;action name=\"updCust\" class=\"com.renkaigis.action2.CustomerAction\" method=\"update\"/&gt; Action 的代码 123456789101112131415/** * 编写客户的 Action 类 */public class CustomerAction extends ActionSupport &#123; public String save() &#123; System.out.println(\"保存客户…\"); return NONE; &#125; public String update() &#123; System.out.println(\"修改用户…\"); return NONE; &#125;&#125; 通配符的访问方式（访问的路径和方法的名称必须要有某种联系） 通配符就是 * 代表任意的字符 使用通配符的方式可以简化配置文件的代码编写，而且扩展和维护比较容易。 具体实例如下： 页面代码 123&lt;H3&gt;通配符配置文件的方式&lt;/H3&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/linkman_save.action\"&gt;保存联系人&lt;/a&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/linkman_update.action\"&gt;修改联系人&lt;/a&gt; 配置文件代码 1234&lt;!--通配符的方式--&gt;&lt;action name=\"linkman_*\" class=\"com.renkaigis.action2.LinkmanAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"saveOK\"&gt;/demo2/success.jsp&lt;/result&gt;&lt;/action&gt; Action 的代码 1234567891011121314/** * 使用联系人来测试通配符 */public class LinkmanAction extends ActionSupport &#123; public String save() &#123; System.out.println(\"保存联系人…\"); return \"saveOK\"; &#125; public String update() &#123; System.out.println(\"修改联系人…\"); return NONE; &#125;&#125; 具体理解：在 JSP 页面发送请求，http://localhost:9090/demo2/linkman_save.action，配置文件中的 linkman_* 可以匹配该请求，* 就相当于变成了 add，method 属性的值使用 {1} 来代替，{1} 就表示的是第一个 * 号的位置！！所以 method 的值就等于了 add，那么就找到 Action 类中的 add 方法，那么 add 方法就执行了！ 动态方法访问的方式（有的开发中也会使用这种方式） 如果想完成动态方法访问的方式，需要开启一个常量，struts.enable.DynamicMethodInvocation = false，把值设置成 true。 注意：不同的 Struts2 框架的版本，该常量的值不一定是 true 或者 false，需要自己来看一下。如果是 false，需要自己开启。 在 struts.xml 中开启该常量。 12&lt;!-- 开启动态方法访问 --&gt;&lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"&gt;&lt;/constant&gt; 具体实例如下： 页面的代码 123&lt;H3&gt;动态方法访问的方式&lt;/H3&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/user!save.action\"&gt;保存用户&lt;/a&gt;&lt;a href=\"&#123;pageContext.request.contextPath&#125;/user!update.action\"&gt;修改用户&lt;/a&gt; 配置文件代码 12&lt;!--配置动态方法访问--&gt;&lt;action name=\"user\" class=\"com.renkaigis.action2.UserAction\"/&gt; Action的类的代码 1234567891011public class UserAction extends ActionSupport &#123; public String save() &#123; System.out.println(\"保存用户…\"); return NONE; &#125; public String update() &#123; System.out.println(\"修改用户…\"); return NONE; &#125;&#125; 总结Struts2 框架主要以下几个步骤： 编写 web.xml 前端控制器12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写 struts.xml 配置文件12345&lt;package name=\"\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"\" class=\"com.renkaigis.action2.LinkmanAction\" method=\"&#123;1&#125;\"&gt; &lt;result name=\"saveOK\"&gt;/demo2/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 编写 Action 类 一般继承 ActionSupport 类 &lt;action&gt; 访问配置一般使用 通配符 的方式： name=&quot;user_*&quot; method=&quot;{1}&quot;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"}]},{"title":"世间安得双全法，不负如来不负卿","slug":"novel-nverqing","date":"2018-06-18T12:05:27.000Z","updated":"2019-09-04T11:39:12.609Z","comments":true,"path":"novel-nverqing.html","link":"","permalink":"http://yoursite.com/novel-nverqing.html","excerpt":"图源微博：青暮从山","text":"图源微博：青暮从山 世间安得双全法，不负如来不负卿。唐玄奘师徒四人取经之路历经千难万险，为的是求取至高无上的佛法佛理，凭的是普渡众生的苍生大义。 这一路，最难的不是遇到妖魔鬼怪，也不是碰到魔女画皮，更不是什么蝎子精蜘蛛精。 而是唐玄奘的心魔，或者说是情劫。 佛曰：色即是空，空即是色。 不惧大风大浪、高山戈壁，也不怕魑魅魍魉、鬼怪妖邪，最怕的是和尚没了取经的念头啊。 （一）缘起却说这一日，碧空如洗，和风习习。 小船悠悠，师徒四人不知不觉就来到了西梁女国了。 唐玄奘虽也是见过大风大浪的人，可还是第一次来到一个只有女子的国度。 走在大街上，周围投射来新奇又热烈的目光，玄奘只觉得浑身不自在。 心中默念“阿弥陀佛”，一心只想着赶快换了通关文牒，离开这个是非之地。 女王听闻唐朝高僧觐见，闪凤目，簇蛾眉，仔细观看，果然一表非凡。 丰姿英伟，相貌轩昂。齿白如银砌，唇红口四方。顶平额阔天仓满，目秀眉清地阁长。两耳有轮真杰士，一身不俗是才郎。好个妙龄聪俊风流子，堪配西梁窈窕娘。[1] 玄奘见到女王陛下，双手合十，恭敬的行礼：“贫僧唐三藏参见女王陛下”。 却见没有声响。 连忙继续“贫僧唐三藏参见女王陛下”。还是没有回应。 无奈只得再拜“贫僧唐三藏参见女王陛下”。玄奘却不知，这女王正细细端详着他的面庞出神，哪听得到他在说什么。 玄奘本想着通关文牒上加盖宝印是很简单的事，却没料想女王陛下让他与徒儿先到馆驿休息。 （二）梦 此部分对话皆来自央视 86 版《西游记》第十六集《趣经女儿国》台词。[2] 夜里，檀香缭绕，女王独坐窗前，画笔下轻轻勾勒着，画上的人可不就是今天来的大唐高僧吗。 闻得太师唤她，女王连忙用绢布将画遮起来。 女王禁不住心下欣喜，同太师说道：“想我西梁女国，从未有过男子，今日有幸，天赐唐王御弟下降。我想这是千载难逢的机缘，愿以一国之富，招他为王，我为王后。” 深夜，女王倚着软塌，望着唐三藏的画像，渐渐陷入了沉睡。 这夜，她做了一个梦。 梦里，他为王，她为后。 梦里，他们策马驰骋。 梦里，他们相互依偎，同游御花园… 梦醒，却是一阵阵失落。 翌日，依着梦境，女王邀玄奘同游御花园。 女王莲步轻移，谈天说地，玄奘却一直恭恭敬敬，时刻与女王保持着距离。 “你看那戏水鸳鸯，如胶似漆，多么欢快，你说是吗？” 玄奘拱手道：“陛下看的真切，贫僧不曾留意。” “御弟哥哥，为什么天地间的鸟呀、蝶呀，都要成对成双的呢？” “这事自有天地以来便是如此。” “御弟……哥哥……” “陛下……” 女王眸中泛着微光，带着哭腔央求道：“不去取经行不行？” “这……哎……”玄奘轻叹一声，不知如何回应。 只听女王叹道：“为什么世间还有像我们这样的孤男寡女，不能成双成对？” 玄奘连忙说，“陛下，贫僧许身佛门，正是为了解救芸芸众生，使世上不再有杀伐纷争，使人间不再有怨女旷夫。” “既然御弟哥哥有如此情怀，那么眼前就有需要你解救的芸芸众生！” 女王无奈，你只知解救芸芸众生，却不救救我？ “哎……陛下，贫僧取经心切，还望陛下早日发放通关牒文。” “今日且莫谈取经之事，御弟哥哥，你看这御花园中春光明媚，景色怡人，我再陪哥哥流连观赏一番，好吗？” 且看湖中鸳鸯戏水，桥上人成双成对。 女王看着玄奘，眸中柔情似水。 （三）情动 此部分对话皆来自央视 86 版《西游记》第十六集《趣经女儿国》台词。[2] 是夜，女王以“夜赏国宝”为由将玄奘请至自己的寝殿。 玄奘来到之后才恍然过来，急忙给女王解释道：“太师领贫僧夜赏国宝，不知为何闯到陛下寝宫？” 只闻帘后人温柔至极，“御弟哥哥，那就请观赏国宝吧！” 床帘徐徐展开，只见床上人斜倚塌前，薄纱缚身，丹唇轻启，头戴高簪珠翠，一副雍容华贵之姿。 玄奘闻言，又看到这一幕，耳红面赤，羞答答不敢抬头。 “难道在御弟哥哥眼里，我还算不得国宝吗？” 说着，女王捧起一盏烛火向玄奘走来。 玄奘早已慌得不知如何是好，不敢正面看她，却忍不住偷偷看她的背影。 “哥哥你看，这烛光也知人情，欲照今日之喜。” “不知陛下喜从何来？” “我身为女王，饱享荣华富贵，可是，从未享受过人间欢乐。今日哥哥到此，真乃天赐良缘。来日哥哥登上宝座，我为王后，从此双宿双飞，这不是万千之喜吗？” 玄奘目光移向别处，使自己快速镇静下来。“佛心四大皆空，贫僧尘念已绝，无缘消受人间富贵。阿弥陀佛…” 说完，紧闭双眼，不敢再多看一眼。 女王依旧巧笑嫣然，如若月里嫦娥到此一般，美得不可方物。 “你说四大皆空，却紧闭双眼。要是你睁开眼睛看看我，我不相信你两眼空空。” 玄奘眯着眼看了看，但又很快紧闭双眼，嘴中不停念叨着阿弥陀佛。 “不敢睁眼看我，还说什么四大皆空呢？”女王看着他颤抖的唇和额头的汗珠，笑意盈盈的反驳他。 玄奘无奈，睁开眼看向女王。 只见眼前人，眉如翠羽，肌似羊脂。脸衬桃花瓣，鬟堆金凤丝。秋波湛湛妖娆态，春笋纤纤妖媚姿。斜軃红绡飘彩艳，高簪珠翠显光辉。[3] 这一眼看得他呆了很久很久，他的额头又一次布满了细密的汗珠。 玄奘连忙回过神来，眼睛移向别处，匆忙用袖子擦拭额头的汗，又念了句“阿弥陀佛”。 “哥哥，别闭上，睁开眼睛吧。” “你就睁开眼睛吧。” 玄奘摇头，“我就是睁眼看你，又能怎样？” “哥哥……” 说着，女王趴在玄奘肩上，拽着他的袈裟袖子，无限暧昧。 玄奘慌了，连忙起身将袖子从她手中拽出。却不想拉扯之间，对方突然放手，自己躺倒在了女王的床上。 玄奘欲起身，却见女王口中不停唤着“哥哥…哥哥…”，将他又一次推倒在床上。 玄奘想反抗，却手忙脚乱不知如何是好，时刻把持着尺度。 女王幽怨的看着他，“哥哥，你难道真的不喜欢我吗？” 玄奘犹豫了，他心里似云海翻涌，不知道怎么作答。只得偏过头去，不让女王看见自己的表情。 女王看着他的样子，更加贴近他，温言软语：“今夜良宵难得，你就答应了我吧” 玄奘长呼一口气，镇静如初，“女王陛下，贫僧已许身佛门，与大唐天子有诺在先，还望女王陛下放了贫僧西去。” 说着，顿了顿，玄奘缓缓转过头来，看着她的背影说道：“来世若有缘分……” 后面的话犹豫了很久说不出口，玄奘也许真的动了心吧。今世无缘，只能来世再续。 女王听闻，心中一喜，若论来世，谁又说的准呢。“我只想今生，不想来世。今生今世，我们俩是有缘分的。” 说着，头倚在玄奘肩上。 良辰美景，灯光烛影之间，两人你侬我侬。 玄奘欲拒还迎，虽故作镇静，但凡心已动，怎奈终究摆脱不了女王。 （四）不负如来却说唐玄奘被那蝎子精掳走，这妖精山洞中灯红酒绿，一副洞房的装扮。 同样是绝世美人儿，玄奘却对那蝎子精提不起一点兴趣。 即使她不是妖怪，即使她再怎么美艳动人，在玄奘眼中只有嫌弃。 玄奘一个出家人自然不懂自己心里的变化。 脑海里依旧浮现着女王的一颦一笑，极尽温柔，极尽欢乐。 玄奘不知道自己动没动情。 他自己不知道，他也不想知道。 面对一个『情』字，七情六欲皆无的玄奘居然选择了逃避。 他怕的是什么？什么王权富贵，什么戒律清规？ 他怕的是，如果动情了，就负了如来；如果不动情，就辜负了“她”。 （五）相见难，别亦难待到临行女儿国之际，女王依依不舍的在通关文牒上盖上印章。 女王哀怨的看着玄奘，舍不得与他分离。身为女王，却留不住这个凡人。 那天，她一直送他到城外。 这一路上，两人没有说过一句话。 这段路，是女王走过的最长的路，也是女王最不想走完的一段路。 这段路，是玄奘走的最不舒服的一段路，虽有佳人在侧，却如鲠在喉。 直到城外，玄奘打破了沉默，“陛下，请留步！”。 女王看着她，欲语还休，怎诉这胸中蜜语万千。只怨今生无缘，道不尽声声珍重，默默地祝君一路平安。 女王唇齿轻咬，似乎是做了很大的一个决定，将关文递给眼前人。 玄奘接过关文，对女王拱手道：“多谢陛下。” 这里，玄奘行的是俗家礼，只因尘缘未了，只有等到来世… 奈何戒律清规，奈何天子之诺，奈何芸芸众生，玄奘纵有万般不舍，也只得策马扬鞭，西行而去。 她在城头似哭似笑，当着百官的面对着他的背影大喊：“御弟哥哥……”千言万语梗在胸中，无法诉说。 夕阳下，玄奘勒马回头，只看了一眼。遂又毅然决然扬鞭而去… 只留女王，孑然一人，孤立城头。 “唐玄奘，下辈子娶我可好？” 风沙漫天，看不见他的表情，也看不见她脸上的泪痕。 僧人不语，只余风声喧嚣。 （六）圆寂玄奘走后的日子，女王日日思君不见君。从来不相信一见钟情的女王，居然败给了一个和尚。 佛门无尘缘。你许我来生，可你既已成佛，又何来来世？ 女王只得在闭塞的女儿国内，努力打探着外界的消息，尤其是关于他的一点一滴。 听闻他取得真经，听闻他受万人朝拜。女王为他高兴，也为自己难过。 数十年的等待，如今女王已人老珠黄。若玄奘你回来，还会认得这个人吗。 女王不过是凡人，有七情六欲，也有生老病死。若说来生，谁还记得谁？ 这天，有属下来报，白马寺玄奘法师圆寂。 如晴天霹雳般，女王瘫倒在塌，泪流满面。 颤颤巍巍的她来到御花园，看着湖中鸳鸯戏水，园中彩蝶翩翩，想起和御弟哥哥的那一幕幕。 宫中议论纷纷，隐约可以听到有宫女说道： 『 听说那唐朝和尚圆寂的时候，千佛诵经，万众朝宗，他走的时候只笑着留下一句：“好！” 』 犹记得那日两人分别时，女王对着他的背影大喊： “唐玄奘，下辈子娶我可好？” （七）成佛玄奘取得真经，回到白马寺，受万人敬仰。每日吃斋念佛，诵经以普度众生。 两耳不闻窗外事，但是他真的忘了那段情劫吗？ 玄奘本乃金蝉子转世，圆寂后成佛，世称“旃檀功德佛”。 前世的许诺玄奘还记得，但既身已成佛，心亦要剔除七情六欲。 佛不比前世的唐朝和尚，那时尚可动情，现在心止如死水。 佛曰：人生有八苦：生，老，病，死，爱别离，怨长久，求不得，放不下。 佛又曰：一切有为法，如梦幻泡影。如露亦如电，应作如是观。 果真是生劫易渡，情劫难了。 始于必经之劫，终于苍生大义。 女王我做了一个梦，你蓄起了长发，我们一起慢慢变老。 我不后悔遇见你。 我也不后悔遇见你之后爱上你。 我更不后悔守着你许诺的来世等了你数多载。 我身为一国之主，却留不住你这个凡人。 何以缘起，何以缘灭。若是没遇见，错过便是错过。 可是一旦遇见了，一旦动了情，又怎叫人放得下。 你心中只有众生和戒律清规，可是我心中却只有你。 一个人孤寂的等了你那么多年，最后等来了你圆寂的消息。 至此，我也就断了这世间的一切念想了。 这世间没了你，我要怎么活？ 玄奘世间安得双全法，不负如来不负卿。 如果动情了，就负了如来；如果不动情，就辜负了“她”。 我本是如来二弟子金蝉子，只因不听佛祖说法，轻漫佛法，转世为大唐高僧。奉观世音菩萨之命前往西天大雷音寺求取大乘佛法，普渡众生。 直到我来到西梁女国，见到了那位花颜月貌的女王。 我觉得我难逃此劫了…… 不知道为什么，我不敢看她的眼睛，我也不敢和她多说话。 但是看到她明媚的笑我又会很欢喜，虽然极力控制着自己。 是否我这个出家人真的动了情？ 我一直都在躲避这个问题，让自己不要去想，我以为不去想就会忘掉这一切。 那一夜，烛火摇曳，我差点就万劫不复。 多亏了蝎子精横插一脚，我想这便是佛祖派蝎子精来警告我的。 想起自己身负拯救苍生的使命，纵使千世万世无欲无情也在所不惜。 『 曾虑多情损梵行，入山又恐别倾城。世间安得双全法，不负如来不负卿。 』 终究没有负了如来，却负了你。 今世的你是什么身份，今世的你又在哪里。 也许有情，奈何缘浅。 参考引用B站 - 【西游记女儿国国王】之 浮生相思梦 文中所用图源于微博：青暮从山 1.《西游记》第五十四回-法性西来逢女国，心猿定计脱烟花：女王闪凤目，簇蛾眉，仔细观看，果然一表非凡，你看他丰姿英伟，相貌轩昂。齿白如银砌，唇红口四方。顶平额阔天仓满，目秀眉清地阁长。两耳有轮真杰士，一身不俗是才郎。好个妙龄聪俊风流子，堪配西梁窈窕娘。 ↩2.央视 86 版《西游记》第十六集《趣经女儿国》台词。 ↩3.《西游记》第五十四回-法性西来逢女国，心猿定计脱烟花：猪八戒在旁，掬着嘴，饧眼观看那女王，却也袅娜，真个眉如翠羽，肌似羊脂。脸衬桃花瓣，鬟堆金凤丝。秋波湛湛妖娆态，春笋纤纤妖媚姿。斜軃红绡飘彩艳，高簪珠翠显光辉。说什么昭君美貌，果然是赛过西施。柳腰微展鸣金珮，莲步轻移动玉肢。月里嫦娥难到此，九天仙子怎如斯。宫妆巧样非凡类，诚然王母降瑶池。 ↩","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"http://yoursite.com/tags/Novel/"}]},{"title":"JavaWeb 之 Hibernate 查询方式与策略优化","slug":"JavaWeb-Hibernate05","date":"2018-06-05T07:21:45.000Z","updated":"2018-08-10T06:41:21.246Z","comments":true,"path":"JavaWeb-Hibernate05.html","link":"","permalink":"http://yoursite.com/JavaWeb-Hibernate05.html","excerpt":"Hibernate 查询方式与策略优化","text":"Hibernate 查询方式与策略优化 Hibernate 框架的查询方式 唯一标识 OID 的检索方式 123session.get(对象.class,OID);// 例如：Customer customer = session.get(Customer.class, 1L); 对象的导航的方式 比如，查询客户下的联系人： 1Customer.getLinkmans(); HQL 的检索方式 （Hibernate Query Language） – Hibernate 的查询语言 QBC 的检索方式 （Query By Criteria） – 条件查询 SQL 检索方式（了解） 本地的SQL检索 HQL 查询HQL 概述**HQL 的介绍 HQL (Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似。 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 HQL 与 SQL 的关系 HQL 查询语句是面向对象的，Hibernate 负责解析 HQL 查询语句，然后根据对象-关系映射文件中的映射信息，把 HQL 查询语句翻译成相应的 SQL 语句。 HQL 查询语句中的主体是域模型中的类及类的属性； SQL 查询语句是与关系数据库绑定在一起的。SQL 查询语句中的主体是数据库表及表的字段。 HQL 的基本查询HQL 基本的查询格式 支持 方法链 的编程，即直接调用 list() 方法 简单的代码如下 1session.createQuery(\"from Customer\").list(); 12345678910111213141516/** * 基本查询的演示 */@Testpublic void run1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Query query = session.createQuery(\"from Customer\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tr.commit();&#125; 使用别名的方式 可以使用别名的方式 不能出现 *，即不能 select * from Customer c ✖ 12session.createQuery(\"from Customer c\").list();session.createQuery(\"select c from Customer c\").list(); 排序查询排序查询和 SQL 语句中的排序的语法是一样的： 升序 1session.createQuery(\"from Customer order by cust_id\").list(); 降序 1session.createQuery(\"from Customer order by cust_id desc\").list(); 分页查询不论使用的是 MySQL 还是 Oracle，都可以使用 Hibernate 框架提供的分页方法。 两个方法如下： 12setFirstResult(a); // 从哪条记录开始，如果查询是从第一条开始，值是 0setMaxResults(b); // 每页查询的记录条数 演示代码如下 1List&lt;LinkMan&gt; list = session.createQuery(\"from LinkMan\").setFirstResult(0).setMaxResults().list(); 12345678910111213141516171819/** * 分页查询 */@Testpublic void run2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); // 查询联系人 Query query = session.createQuery(\"from Linkman l order by l.lkm_id\"); // 分页查询，调用方法，查询第一页的数据 1-3 条 query.setFirstResult(0); query.setMaxResults(3); List&lt;Linkman&gt; list = query.list(); for(Linkman linkman:list)&#123; System.out.println(linkman); &#125; tr.commit();&#125; 条件查询 setParameter(&quot;?号的位置，默认从0开始&quot;,&quot;参数的值&quot;); 不用考虑参数的具体类型 按位置绑定参数的条件查询（指定下标值，默认从 0 开始） 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） 例如代码如下： 1234567891011121314151617181920212223/** * 按条件查询 */@Testpublic void run3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); // 查询联系人 Query query = session.createQuery(\"from Linkman l where l.lkm_gender = ?\"); // 传入值 // query.setString(0, \"男\"); // Query query = session.createQuery(\"from Linkman l where l.lkm_id &gt; 2\"); // query.setLong(0, 2L); // 通用的方法，不用判断具体的类型 query.setParameter(0, \"男\"); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) &#123; System.out.println(linkman); &#125; tr.commit();&#125; HQL 的投影查询投影查询就是想查询某一字段的值或者某几个字段的值。 投影查询的案例： 如果查询多个字段，例如下面这种方式 1234List&lt;Object[]&gt; list = session.createQuery(\"select c.cust_name,c.cust_level from Customer c\").list();for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects));&#125; 如果查询两个字段，也可以把这两个字段封装到对象中 先在持久化类中 提供对应字段的构造方法（不要忘了空的构造方法）语句也要像下面一样发生改变 1234List&lt;Customer&gt; list = session.createQuery(\"select new Customer(c.cust_name,c.cust_level) from Customer c\").list();for (Customer customer : list) &#123; System.out.println(customer);&#125; 聚合函数查询count()、sum()、avg()、max()、min()等。 获取总的记录数12345678Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();// 也可以是 select count(*) from CustomerList&lt;Number&gt; list = session.createQuery(\"select count(c) from Customer c\").list();// 通过下标取值Long count = list.get(0).longValue();System.out.println(count);tr.commit(); 获取某一列数据的和123456Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();List&lt;Number&gt; list = session.createQuery(\"select sum(c.cust_id) from Customer c\").list();Long count = list.get(0).longValue();System.out.println(count);tr.commit(); HQL 多表查询多表的查询HQL 语句和 SQL 语句的查询语法比较类似。 内连接查询 显示内连接 1select * from customers c inner join orders o on c.cid = o.cno; 隐式内连接 1select * from customers c,orders o where c.cid = o.cno; 外连接查询 左外连接 1select * from customers c left join orders o on c.cid = o.cno; 右外连接 1select * from customers c right join orders o on c.cid = o.cno; 迫切和非迫切 非迫切返回结果是 Object[] 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的 Set 集合中。 内连接查询 内连接使用 inner join ，默认返回的是 Object 数组 1234567891011121314151617/** * 内连接，数据默认返回的是数组 */@Testpublic void run1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); // 默认返回数组 Query query = session.createQuery(\"from Customer c inner join c.linkmans\"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tr.commit();&#125; 迫切内连接: inner join fetch ，返回的是实体对象 1234567891011121314151617181920/** * 内连接，数据默认返回的是数组 * 把数据封装到对象中 * 使用关键字：fetch 迫切连接，这样就会把数据封装到对象中 * 此时数据会重复 */@Testpublic void run1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); // 使用 fetch 迫切连接，封装数据 Query query = session.createQuery(\"from Customer c inner join fetch c.linkmans\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tr.commit();&#125; 解决数据重复： 123456789101112131415161718/** * 解决数据的重复问题 */@Testpublic void run2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Query query = session.createQuery(\"from Customer c inner join fetch c.linkmans\"); List&lt;Customer&gt; list = query.list(); // 手动解决数据重复问题，编程中都使用这种方式来解决重复的问题 Set&lt;Customer&gt; set=new HashSet&lt;&gt;(list); for (Customer customer : set) &#123; System.out.println(customer); &#125; tr.commit();&#125; 左外连接查询 左外连接: 封装成 List&lt;Object[]&gt; 迫切左外连接 12345678Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();List&lt;Customer&gt; list = session.createQuery(\"from Customer c left join fetch c.linkmans\").list();Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list);for (Customer customer : set) &#123; System.out.println(customer);&#125;tr.commit(); QBC 查询QBC：Query By Criteria，按条件进行查询。 Criteria：代表一次查询； Criterion：代表一个查询条件； Restrictions：产生查询条件的工具类。 简单查询使用的是 Criteria 接口： 1234List&lt;Customer&gt; list = session.createCriteria(Customer.class).list();for (Customer customer : list) &#123; System.out.println(customer);&#125; 排序查询 需要使用 addOrder() 的方法来设置参数，参数使用 org.hibernate.criterion.Order 对象。 具体代码如下： 1234567891011Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();Criteria criteria = session.createCriteria(Linkman.class);// 设置排序// criteria.addOrder(Order.asc(\"lkm_id\"));criteria.addOrder(Order.desc(\"lkm_id\"));List&lt;Linkman&gt; list = criteria.list();for (Linkman linkman : list) &#123; System.out.println(linkman);&#125;tr.commit(); 分页查询QBC 的分页查询也是使用两个方法: setFirstResult(); setMaxResults(); 代码如下; 123456789101112Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();Criteria criteria = session.createCriteria(Linkman.class);// 设置排序criteria.addOrder(Order.desc(\"lkm_id\"));criteria.setFirstResult(0);criteria.setMaxResults(3);List&lt;Linkman&gt; list = criteria.list();for (Linkman linkman : list) &#123; System.out.println(linkman);&#125;tr.commit(); 条件查询Criterion 是查询条件的接口，Restrictions 类是 Hibernate 框架提供的工具类，使用该工具类来设置查询条件。 条件查询使用 Criteria 接口的 add 方法，用来传入条件。 使用 Restrictions 的添加条件的方法，来添加条件，例如： 方法 含义 Restrictions.eq 相等 Restrictions.gt 大于号 Restrictions.ge 大于等于 Restrictions.lt 小于 Restrictions.le 小于等于 Restrictions.between 在之间 Restrictions.like 模糊查询 Restrictions.in 范围 Restrictions.and 并且 Restrictions.or 或者 Restrictions.isNull 查询某属性为空的值 测试代码如下 12345678910111213Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();Criteria criteria = session.createCriteria(Linkman.class);// 设置排序criteria.addOrder(Order.desc(\"lkm_id\"));// 设置查询条件// Restrictions 提供静态的方法，拼接查询的条件criteria.add(Restrictions.or(Restrictions.eq(\"lkm_gender\", \"男\"), Restrictions.gt(\"lkm_id\", 3L)));List&lt;Linkman&gt; list = criteria.list();for (Linkman linkman : list) &#123; System.out.println(linkman);&#125;tr.commit(); 聚合函数查询Projection 的聚合函数的接口，而 Projections 是 Hibernate 提供的工具类，使用该工具类设置聚合函数查询。 使用 QBC 的聚合函数查询，需要使用 criteria.setProjection() 方法 具体的代码如下： 12345678Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();Criteria criteria = session.createCriteria(Linkman.class);criteria.setProjection(Projections.rowCount());List&lt;Number&gt; list = criteria.list();Long count = list.get(0).longValue();System.out.println(count);tr.commit(); 离线条件查询脱离 session，可以不使用 session 来创建。而是在 web 层创建对象。 离线条件查询使用的是 DetachedCriteria 接口进行查询，离线条件查询对象在创建的时候，不需要使用 Session 对象，只是在查询的时候使用 Session 对象即可。 创建离线条件查询对象 1DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 具体的代码如下 123456789101112Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class);// 设置查询条件criteria.add(Restrictions.eq(\"lkm_gender\", \"男\"));// 查询数据List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list();for (Linkman linkman : list) &#123; System.out.println(linkman);&#125;tr.commit(); SQL 查询方式（了解）使用 Hibernate 框架一般不会使用 SQL 查询。 基本语法： 12345678910Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();SQLQuery sqlQuery = session.createSQLQuery(\"select * from cst_linkman where lkm_gender = ?\");sqlQuery.setParameter(0,\"男\");// 通过方法设置，封装数据sqlQuery.addEntity(Linkman.class);List&lt;Linkman&gt; list = sqlQuery.list();System.out.println(list);tr.commit(); 查询功能优化 没有好与坏之分，只有适合不适合，可根据需求自行优化。但一般都会使用默认的，除非有特殊需求。 延迟加载延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送 SQL 语句，是 Hibernate 框架提升性能的方式。 类级别的延迟加载 Session 对象的 get 方法是没有延迟加载； Session 对象的 load 方法默认就是 延迟加载； Customer c1 = session.load(Customer.class, 1L); 没有发送 SQL 语句，当使用该对象的属性时，才发送 SQL 语句。 使类级别的延迟加载失效： 在 &lt;class&gt; 标签上配置 lazy=&quot;false&quot; 或者： Hibernate.initialize(Object proxy); 把对象先初始化一下。 1Hibernate.initialize(c1); 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是否是延迟加载） 默认是延迟加载 123456Session session = HibernateUtils.getCurrentSession();Transaction tr = session.beginTransaction();Customer c = session.get(Customer.class, 1L);System.out.println(\"=============\");System.out.println(c.getLinkmans().size()); // 当查询客户下的联系人的时候才发送语句进行查询tr.commit(); 关联级别延迟加载的策略查询策略：使用 Hibernate 查询一个对象的时候，查询其关联对象，应该如何查询，是 Hibernate 的一种优化手段！！ Hibernate 框架的检索策略解决的问题 查询的时机12Customer c1 = (Customer) session.get(Customer.class, 1);System.out.println(c1.getLinkmans().size()); lazy 属性解决查询的时机的问题，需要配置 是否采用延迟加载！！ 查询的语句格式1234List&lt;Customer&gt; list = session.createQuery(\"from Customer\").list();for(Customer c : list)&#123; System.out.println(c.getLinkmans());&#125; fetch 属性就可以解决 查询语句的格式 的问题！！ set 标签配置策略在 &lt;set&gt; 标签上使用 fetch 和 lazy 属性： fetch 的取值 – 控制 SQL 语句生成的格式 select – 默认值。发送查询语句 join – 连接查询。发送的是一条迫切左外连接！配置了 join，lazy 就失效了 subselect – 子查询。发送一条子查询查询其关联对象。（需要使用 list() 方法进行测试） lazy 的取值 – 查找关联对象的时候是否采用延迟! true – 默认。延迟 false – 不延迟 extra – 及其懒惰 set 标签上的默认值是 fetch=&quot;select&quot; 和 lazy=&quot;true&quot; 总结：Hibernate 框架都采用了默认值，开发中基本上使用的都是默认值。特殊情况再进行设置。 many-to-one 标签配置策略在 &lt;many-to-one&gt; 标签上使用 fetch 和 lazy 属性 fetch的取值 – 控制SQL的格式. select – 默认。发送基本select语句查询 join – 发送迫切左外连接查询 lazy的取值 – 控制加载关联对象是否采用延迟 false – 不采用延迟加载。 proxy – 默认值。代理。现在是否采用延迟 由另一端的 &lt;class&gt; 上的 lazy 确定.如果这端的 class 上的 lazy=&quot;true&quot;。proxy 的值就是 true(延迟加载)。 如果 class 上 lazy=&quot;false&quot; ，proxy 的值就是 false(不采用延迟) 在 &lt;many-to-one&gt; 标签上的默认值是 fetch=&quot;select&quot; 和 proxy","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"JavaWeb 之 Hibernate 关联关系映射","slug":"JavaWeb-Hibernate04","date":"2018-06-01T10:45:37.000Z","updated":"2018-08-10T06:41:12.377Z","comments":true,"path":"JavaWeb-Hibernate04.html","link":"","permalink":"http://yoursite.com/JavaWeb-Hibernate04.html","excerpt":"Hibernate 关联关系映射","text":"Hibernate 关联关系映射 Hibernate 一对多映射以 客户关系管理系统（CRM） 为例： Java WEB中一对多的设计及其建表原则多方表建一个字段作为外键，指向一方表的主键。 先导入SQL的建表语句 创建数据库：create database hibernate_03; 执行 SQL 语句进行建表： 客户表： 12345678910111213CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_user_id` bigint(32) DEFAULT NULL COMMENT '负责人id', `cust_create_id` bigint(32) DEFAULT NULL COMMENT '创建人id', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_linkman` varchar(64) DEFAULT NULL COMMENT '联系人', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 联系人表： 123456789101112131415CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) NOT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 编写客户和联系人的 JavaBean 程序（注意一对多的编写规则） 一方 Set 集合，必须自己初始化；多方编写一个对象，不要自己 new ！ 客户的 JavaBean 如下： 1234567891011121314public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;();&#125; 联系人的 JavaBean 如下： 12345678910111213public class Linkman &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer;&#125; 编写客户和联系人的映射配置文件注意一对多的配置编写： 多方： 1&lt;many-to-one name=\"customer\" class=\"com.renkaigis.domain.Customer\" column=\"lkm_cust_id\"/&gt; 其中： name：当前 JavaBean 中的属性class：属性的全路径column：外键的字段 一方： 1234567&lt;!--配置一方--&gt;&lt;set name=\"linkmans\"&gt; &lt;!--需要出现两个子标签--&gt; &lt;!--外键的字段--&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.renkaigis.domain.Linkman\"/&gt;&lt;/set&gt; 客户的映射配置文件12345678910111213141516171819&lt;class name=\"com.renkaigis.domain.Customer\" table=\"cst_customer\"&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"cust_name\" column=\"cust_name\"/&gt; &lt;property name=\"cust_user_id\" column=\"cust_user_id\"/&gt; &lt;property name=\"cust_create_id\" column=\"cust_create_id\"/&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;set name=\"linkmans\"&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.renkaigis.domain.Linkman\"/&gt; &lt;/set&gt;&lt;/class&gt; 联系人的映射配置文件123456789101112131415&lt;class name=\"com.renkaigis.domain.Linkman\" table=\"cst_linkman\"&gt; &lt;id name=\"lkm_id\" column=\"lkm_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"lkm_name\" column=\"lkm_name\"/&gt; &lt;property name=\"lkm_gender\" column=\"lkm_gender\"/&gt; &lt;property name=\"lkm_phone\" column=\"lkm_phone\"/&gt; &lt;property name=\"lkm_mobile\" column=\"lkm_mobile\"/&gt; &lt;property name=\"lkm_email\" column=\"lkm_email\"/&gt; &lt;property name=\"lkm_qq\" column=\"lkm_qq\"/&gt; &lt;property name=\"lkm_position\" column=\"lkm_position\"/&gt; &lt;property name=\"lkm_memo\" column=\"lkm_memo\"/&gt; &lt;many-to-one name=\"customer\" class=\"com.renkaigis.domain.Customer\" column=\"lkm_cust_id\"/&gt;&lt;/class&gt; 保存客户和联系人的数据双向关联数据保存（麻烦）1234567891011121314151617181920212223242526272829/** * 测试双向关联 */@Testpublic void run1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c1 = new Customer(); c1.setCust_name(\"小虞\"); Linkman l1 = new Linkman(); l1.setLkm_name(\"小项\"); Linkman l2 = new Linkman(); l2.setLkm_name(\"小羽\"); // 双向关联 c1.getLinkmans().add(l1); c1.getLinkmans().add(l2); l1.setCustome1r(c1); l2.setCustomer(c1); // 保存 session.save(c1); session.save(l1); session.save(l2); tr.commit();&#125; 级联保存测试：如果现在代码只插入其中的一方的数据 如果只保存其中的一方的数据，那么程序会抛出异常。 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ 级联保存是方向性 级联保存效果 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ 使用 cascade=&quot;save-update&quot; 注意：级联保存有方向性 12345&lt;!--客户级联联系人--&gt;&lt;set name=\"linkmans\" cascade=\"save-update\"&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.renkaigis.domain.Linkman\"/&gt;&lt;/set&gt; 测试代码： 123456789101112131415161718192021222324/** * 测试级联关联 */@Testpublic void run2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c1 = new Customer(); c1.setCust_name(\"小虞\"); Linkman l1 = new Linkman(); l1.setLkm_name(\"小项\"); Linkman l2 = new Linkman(); l2.setLkm_name(\"小羽\"); // 双向关联 c1.getLinkmans().add(l1); c1.getLinkmans().add(l2); // 保存客户级联保存联系人 session.save(c1); tr.commit();&#125; 相反的，要使用联系人去关联客户，那么需要在联系人的映射里面配置 cascade=&quot;save_update&quot;，这是只要保存了联系人，与其对应的客户也会保存或更新。 级联删除 1.数据库中删除含有外键的客户时，SQL 语句会报出错误的：delete from customers where cid = 1; 2.如果使用 Hibernate 框架直接删除客户的时候，测试发现是可以删除的； Hibernate 框架删除有外键的信息是，会将外键先查出来置为 null，然后执行删除操作； 3.上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的！！（轻易不要使用） 1&lt;many-to-one cascade=\"delete\" /&gt; 级联的取值（cascade的取值） none – 不使用级联 save-update – 级联保存或更新 delete – 级联删除 delete-orphan – 孤儿删除(注意：只能应用在一对多关系) all – 除了 delete-orphan 的所有情况（包含save-update delete） all-delete-orphan – 包含了 delete-orphan 的所有情况（包含save-update delete delete-orphan） 孤儿删除（孤子删除）只有在一对多的环境下才有孤儿删除 在一对多的关系中，可以将一的一方认为是父方。将多的一方认为是子方。孤儿删除：在解除了父子关系的时候，将子方记录就直接删除。 1&lt;many-to-one cascade=\"delete-orphan\" /&gt; 12345678910111213141516/** * 测试孤儿删除 */@Testpublic void run3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c1 = session.get(Customer.class, 1L); Linkman l1 = session.get(Linkman.class, 1L); // 解除关系 c1.getLinkmans().remove(l1); tr.commit();&#125; 放弃外键的维护双方都维护外键的时候，会产生多余的 SQL 语句 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的 SQL 语句。 产生的原因：session 的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的 SQL 语句。 放弃外键维护如果不想产生多余的 SQL 语句，那么需要一方来放弃外键的维护！ 只有 一方 可以放弃，多方 没有哪个属性 在 &lt;set&gt; 标签上配置一个 inverse=&quot;true&quot;，true：放弃，false：不放弃，默认值是false 12345&lt;!-- 放弃外键的维护 --&gt;&lt;set name=\"linkmans\" inverse=\"true\"&gt; &lt;key column=\"lkm_cust_id\"/&gt; &lt;one-to-many class=\"com.renkaigis.domain.Linkman\"/&gt;&lt;/set&gt; cascade 和 inverse 的区别 cascade 用来级联操作（保存、修改和删除）; inverse 用来维护外键的。 一般情况下，在 一方 配置 inverse 放弃外键维护，在 多方 配置 cascade 来进行级联保存操作。 Hibernate 多对多映射 多对多的建表原则 需要创建一个中间表，至少需要包含两个字段，作为这个表外键，分别指向两张表的主键。 两个外键一起叫联合主键。 使用 Hibernate 框架，只要编写两个 JavaBean，编写两个映射的配置文件，中间表会自动生成。 多对多 JavaBean 的编写以用户和角色为例，一个用户可以有多个角色，一个角色可以被多个用户扮演。 编写用户和角色的 JavaBean多对多都要用 Set 集合： 用户的 JavaBean 代码如下 12345678910public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); // 省略 get / set&#125; 角色的 JavaBean 代码如下 12345678public class Role &#123; private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); // 省略 get / set&#125; 用户和角色的映射配置 用户的映射配置文件如下 1234567891011121314151617181920212223&lt;class name=\"com.renkaigis.domain.User\" table=\"sys_user\"&gt; &lt;id name=\"user_id\" column=\"user_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"user_code\" column=\"user_code\"/&gt; &lt;property name=\"user_name\" column=\"user_name\"/&gt; &lt;property name=\"user_password\" column=\"user_password\"/&gt; &lt;property name=\"user_state\" column=\"user_state\"/&gt; &lt;!-- 配置多对多 name 集合的名称 table 中间表的名称 --&gt; &lt;set name=\"roles\" table=\"sys_user_role\"&gt; &lt;!-- 当前对象在中间表的外键名称 --&gt; &lt;key column=\"user_id\"/&gt; &lt;!-- class 集合中存入对象，对象的全路径 column 集合中对象在中间表的外键的名称 --&gt; &lt;many-to-many class=\"com.renkaigis.domain.Role\" column=\"role_id\"/&gt; &lt;/set&gt;&lt;/class&gt; 角色的映射配置文件如下 123456789101112&lt;class name=\"com.renkaigis.domain.Role\" table=\"sys_role\"&gt; &lt;id name=\"role_id\" column=\"role_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"role_name\" column=\"role_name\"/&gt; &lt;property name=\"role_memo\" column=\"role_memo\"/&gt; &lt;set name=\"users\" table=\"sys_user_role\"&gt; &lt;key column=\"role_id\"/&gt; &lt;many-to-many class=\"com.renkaigis.domain.User\" column=\"user_id\"/&gt; &lt;/set&gt;&lt;/class&gt; 关联多对多进行双向关联的时候：必须有一方去放弃外键维护权。 否则会发生异常！ 级联保存级联保存1&lt;set cascade=\"save-update\"&gt; 级联删除（在多对多中是很少使用的） 开发中不用！ 1&lt;set cascade=\"delete\"/&gt; 操作中间表操作集合，就是操作中间表。 12345678910111213/** * 假设：张三用户，有2个角色，演员和导演，让张三没有演员这个角色 */public void run()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); // 获取用户和角色 User u1 = session.get(User.class, 1L); Role r2 = session.get(Role.class, 2L); // 移除用户的某一个角色，那么中间表就会修改了 u1.getRoles().remove(r2); tr.commit();&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"JavaWeb 之 Hibernate 持久化类、缓存与事务","slug":"JavaWeb-Hibernate03","date":"2018-05-30T08:43:19.000Z","updated":"2018-08-10T06:41:33.801Z","comments":true,"path":"JavaWeb-Hibernate03.html","link":"","permalink":"http://yoursite.com/JavaWeb-Hibernate03.html","excerpt":"Hibernate 持久化类、缓存与事务。","text":"Hibernate 持久化类、缓存与事务。 Hibernate 的持久化类 什么是持久化类持久化类：就是一个 Java 类（自己编写的 JavaBean），这个 Java 类与表建立了映射关系就可以称为是持久化类。 持久化类 = JavaBean + xxx.hbm.xml 持久化类的编写规则 提供一个无参数 public 访问控制符的构造器 – 底层需要进行反射。 提供一个标识属性，映射数据表主键字段 – 唯一标识 OID。数据库中通过主键，Java 对象通过地址确定对象，持久化类通过唯一标识 OID 确定记录。 所有属性提供 public 访问控制符的 set 或者 get 方法 标识属性应尽量使用基本数据类型的包装类型 区分自然主键和代理主键创建表的时候 自然主键：对象本身的一个属性。创建一个人员表，每个人都有一个身份证号（唯一的）。使用身份证号作为表的主键，自然主键。（开发中不会使用这种方式） 代理主键：不是对象本身的一个属性。创建一个人员表，为每个人员单独创建一个字段。用这个字段作为主键，代理主键。（开发中推荐使用这种方式） 创建表的时候尽量使用代理主键创建表 主键的生成策略12345678910&lt;hibernate-mapping&gt; &lt;class name=\"com.renkaigis.domain.User\" table=\"t_user\"&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;!--主键的生成策略--&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" length=\"30\"/&gt; &lt;property name=\"age\" column=\"age\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 重要的是 uuid 和 native increment适用于 short，int，long 作为主键。不是使用的数据库自动增长机制。 Hibernate中提供的一种增长机制。 先进行查询：select max(id) from user; 再进行插入：获得 最大值 + 1作为新的记录的主键。 SQL 代码如下： 123456789101112Hibernate: select max(id) from t_userHibernate: insert into t_user (name, age, id) values (?, ?, ?) 问题： 不能在集群环境下或者有并发访问的情况下使用。 identity适用于 short，int，long 作为主键。但是这个必须使用在有自动增长数据库中，采用的是数据库底层的自动增长机制。 底层使用的是数据库的自动增长（auto_increment）。像 Oracle 数据库没有自动增长。 sequence适用于 short，int，long 作为主键。底层使用的是序列的增长方式。 Oracle 数据库底层没有自动增长，想自动增长需要使用序列。 uuid ★适用于 char，varchar 类型的作为主键。 使用随机的字符串作为主键。 12345678910111213141516171819/** * 测试 uuid 生成主键策略 * Person 类有两个属性 String pname 和 String pid * Person.hbm.xml 如下编写： * &lt;id name=\"pid\" column=\"pid\"&gt; &lt;generator class=\"uuid\"/&gt; &lt;/id&gt; */@Testpublic void runUUID() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); Person p = new Person(); p.setPname(\"老王\"); session.save(p); tr.commit(); session.close();&#125; 查看生成的 uuid 主键： 1234567mysql&gt; select * from t_person;+----------------------------------+--------+| pid | pname |+----------------------------------+--------+| ff80808163ab33ae0163ab33b2370000 | 老王 |+----------------------------------+--------+1 row in set (0.00 sec) native ★本地策略。根据底层的数据库不同，自动选择适用于该种数据库的生成策略。（short，int，long） 如果底层使用 MySQL 数据库：相当于 identity 如果底层使用 Oracle 数据库：相当于 sequence assigned主键的生成不用 Hibernate 管理了。必须手动设置主键。 1p.setPid(\"abc\"); Hibernate 持久化对象的状态 持久化对象的状态Hibernate 为了管理持久化类：将持久化类分成了三个状态 瞬时态：Transient Object 没有持久化标识 OID，没有被纳入到 Session 对象的管理。 持久态：Persistent Object 有持久化标识 OID，已经被纳入到 Session 对象的管理。 脱管态：Detached Object 有持久化标识 OID，没有被纳入到 Session 对象的管理。 1234567891011121314151617181920212223242526/** * 持久化对象的状态 */@Testpublic void run3() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // 瞬时态：没有 OID 的值，也没有被 session 管理，此时 user 对象是瞬时态对象 User user=new User(); user.setName(\"空空\"); user.setAge(18); // 此时 user 中已经有 id 值了，默认的情况下，把 user 对象也保存到 session 的缓存中 session.save(user); System.out.println(user.getId()); // 此时，user 是持久化对象 tr.commit(); // session 销毁，缓存没有了 session.close(); // 此时 user 对象存在 id 值，但是 session 销毁了，缓存不存在了，session 不管理 user 对象了 // user 是托管态对象 System.out.println(user.getId()); System.out.println(user.getName());&#125; 控制台输出的结果： 123456789101112131415Hibernate: select max(id) from t_user2 // 此时的 user 有 id 值，并且被 session 管理，证明 user 是持久态对象Hibernate: insert into t_user (name, age, id) values (?, ?, ?)2 // 此时 session 已经销毁，但是 user 还有 id 值，证明 user 是托管态对象空空 Hibernate 持久化对象状态的转换瞬时态 获得瞬时态的对象 1User user = new User() 瞬时态对象转换持久态 123save();或者saveOrUpdate(); 瞬时态对象转换成脱管态 1user.setId(1) 持久态 获得持久态的对象 123get();或者load(); 持久态转换成瞬时态对象 1delete(); // 比较有争议的，进入特殊的状态（删除态：Hibernate 中不建议使用的） 持久态对象转成脱管态对象 1session.close()/evict()/clear(); 脱管态 获得托管态对象:不建议直接获得脱管态的对象. 12User user = new User();user.setId(1); 脱管态对象转换成持久态对象 123update();或者saveOrUpdate();或者lock(); 脱管态对象转换成瞬时态对象 1user.setId(null); 注意： 持久态对象有自动更新数据库的能力！！ 持久态对象自动更新数据库： 123456789101112131415161718/** * 持久态对象自动更新数据库 */@Testpublic void run4() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // user 是持久态对象，有自动更新数据库的能力 User user = session.get(User.class, 1); // 重新设置名称 user.setName(\"天才\"); // session.update(user); tr.commit(); session.close();&#125; 上面代码注释掉了 session.update(user); 方法，但是数据库依旧更新了，SQL 语句也正常执行了。 控制台输出结果（没调用 update，但是执行了 update 语句。原因是因为一级缓存的存在。）： 1234567891011121314151617Hibernate: select user0_.id as id1_1_0_, user0_.name as name2_1_0_, user0_.age as age3_1_0_ from t_user user0_ where user0_.id=?Hibernate: update t_user set name=?, age=? where id=? Hibernate 的一级缓存 Session 对象的一级缓存（重点）什么是缓存？其实就是一块内存空间，将数据源（数据库或者文件）中的数据存放到缓存中。再次获取的时候，直接从缓存中获取。可以提升程序的性能！ Hibernate 框架提供了两种缓存一级缓存 自带的不可卸载的。一级缓存的生命周期与 session 一致。一级缓存称为 session 级别的缓存。 二级缓存（有更好的替代品） 默认没有开启，需要手动配置才可以使用的。二级缓存可以在多个 session 中共享数据，二级缓存称为是 sessionFactory 级别的缓存。 Session 对象的缓存概述 Session 接口中，有一系列的 java 的集合，这些 java 集合构成了 Session 级别的缓存（一级缓存），将对象存入到一级缓存中，session 没有结束生命周期，那么对象在 session 中存放着 内存中包含 Session 实例 –&gt; Session 的缓存（一些集合） –&gt; 集合中包含的是缓存对象！ 证明一级缓存的存在，编写查询的代码即可证明 在同一个 Session 对象中两次查询，可以证明使用了缓存。 1234567891011121314151617181920212223/** * 证明一级缓存的存在 */@Testpublic void run5() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); User user = new User(); user.setName(\"天行健\"); // 保存用户，user 已经存入到 session 的缓存中 // id 是生成的 id Serializable id = session.save(user); System.out.println(id); // 获取对象，不会看到 SQL 语句 User user2 = session.get(User.class, id); System.out.println(user2.getName()); tr.commit(); session.close();&#125; 控制台输出结果： 123456789Hibernate: insert into t_user (name, age) values (?, ?)4天行健 分析： 获取对象的时候没有查询的 SQL 语句执行，说明 session 是从缓存中获取对象的。证明 session 一级缓存的存在。 Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ 使用 get 方法查询 User 对象 然后设置 User 对象的一个属性，注意：没有做 update 操作。发现，数据库中的记录也改变了。 利用快照机制来完成的（SnapShot） 控制Session的一级缓存（了解）123Session.clear(); // 清空缓存。Session.evict(Object entity); // 从一级缓存中清除指定的实体对象。Session.flush(); // 刷出缓存 Hibernate中的事务与并发 事务相关的概念**什么是事务 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. 转账的例子：扣钱，加钱。两个操作组成了一个事情！ 事务的特性 原子性 – 事务不可分割。 一致性 – 事务执行的前后数据的完整性保持一致。 隔离性 – 一个事务执行的过程中，不应该受到其他的事务的干扰。 持久性 – 事务一旦提交，数据就永久保持到数据库中。 如果不考虑隔离性：引发一些读的问题 脏读 – 一个事务读到了另一个事务未提交的数据。 不可重复读 – 一个事务读到了另一个事务已经提交的 update 数据，导致多次查询结果不一致。 虚读 – 一个事务读到了另一个事务已经提交的 insert 数据，导致多次查询结构不一致。 设置隔离级别通过设置数据库的隔离级别来解决上述读的问题 未提交读：以上的读的问题都有可能发生。 已提交读：避免脏读，但是不可重复读，虚读都有可能发生。 可重复读：避免脏读，不可重复读。但是虚读是有可能发生。 串行化：以上读的情况都可以避免。 如果想在 Hibernate 的框架中来设置隔离级别，需要在 hibernate.cfg.xml 的配置文件中通过标签来配置（默认隔离级别是 4）： 1&lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; 通过：hibernate.connection.isolation = 4 来配置，取值如下： 1 — Read uncommitted isolation 2 — Read committed isolation 4 — Repeatable read isolation 8 — Serializable isolation 丢失更新的问题如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 A事务和B事务同时获取到一条数据，同时再做修改 如果A事务修改完成后，提交了事务 B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 丢失更新问题演示更新前的数据库： 12345678mysql&gt; select * from t_user;+----+-----------+------+| id | name | age |+----+-----------+------+| 1 | 天才 | 18 || 2 | 空空 | 18 |+----+-----------+------+4 rows in set (0.01 sec) 假设 runA 方法和 runB() 方法同时对 t_user 表进行修改，同时查询到 id = 1 的用户（需加断点），对其进行修改。 12345678910111213141516171819202122232425262728293031/** * 丢失更新1 */@Testpublic void runA() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); User user = session.get(User.class, 1); // 修改 id = 1 的用户名为白蛇 user.setName(\"白蛇\"); tr.commit(); session.close();&#125;/** * 丢失更新2 */@Testpublic void runB() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); User user = session.get(User.class, 1); // 修改 id = 1 的用户年龄为 88 user.setAge(88); tr.commit(); session.close();&#125; 分析：假设 runA 方法先提交，那么数据库中的数据为： 12345678mysql&gt; select * from t_user;+----+-----------+------+| id | name | age |+----+-----------+------+| 1 | 白蛇 | 18 || 2 | 空空 | 18 |+----+-----------+------+4 rows in set (0.01 sec) 分析：runA 提交之后，runB 提交，则此时数据库中数据为： 12345678mysql&gt; select * from t_user;+----+-----------+------+| id | name | age |+----+-----------+------+| 1 | 天才 | 88 || 2 | 空空 | 18 |+----+-----------+------+4 rows in set (0.01 sec) 分析：最后数据库中的数据只是 runB 修改的结果，而 runA 修改的结果“丢失了”，这就是丢失更新的问题。 丢失更新解决方案乐观锁乐观锁采用 版本号 的机制来解决的。会给表结构添加一个字段 version = 0 ，默认值是 0 当 A 事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号 version = 1 。 当 B 事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 悲观锁悲观锁采用的是数据库提供的一种锁机制，如果采用做了这种机制，在 SQL 语句的后面添加 for update 子句 当 A 事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 只有当 A 事务提交后，锁释放了，其他事务才能操作该条记录 使用 Hibernate 框架解决丢失更新的问题悲观锁 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 乐观锁 在对应的 JavaBean 中添加一个属性，名称可以是任意的。例如：private Integer version; 并提供 get 和 set 方法。 在映射的配置文件中，提供 &lt;version name=&quot;version&quot;/&gt; 标签即可。 注意 version 标签的编写位置。 1234567891011&lt;class name=\"com.renkaigis.domain.User\" table=\"t_user\"&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!--乐观锁，使用 version 标签--&gt; &lt;version name=\"version\"/&gt; &lt;property name=\"name\" column=\"name\" length=\"30\"/&gt; &lt;property name=\"age\" column=\"age\"/&gt;&lt;/class&gt; 绑定本地的SessionHibernate 框架中，使用 session 对象开启事务，所以需要来传递 session 对象，框架提供了 ThreadLocal 的方式 需要在 hibernate.cfg.xml 的配置文件中提供配置 12&lt;!--开启绑定本地的 session--&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; 重新编写 HibernateUtils 的工具类，使用 SessionFactory 的 getCurrentSession() 方法，获取当前的 Session 对象。并且该 Session 对象不用手动关闭，线程结束了，会自动关闭。 12345// 业务层开事务public static Session getCurrentSession() &#123; // 从 ThreadLocal 类中获取到 session 对象 return FACTORY.getCurrentSession();&#125; 注意： 想使用 getCurrentSession() 方法，必须要先配置才能使用。 演示绑定本地 sessionweb层浏览器端发送请求，同时新增两个用户。 123456789101112public class SaveServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User u1 = new User(); u1.setName(\"测试1\"); User u2 = new User(); u2.setName(\"测试2\"); new UserService().save(u1, u2); &#125;&#125; 业务层业务层获取当前线程的 session，开启事务，调用 dao 保存用户，若发生异常则回滚。 线程结束后 session 自动关闭。 1234567891011121314151617181920public class UserService &#123; public void save(User u1, User u2) &#123; UserDao dao = new UserDao(); Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); try &#123; dao.save1(u1); // int a = 10 / 0; dao.save2(u2); tr.commit(); &#125; catch (Exception e) &#123; // 出现问题，回滚事务 tr.rollback(); &#125; finally &#123; // session.close(); // 以前需要自己释放资源 // 现在 session 不用关闭，线程结束后 session 自动关闭。 &#125; &#125;&#125; 持久层获取当前 session，与业务层 session 保持一致，进行保存操作。 1234567891011public class UserDao &#123; public void save1(User u1) &#123; Session session = HibernateUtils.getCurrentSession(); session.save(u1); &#125; public void save2(User u2) &#123; Session session = HibernateUtils.getCurrentSession(); session.save(u2); &#125;&#125; 访问 Servlet，数据添加完成。 12345678910mysql&gt; select * from t_user;+----+---------+------+---------+| id | name | age | version |+----+---------+------+---------+| 1 | 天才 | 88 | 1 || 2 | 空空 | 18 | 0 || 7 | 测试1 | NULL | 0 || 8 | 测试2 | NULL | 0 |+----+---------+------+---------+4 rows in set (0.00 sec)","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"JavaWeb 之 Hibernate 配置及接口","slug":"JavaWeb-Hibernate02","date":"2018-05-30T08:33:19.000Z","updated":"2018-08-10T06:41:30.064Z","comments":true,"path":"JavaWeb-Hibernate02.html","link":"","permalink":"http://yoursite.com/JavaWeb-Hibernate02.html","excerpt":"Hibernate 配置文件与接口方法。","text":"Hibernate 配置文件与接口方法。 映射配置文件 映射文件，即类与表的映射配置文件，假设是 Customer.hbm.xml &lt;class&gt;标签 &lt;class&gt; 标签 用来将类与数据库表建立映射关系 name 类的全路径 table 表名.(类名与表名一致,那么table属性也可以省略) catalog 数据库的名称，基本上都会省略不写 &lt;id&gt;标签 &lt;id&gt; 标签 用来将类中的属性与表中的主键建立映射，id 标签就是用来配置主键的 name 类中属性名 column 表中的字段名。（如果类中的属性名与表中的字段名一致,那么 column 可以省略。） length 字段的程度，如果数据库已经创建好了，那么 length 可以不写。如果没有创建好，生成表结构时，length 最好指定。 &lt;property&gt;标签 &lt;property&gt; 标签 用来将类中的普通属性与表中的字段建立映射 name 类中属性名 column 表中的字段名（如果类中的属性名与表中的字段名一致,那么column可以省略。） length 数据长度 type 数据类型（一般都不需要编写，如果写需要按着规则来编写）Hibernate 的数据类型 type=”string”Java 的数据类型 type=”java.lang.String” 数据库字段的数据类型 &lt;column name=”name” sql-type=”varchar”/&gt; 注： 配置不需要那么麻烦，一般默认的就可以了。 核心配置文件 核心配置文件的两种方式属性文件第一种方式是属性文件的形式，即 properties 的配置文件 hibernate.properties 里面的编写规则如下：（key=value） 1hibernate.connection.driver_class=com.mysql.jdbc.Driver 缺点：不能加载映射的配置文件，需要手动编写代码去加载 xml 文件（★）第二种方式是 XML 文件的形式，开发基本都会选择这种方式（★） hibernate.cfg.xml 1&lt;property name=\"hibernate.connection.driver_class\" &gt;com.mysql.jdbc.Driver&lt;/property&gt; 优点 格式比较清晰 编写有提示 可以在该配置文件中加载映射的配置文件（最主要的） hibernate.cfg.xml 的配置文件详解必须有的配置 数据库连接信息: 1234hibernate.connection.driver_class -- 连接数据库驱动程序hibernate.connection.url -- 连接数据库 URLhibernate.connection.username -- 数据库用户名hibernate.connection.password -- 数据库密码 方言: 1hibernate.dialect -- 操作数据库方言 可选的配置12345678* hibernate.show_sql -- 显示 SQL，控制台输出 SQL 语句* hibernate.format_sql -- 格式化控制台输出的 SQL 语句* hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表。 ---测试的时候使用 * create-drop -- 每次都会创建一个新的表，当执行结束之后，将创建的这个表删除。 ---测试的时候使用 * update★ -- 如果有表，使用原来的表。没有表，创建一个新的表。同时更新表结构。 * validate -- 如果有表，使用原来的表。同时校验映射文件与表中字段是否一致如果不一致就会报错。 加载映射 如果是 XML 方式： 1&lt;mapping resource=\"com/renkaigis/domain/Customer.hbm.xml\"/&gt; 单表最基本的 Hibernate 配置文件hibernate.cfg.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!--记住：先配置 SessionFactory 标签，一个数据库对应一个 SessionFactory 标签--&gt; &lt;session-factory&gt; &lt;!--必须配置的参数有 5 个，4 大参数和数据库的方言--&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_01&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!--数据库的方言--&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--可选配置--&gt; &lt;!--控制台显示 SQL 语句--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!--格式化显示的 SQL 语句--&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!--生成数据库表结构--&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--映射配置文件，需要引入映射的配置文件--&gt; &lt;mapping resource=\"com/renkaigis/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Hibernate 常用的接口和类 Configuration 类和作用Configuration类 Configuration 对象用于配置并且启动 Hibernate。 Hibernate 应用通过该对象来获得 对象-关系映射 文件中的元数据，以及动态配置 Hibernate 的属性，然后创建 SessionFactory 对象。 简而言之：加载 Hibernate 的配置文件，可以获取 SessionFactory 对象。 Configuration类的其他应用（了解）加载配置文件的种类，Hibernate 支持 xml 和 properties 类型的配置文件，在开发中基本都使用 XML 配置文件的方式。 如果采用的是 properties 的配置文件，那么通过下面语句可以加载配置文件 1Configuration configuration = new Configuration(); 但是需要自己手动加载映射文件 例如： 1config.addResource(\"cn/itcast/domain/Student.hbm.xml\"); 如果采用的 XML 的配置文件，通过下面语句可直接加载配置文件和映射文件。 1Configuration configuration = new Configuration().configure(); SessionFactory 类 ★SessionFactory 是工厂类，负责初始化 Hibernate，充当数据存储源，并负责创建 Session 对象。 SessionFactory 类的特点 由Configuration 通过加载配置文件创建该对象。 SessionFactory 对象中保存了当前的数据库配置信息和所有映射关系以及预定义的 SQL 语句。同时，SessionFactory 还负责维护 Hibernate 的二级缓存。 预定义 SQL 语句 使用 Configuration 类创建了 SessionFactory 对象时，已经在 SessionFacotry 对象中缓存了一些 SQL 语句； 常见的SQL语句是增删改查（通过主键来查询）； 这样做的目的是效率更高。 一个 SessionFactory 实例对应一个数据库，应用从该对象中获得 Session 实例。 SessionFactory 是 线程安全 的，意味着它的一个实例可以被应用的多个线程共享。 SessionFactory 是 重量级 的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个 SessionFactory 实例，且在应用初始化的时候完成。 SessionFactory 需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为 Hibernate 的二级缓存，被多线程所共享。 总之，一般应用使用一个 SessionFactory，最好是应用启动时就完成初始化。 编写 HibernateUtils 的工具类简化获取 Session 的方法，在服务器启动时就完成了初始化，加载了配置文件和映射文件。 123456789101112131415public class HibernateUtils &#123; private static final Configuration cfg; private static final SessionFactory factory; static&#123; // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); &#125; // 获取Session对象 public static Session openSession()&#123; return factory.openSession(); &#125;&#125; 测试： 123456789101112131415/** * 测试工具类 */@Testpublic void testSave2() &#123; // 通过工具类获取 session 对象 Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); Customer c=new Customer(); c.setCust_name(\"小明\"); session.save(c); tr.commit(); session.close();&#125; Session 接口概述 Session 是在 Hibernate 中使用最频繁的接口。也被称之为 持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象； Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心； Session 是线程不安全的； 所有持久化对象必须在 session 的管理下才可以进行持久化操作； Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处； 持久化类与 Session 关联起来后就具有了持久化的能力。 特点 不是线程安全 的。应避免多个线程使用同一个 Session 实例； Session 是 轻量级 的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的 Session 实例； Session 有一个缓存，被称之为 Hibernate 的一级缓存。每个 Session 实例都有自己的缓存。 常用的方法 save(obj) delete(obj) get(Class,id) update(obj) saveOrUpdate(obj) – 保存或者修改（如果没有数据，保存数据。如果有，修改数据） createQuery() – HQL语句的查询的方式 get(Class,id)12345678910111213141516/** * 测试 get() 方法，获取查询，通过主键来查询一条记录 */@Testpublic void testGet() &#123; // 通过工具类获取 session 对象 Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // 两个参数：JavaBean 的 class 对象，主键的值 Customer c = session.get(Customer.class, 94L); System.out.println(c); tr.commit(); session.close();&#125; 输出结果： 1Customer&#123;cust_id=94, cust_name=&apos;测试&apos;, cust_user_id=null, cust_create_id=null, cust_source=&apos;null&apos;, cust_industry=&apos;null&apos;, cust_level=&apos;2&apos;, cust_linkman=&apos;null&apos;, cust_phone=&apos;110&apos;, cust_mobile=&apos;null&apos;&#125; delete(obj)1234567891011121314151617/** * 测试 delete() 方法 * 注意：删除或者修改，都要先查询在删除或者修改 */@Testpublic void testDel() &#123; // 通过工具类获取 session 对象 Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 94L); // 删除客户 session.delete(c); tr.commit(); session.close();&#125; 输出 SQL 语句： 12345678910111213141516171819202122Hibernate: select customer0_.cust_id as cust_id1_0_0_, customer0_.cust_name as cust_nam2_0_0_, customer0_.cust_user_id as cust_use3_0_0_, customer0_.cust_create_id as cust_cre4_0_0_, customer0_.cust_source as cust_sou5_0_0_, customer0_.cust_industry as cust_ind6_0_0_, customer0_.cust_level as cust_lev7_0_0_, customer0_.cust_linkman as cust_lin8_0_0_, customer0_.cust_phone as cust_pho9_0_0_, customer0_.cust_mobile as cust_mo10_0_0_ from cst_customer customer0_ where customer0_.cust_id=?Hibernate: delete from cst_customer where cust_id=? update(obj)12345678910111213141516171819/** * 测试 update() 方法 */@Testpublic void testUpdate() &#123; // 通过工具类获取 session 对象 Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // 查询客户 Customer c = session.get(Customer.class, 1L); // 设置客户信息 c.setCust_level(\"中级\"); c.setCust_name(\"小徐\"); // 修改 session.update(c); tr.commit(); session.close();&#125; saveOrUpdate(obj)12345678910111213141516171819/** * 测试 SaveOrUpdate() 方法 */@Testpublic void testSaveOrUpdate() &#123; // 通过工具类获取 session 对象 Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // 查询客户 Customer c = session.get(Customer.class, 1L); // 设置客户信息 // c.setCust_id(7L); // 千万不能修改 id 值 c.setCust_name(\"小天\"); // 修改 session.saveOrUpdate(c); tr.commit(); session.close();&#125; createQuery()12345678910111213141516171819/** * 测试 creatQuery() 方法 */@Testpublic void testSel() &#123; Session session = HibernateUtils.getSession(); Transaction tr = session.beginTransaction(); // 创建查询的接口 Query query = session.createQuery(\"from Customer\"); // 查询所有的数据 select * from 表 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tr.commit(); session.close();&#125; Transaction 接口Transaction 是事务的接口。 常用的方法 commit() – 提交事务 rollback() – 回滚事务 特点 Hibernate 框架默认情况下事务不自动提交.需要手动提交事务 如果没有开启事务，那么每个 Session 的操作，都相当于一个独立的事务 测试事务12345678910111213141516171819202122232425/** * 测试事务 */@Testpublic void testSave3() &#123; Session session = null; Transaction tr = null; try &#123; session = HibernateUtils.getSession(); // 开启事务 tr = session.beginTransaction(); Customer c = new Customer(); // int a=10/0; c.setCust_name(\"嘿嘿\"); session.save(c); tr.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tr.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 session.close(); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"JavaWeb 之 Hibernate 快速入门","slug":"JavaWeb-Hibernate01","date":"2018-05-30T08:23:19.000Z","updated":"2018-08-10T06:41:25.530Z","comments":true,"path":"JavaWeb-Hibernate01.html","link":"","permalink":"http://yoursite.com/JavaWeb-Hibernate01.html","excerpt":"Hibernate 快速入门。","text":"Hibernate 快速入门。 Hibernate框架的概述 Hibernate 是一个开放源代码的对象关系映射（ORM）框架，它对 JDBC 进行了非常轻量级的对象封装，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate 可以应用在任何使用 JDBC 的场合，既可以在 Java 的客户端程序使用，也可以在 Servlet/JSP 的 Web 应用中使用。 Hibernate 是轻量级 JavaEE 应用的持久层解决方案，是一个关系数据库 ORM 框架。 Hibernate是一个持久层的ORM框架！！！ ORM（对象关系映射）ORM 映射：Object Relational Mapping O：面向对象领域的 Object （JavaBean 对象） R：关系数据库领域的 Relational （表的结构） M：映射 Mapping （XML 的配置文件） 简而言之：Hibernate 使程序员通过操作对象的方式来操作数据库表记录。 Hibernate 优点 Hibernate 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码； Hibernate是一个基于 JDBC 的主流持久化框架，是一个优秀的 orm 实现，它很大程度的简化了 dao 层编码工作； Hibernate 的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。 Hibernate 框架入门 下载 Hibernate 运行环境下载对应的 jar 包点击下载 Hibernate 5.0.7 Hibernate 目录结构1234567| -- documents 相关的文档| -- lib jar包| | -- jpa sun 公司提供的 orm 框架的规范| | -- required 必需要引入的包| | -- optional 可选的包（c3p0 等）| -- project 提供的一些小项目（无关紧要）| | -- etc 配置文件 创建表结构建表语句如下： 123456789101112131415Create database hibernate_01;Use hibernate_01;CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_user_id` bigint(32) DEFAULT NULL COMMENT '负责人id', `cust_create_id` bigint(32) DEFAULT NULL COMMENT '创建人id', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_linkman` varchar(64) DEFAULT NULL COMMENT '联系人', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 搭建 Hibernate 的开发环境创建WEB工程，引入 Hibernate 开发所需要的 jar 包 MySQL 的驱动 jar 包 1- mysql-connector-java-5.1.7-bin.jar Hibernate 开发需要的 jar 包（../hibernate-release-5.0.7.Final/lib/required/所有jar包） 日志 jar 包 123- log4j-1.2.16.jar // log for java，具体的日志实现- slf4j-api-1.6.1.jar // log4j 规范，接口- slf4j-log4j12-1.7.2.jar // 整合的 编写 JavaBean 实体类Customer 类的代码如下： 12345678910111213141516/** * 客户的JavaBean */public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法&#125; 创建类与表结构的映射在JavaBean所在的包下创建映射的配置文件 默认的命名规则为：实体类名.hbm.xml 在 xml 配置文件中引入约束（引入的是 hibernate3.0 的 dtd 约束，不要引入 4 的约束） 123&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt; 如果不能上网，编写配置文件是没有提示的，需要自己来配置Eclipse： 先复制 http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd –&gt; Window –&gt; preferences –&gt; 搜索xml –&gt; 选择xml catalog –&gt; 点击add –&gt; 选择 URI –&gt; 粘贴复制的地址 –&gt; 选择location，选择本地的 dtd 的路径 Idea：貌似不存在这样的问题idea 很智能，能自己找到 jar 包下的 dtd 文件。 编写映射的配置文件Customer.hbm.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;!--配置类和表结构的映射--&gt; &lt;class name=\"com.renkaigis.domain.Customer\" table=\"cst_customer\"&gt; &lt;!--配置 id 见到 name 属性，JavaBean 的属性 见到 column 属性，表结构的属性 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;!--主键的生成策略--&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!--配置其他属性--&gt; &lt;property name=\"cust_name\" column=\"cust_name\"/&gt; &lt;property name=\"cust_user_id\" column=\"cust_user_id\"/&gt; &lt;property name=\"cust_create_id\" column=\"cust_create_id\"/&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 编写 Hibernate 核心的配置文件**创建配置文件在 src 目录下，创建名称为 hibernate.cfg.xml 的配置文件 在XML中引入DTD约束123&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt; 配置参数打开：../hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 必须配置的4大参数注： 前面的是属性的 name，后面是属性的 value 值 1234#hibernate.connection.driver_class com.mysql.jdbc.Driver#hibernate.connection.url jdbc:mysql:///hibernate_01#hibernate.connection.username root#hibernate.connection.password 123456 数据库的方言（必须配置的）1#hibernate.dialect org.hibernate.dialect.MySQLDialect 可选的配置123#hibernate.show_sql true#hibernate.format_sql true#hibernate.hbm2ddl.auto update 引入映射配置文件（必须要引入映射文件，框架需要加载映射文件） 1&lt;mapping resource=\"com/itheima/domain/Customer.hbm.xml\"/&gt; 核心配置文件hibernate.cfg.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!--记住：先配置 SessionFactory 标签，一个数据库对应一个 SessionFactory 标签--&gt; &lt;session-factory&gt; &lt;!--必须配置的参数有 5 个，4 大参数和数据库的方言--&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_01&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;!--数据库的方言--&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--可选配置--&gt; &lt;!--映射配置文件，需要引入映射的配置文件--&gt; &lt;property name=\"com/renkaigis/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写 Hibernate 入门代码 先加载配置文件 创建 SessionFactory 对象，生成 Session 对象 创建 Session 对象 开启事务 编写保存的代码 提交事物 释放资源 具体的代码如下： 12345678910111213141516171819202122232425262728293031/*** 测试保存客户*/@Testpublic void testSave() &#123; // 1. 先加载配置文件 Configuration config = new Configuration(); // 默认加载 src 目录下的 hibernate.cfg.xml 文件 config.configure(); // 2. 创建 SessionFactory 对象 SessionFactory factory = config.buildSessionFactory(); // 3. 创建 Session 对象 Session session = factory.openSession(); // 4. 开启事务 Transaction tr = session.beginTransaction(); // 5. 编写保存代码 Customer c=new Customer(); c.setCust_name(\"测试\"); c.setCust_level(\"2\"); c.setCust_phone(\"110\"); // 保存数据，操作对象就相当于操作数据库的表结构 session.save(c); // 6. 提交事务 tr.commit(); // 7. 释放资源 session.close(); factory.close();&#125; 总结 1）. 下载 Hibernate 框架的开发包； 2）. 编写数据库和表结构； 3）. 创建 WEB 的项目，导入了开发的 jar 包； MySQL 驱动包、Hibernate 开发的必须要有的 jar 包、日志的 jar 包 4）. 编写 JavaBean ，不要使用基本数据类型，使用包装类； 5）. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签； 6）. 编写 hibernate 的核心的配置文件，里面的内容是固定的； 7）. 编写代码。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"JavaWeb 之 idea 新建部署 JavaWeb 项目","slug":"JavaWeb-idea-new-web-project","date":"2018-05-28T14:08:32.000Z","updated":"2018-08-10T06:42:26.509Z","comments":true,"path":"JavaWeb-idea-new-web-project.html","link":"","permalink":"http://yoursite.com/JavaWeb-idea-new-web-project.html","excerpt":"习惯了 Eclipse ，想用用逼格高点的 idea 发现处处碰壁，终于搞好了，记录一下！","text":"习惯了 Eclipse ，想用用逼格高点的 idea 发现处处碰壁，终于搞好了，记录一下！ 新建项目新建项目 –&gt; Java EE –&gt; Web Application(勾选 Create web.xml)，点击 next，输入项目名和路径。 建 classes 和 lib 文件夹在 WEB-INF 目录下创建两个文件夹 classes、lib： classes：用来存放编译后输出的 class 文件 lib：用来存放项目所需的 jar 包 配置路径和 jar 包配置路径，File –&gt; Project Structure –&gt; Modules –&gt; Paths，选择 “Use module compile output path” -&gt; 将 Output path 和 Test output path 都选择刚刚创建的 classes 文件夹。 接着选择 Dependencies –&gt; 将 Module SDK 选择为自己电脑上的 jdk –&gt; 点击右边的“+”号 –&gt; 选择 “1 Jars or Directories” –&gt; 选择刚刚创建的 lib 文件夹 –&gt; 选择 jar directory，OK 就可以了。 配置 Tomcat 服务器菜单 Run –&gt; Edit Configurations… –&gt; 点击 “+” 号 –&gt; 选择 “Tomcat Server” –&gt; 选择 “Local”，在如下界面输入自己的服务器名。 点击 “Application server” 后面的 “Configure…”，弹出 Application Servers 窗口，选择本地安装的 Tomcat 目录 –&gt; OK； HTTP port 默认端口号是 8080，可以自己修改，也可以使用默认的。例如，我设为 9090，那么项目的访问路径就为：http://localhost:9090 左下角显示警告，是因为没有部署项目，点击右边的 Fix ，弹出下图，部署自己的项目，点击 ➕ 号，选择自己的 web 项目。右边可以输入项目的访问路径，可以默认，也可以自己定义。 若默认，则项目访问路径为：http://localhost:9090(我的9090端口) 若自己定义名称 test，则项目访问路径为：http://localhost:9090/test(我的9090端口) 部署并运行项目点击主界面上的 run 按钮，就可以启动服务器并运行自己的项目了。默认打开的是项目路径下的 index.jsp，可对他进行自定义编辑，看看自己的成果吧。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"MySQL 重新启动出错：MySQL is not running, but lock file (/var/lock/subsys/mysql) exists.","slug":"mysqlerror00","date":"2018-05-16T02:56:28.000Z","updated":"2018-05-16T03:06:08.891Z","comments":true,"path":"mysqlerror00.html","link":"","permalink":"http://yoursite.com/mysqlerror00.html","excerpt":"Linux 下： 运行 service mysql status 时出错： 1MySQL is not running, but lock file (/var/lock/subsys/mysql) exists","text":"Linux 下： 运行 service mysql status 时出错： 1MySQL is not running, but lock file (/var/lock/subsys/mysql) exists 解决方案： rm -f /var/lock/subsys/mysql 1[root@centos65 /]# rm -f /var/lock/subsys/mysql 重新检查 mysql 状态： 1[root@centos65 /]# service mysql status 若没有启动，可以重新启动 mysql 服务： 12[root@centos65 /]# service mysql startStarting MySQL..","categories":[],"tags":[]},{"title":"JavaWeb 学习笔记（三）—— JSP","slug":"JavaWeb03-jsp","date":"2018-05-01T14:08:57.000Z","updated":"2018-08-10T06:39:23.488Z","comments":true,"path":"JavaWeb03-jsp.html","link":"","permalink":"http://yoursite.com/JavaWeb03-jsp.html","excerpt":"","text":"JSP 简介JSP 概念JSP（Java Server Pages），java 服务器页面，其根本是一个简化的 Servlet 设计，是一种动态网页技术标准。JSP 是在传统的网页 HTML（标准通用标记语言的子集）文件(*.htm,*.html)中插入 Java 程序段(Scriptlet)和 JSP 标记(tag)，从而形成 JSP 文件，后缀名为(*.jsp)。 用 JSP 开发的 Web 应用是跨平台的，既能在 Linux 下运行，也能在其他操作系统上运行。 JSP 运行在服务器端，处理请求，生成动态的内容。对应的 java 和 class 文件在 tomcat 目录下的 work 目录下。 JSP 执行流程 浏览器发送请求，访问 jsp 页面； 服务器接受请求，jspSerlvet 会帮我们查找对应的 jsp 文件； 服务器将 jsp 页面翻译成 java 文件； jvm 会将 java 编译成 .class 文件； 服务器运行 class 文件，生成动态的内容； 将内容发送给服务器； 服务器组成响应信息，发送给浏览器； 浏览器接受数据，解析展示。 JSP 脚本 &lt;% %&gt;：java 程序片段，生成在 jsp 的 service 方法中 &lt;%= %&gt;：输出表达式，生成在 jsp 的 service 方法中，相当于 java 中调用 out.print(..) &lt;%! %&gt;：声明成员，翻译成 servlet 内部的内容。 JSP 注释JSP 支持三种注释：HTML 注释、Java 注释、JSP 注释: JSP 指令EL 表达式JSP 标注标签库（JSTL）","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JavaWeb 学习笔记（二）—— Request 与 Response","slug":"JavaWeb02-request-response","date":"2018-04-30T13:24:06.000Z","updated":"2018-08-10T06:40:33.116Z","comments":true,"path":"JavaWeb02-request-response.html","link":"","permalink":"http://yoursite.com/JavaWeb02-request-response.html","excerpt":"","text":"Response响应 的作用是往浏览器写东西。包括响应行、响应头、响应体。 操作 Response 对象操作响应行响应行的格式：协议/版本 状态码 状态码说明 状态码 说明 1xx 已发送请求 2xx 已完成响应200：正常响应 3xx 还需浏览器进一步操作302：重定向，配合响应头location304：读缓存 4xx 用户操作错误404：用户操作错误访问的方法不存在 5xx 服务器错误500：内部异常 设置状态码：12345//仅针对于上表的 1xx、2xx、3xxvoid setStatus(int 状态码):Sets the status code for this response. //针对于 4xx 和 5xx【了解】void sendError(int 状态码):Sends an error response to the client using the specified status code and clearing the buffer. 操作响应头格式：key/value（value 可以是多个值） 常用方法1234567setHeader(String key,String value):设置字符串形式的响应头【了解】setIntHeader(String key,int value):设值整型的响应头【了解】setDateHeader(String key,long value):设值时间的响应头addHeader(String key,String value):添加字符串形式的响应头，之前设置过则追加，若没有设置过则设置【了解】addIntHeader(String key,int value):添加整型的响应头【了解】addDateHeader(String key,long value):添加时间的响应头 常用的响应头 location：重定向 refresh：定时刷新 content-type：设置文件的 mime 类型，设置响应流的编码及告诉浏览器用什么编码打开 content-disposition：文件下载 重定向与定时刷新重定向 方式1：★★ 1response.sendRedirect(\"/javaweb/test1\"); 方式2： 12response.setStatus(302);respooen.setHeader(\"location\",\"/day10/loc2\"); 定时刷新 方式1： 12//设置头 refreshresponse.setHeader(\"refresh\",\"秒数;url=跳转的路径\"); 方式2： 12&lt;--! 设置html的meta标签 --&gt;&lt;meta http-equiv=\"refresh\" content=\"3;url=/javaweb/test1.html\"&gt; 操作响应体响应体即页面上要展示的内容。 常用方法12Writer getWriter():字符流ServletOutputStream getOutputStream():字节流 注：自己写的东西用字符流,其他一概用字节流. 处理响应中文乱码 方式1：★ 1response.setContentType(\"text/html;charset=utf-8\"); 方式2：理解 1response.setHeader(\"content-type\", \"text/html;charset=utf-8\"); 详细的介绍如下： 处理字节流12345//设置浏览器默认打开编码response.setHeader(\"Content-Type\", \"text/html;charset=UTF-8\");//中文转成字节数组编码response.getOutputStream().write(\"上山打老虎\".getBytes(\"UTF-8\")); 处理字符流123456//设置response的缓冲区的编码response.setCharacterEncoding(\"UTF-8\");//设置浏览器默认打开的编码.response.setHeader(\"Content-Type\", \"text/html;charset=UTF-8\");response.setContentType(\"text/html;charset=UTF-8\");//相当于上面两句 注意: 两个流互斥 当响应完成之后，服务器会判断一下流是否已经关闭，若没有关闭，服务器会帮我们关闭。（底层使用的缓冲流） 扩展-文件下载超链接方式1&lt;a href=\"/javaweb/download/Notes.txt\"&gt;下载 Notes.txt&lt;/a&gt; 若浏览器能解析该资源的mime类型，则打开；若不能解析，则下载。 手动编码方式通过 servlet 完成。 a.设置文件的 mime 类型12String mimeType=context.getMimeType(文件名);response.setContentType(mimeType); b.设置下载头信息1response.setHeader(\"content-disposition\", \"attachment;filename=\"+文件名称); c.提供流1response.getOutputStream(); 扩展-使用commons-io工具类，对拷流： 1IOUtils.copy(is,os); 案例-文件下载1.在页面中提供一组下载的链接123response.getWriter().println(\"&lt;h2&gt;手动编码方式下载&lt;/h2&gt;\");response.getWriter().println(\"&lt;a href='/WEB10/downloadServlet?filename=a.bmp'&gt;a.bmp&lt;/a&gt;&lt;br/&gt;\");response.getWriter().println(\"&lt;a href='/WEB10/downloadServlet?filename=WEB01.zip'&gt;WEB01.zip&lt;/a&gt;\"); 2.编写 DownloadServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445//获取下载文件的名称String filename = request.getParameter(\"name\");//注意中文乱码:filename = new String(filename.getBytes(\"iso8859-1\"), \"utf-8\");ServletContext context = this.getServletContext();//文件下载//1.设置文件的mimeTypeString mimeType = context.getMimeType(filename);response.setContentType(mimeType);//2.设置下载的头信息//原始的//response.setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//常见的浏览器将文件名称使用utf-8 不推荐 不兼容火狐//response.setHeader(\"content-disposition\", \"attachment;filename=\"+URLEncoder.encode(filename, \"utf-8\"));//方式1:通过 DownLoadUtils 工具类编码//String _filename=DownLoadUtils.getName(request.getHeader(\"user-agent\"), filename);//response.setHeader(\"content-disposition\", \"attachment;filename=\"+_filename);//方式2:网络上的方式 (8成好使)response.setHeader(\"content-disposition\", \"attachment;filename=\" + new String(filename.getBytes(\"gbk\"), \"iso8859-1\"));//3.对拷流//获取输入流InputStream is = context.getResourceAsStream(\"/download/\" + filename);//获取输出流ServletOutputStream os = response.getOutputStream();/*int len = -1;byte[] b = new byte[1024];while((len = is.read(b))!=-1)&#123; os.write(b, 0, len);&#125;is.close();*///使用commons-io工具类对拷流IOUtils.copy(is, os);os.close();is.close(); 其中，DownLoadUtils 如下进行封装： 1234567891011121314151617public class DownLoadUtils &#123; public static String getName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains(\"MSIE\")) &#123; // IE浏览器 filename = URLEncoder.encode(filename, \"utf-8\"); filename = filename.replace(\"+\", \" \"); &#125; else if (agent.contains(\"Firefox\")) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = \"=?utf-8?B?\" + base64Encoder.encode(filename.getBytes(\"utf-8\")) + \"?=\"; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, \"utf-8\"); &#125; return filename; &#125;&#125; 扩展-生成验证码 编写 CodeServlet: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 使用java图形界面技术绘制一张图片int charNum = 4;int width = 30 * 4;int height = 30;// 1. 创建一张内存图片BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);// 2.获得绘图对象Graphics graphics = bufferedImage.getGraphics();// 3、绘制背景颜色graphics.setColor(Color.YELLOW);graphics.fillRect(0, 0, width, height);// 4、绘制图片边框graphics.setColor(Color.BLUE);graphics.drawRect(0, 0, width - 1, height - 1);// 5、输出验证码内容graphics.setColor(Color.RED);graphics.setFont(new Font(\"宋体\", Font.BOLD, 20));// 随机输出4个字符Graphics2D graphics2d = (Graphics2D) graphics;String s = \"ABCDEFGHGKLMNPQRSTUVWXYZ23456789\";Random random = new Random();// session中要用到String msg = \"\";int x = 5;for (int i = 0; i &lt; 4; i++) &#123; int index = random.nextInt(32); String content = String.valueOf(s.charAt(index)); msg += content; double theta = random.nextInt(45) * Math.PI / 180; // 让字体扭曲 graphics2d.rotate(theta, x, 18); graphics2d.drawString(content, x, 18); graphics2d.rotate(-theta, x, 18); x += 30;&#125;// 6、绘制干扰线graphics.setColor(Color.GRAY);for (int i = 0; i &lt; 5; i++) &#123; int x1 = random.nextInt(width); int x2 = random.nextInt(width); int y1 = random.nextInt(height); int y2 = random.nextInt(height); graphics.drawLine(x1, y1, x2, y2);&#125;// 释放资源graphics.dispose();// 图片输出 ImageIOImageIO.write(bufferedImage, \"jpg\", response.getOutputStream()); 点击换一张验证码的 js 代码: 1234function changeImg(obj)&#123; //操作src属性 obj.src=\"/day10/code?i=\"+Math.random();&#125; 结果如下图： Request请求 的作用是获取浏览器发送过来的数据。 操作 Request 对象操作请求行请求行的格式：请求方式 请求资源 协议/版本 常用方法：HttpServletRequest 【掌握】★ 123String getMethod() //获取请求方式String getRemoteAddr() //获取ip地址String getContextPath() //在 java 中获取项目名称 (/javaweb) 【了解】 1234getRequestURI() //获取的是 从项目名到参数之前的内容 /javaweb/registgetRequestURL() //获取的带协议的完整路径 http://localhost/javaweb/registString getQueryString() //get请求的所有参数 username=tom&amp;password=123String getProtocol() //获取协议和版本 例如：请求行 1GET /day10/row?username=tom&amp;password=123 HTTP/1.1 操作请求头格式：key/value（value 可以是多个值） 常用方法 【掌握】★ 1String getHeader(String key) //通过key获取指定的value(一个) 【了解】 1234Enumeration getHeaders(String name) //通过key获取指定的value(多个)Enumeration getHeaderNames() //获取所有的请求头的名称int getIntHeader(String key) //获取整型的请求头long getDateHeader(String key) //获取时间的请求头 重要的请求头: user-agent：浏览器内核 msie firefox chromereferer：页面从那里来 防盗链 操作请求参数请求参数：username=tom&amp;password=123&amp;hobby=drink&amp;hobby=sleep 常用方法123String getParameter(String key) //获取一个值String[] getParameterValues(String key) //通过一个key获取多个值Map&lt;String,String[]&gt; getParameterMap() //获取所有的参数名称和值 例如： 12345678910//valueusername:tom//valueshobby:[drink, sleep]//mapusername::[tom]password::[123]hobby::[drink, sleep] 请求的中文乱码 对于 get 请求：参数追加到地址栏，会使用 utf-8 编码，服务器（tomcat7）接受到请求之后，使用 iso-8859-1 解码，所以会出现乱码。 对于 post 请求：参数是放在请求体中，服务器获取请求体的时候使用 iso-8859-1 解码，也会出现乱码。 通用的方法：缺点是需要一个一个设置 1new String(参数.getBytes(\"iso-8859-1\"),\"utf-8\"); 针对于 post 请求的方法：只需要将请求流的编码设置成 utf-8 即可。 1request.setCharacterEncoding(\"utf-8\"); 域对象 request request 域 生命周期 创建 一次请求来的时候 销毁 响应生成的时候 作用 存放一次请求里面的数据 请求转发（也叫请求链、请求串） 1request.getRequestDispatcher(\"内部路径\").forward(request,response); 作为域对象存取值 123void setAttribute(String name, Object o)void removeAttribute(String name)Object getAttribute(String name) 例如： 123request.setAttribute(\"username\",\"tom\");request.getAttribute(\"username\"); 请求转发与重定向 重定向 1response.sendRedirect(String path); 请求转发 1request.getRequestDispatcher(String path).forward(request,response); 重定向发送两次请求，请求转发一次请求 重定向地址栏发生改变，请求转发不变 重定向是从浏览器发送，请求转发是服务器内部 重定向不存在 request 域对象，请求转发可以使用 request 域对象 重定向是 response 的方法，请求转发是 request 的方法 重定向可以请求站外资源，请求转发不可以 扩展-编码解码12URLEncoder.encode(String s, \"utf-8\"); //指定编码URLDecoder.decode(String s8, \"iso8859-1\"); //指定解码 例如： 12345678910111213141516public static void main(String[] args) throws Exception &#123; String s=\"天下\"; //用 utf-8 进行编码 String s8=URLEncoder.encode(s, \"utf-8\"); //System.out.println(s8); //对utf-8的字符串通过iso8859-1进行解码，则会出现乱码 String so = URLDecoder.decode(s8, \"iso8859-1\"); System.out.println(so); //乱码 byte[] b = so.getBytes(\"iso-8859-1\"); String _s = new String(b, \"utf-8\"); //上面的两句简写为：String _s=new String(so.getBytes(\"iso8859-1\"),\"utf-8\"); System.out.println(_s);&#125; 整理的也许不全面，就这样吧！","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JavaWeb 学习笔记（一）—— HTTP 与 Servlet","slug":"JavaWeb01-http-servlet","date":"2018-03-27T13:14:24.000Z","updated":"2018-08-10T07:02:44.778Z","comments":true,"path":"JavaWeb01-http-servlet.html","link":"","permalink":"http://yoursite.com/JavaWeb01-http-servlet.html","excerpt":"","text":"HTTP 协议HTTP 协议的概念超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。 规定被约束的对象要遵守的规则！ HTTP 协议HTTP 协议规定：浏览器（客户端）向服务器发送何种格式的数据，服务器会处理数据，向浏览器（客户端）作出响应。（向客户端发送何种格式的数据） HTTP 协议的特点: HTTP 协议遵守一个请求响应模型； 请求和响应必须成对出现； 必须先有请求后有响应； HTTP 协议默认的端口：80 HTTP 协议的请求部分（Request）组成部分：请求行、请求头、请求体 12345678910//get 请求方式的抓包：GET /WEB09/demo1/subSucc.html?username=aaa&amp;password=123 HTTP/1.1Accept: text/html, application/xhtml+xml, */*X-HttpWatch-RID: 63397-10023Referer: http://localhost:8080/WEB09/demo1/demo1.htmlAccept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: localhost:8080Connection: Keep-Alive 123456789101112131415//post 请求方式的抓包：POST /WEB09/demo1/subSucc.html HTTP/1.1Accept: text/html, application/xhtml+xml, */*X-HttpWatch-RID: 63397-10049Referer: http://localhost:8080/WEB09/demo1/demo1.htmlAccept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoContent-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: localhost:8080Content-Length: 25Connection: Keep-AliveCache-Control: no-cacheusername=aaa&amp;password=123 请求行请求行：请求信息的第一行，包含：请求方式、请求路径、协议版本。 例如： 1GET /WEB09/demo1/subSucc.html?username=aaa&amp;password=123 HTTP/1.1 请求方式：请求方式有很多种，常用的是 GET 和 POST。 GET 和 POST 区别： GET：请求参数会显示到地址栏；GET方式有大小的限制；GET方式没有请求体。 POST：请求参数不会显示到地址栏；在请求体中，POST没有大小限制；POST方式有请求体。 只有表单设置为 method=&quot;post&quot; 才是 post 请求，其他的都是 get 请求 请求头请求头：请求信息的第二行到空行结束。 格式：key：value（value可以是多个值） 常见的请求头: 请求头 描述 Accept: text/html,image/bmp 支持数据类型text/html text/css text/javascript 大类型/小类型 mime类型 Accept-Charset: ISO-8859-1 字符集 Accept-Encoding: gzip 支持压缩 Accept-Language:zh-cn 语言环境 Host: www.renkaigis.com:80 访问主机 ★ If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT 缓存文件的最后修改时间，和响应中一个头一起使用，完成本地缓存的查找 ★ Referer: http://www.renkaigis.com/index.jsp 来自哪个页面、防盗链 ★ User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) 获得客户端浏览器的信息。（文件下载：IE：URL编码，火狐：Base64） Connection:Keep-Alive 链接状态 请求体请求体：空行以下的内容。 只有post才有请求体，获取请求参数：http://xxxx?username=tom&amp;password=123 格式：username=tom&amp;password=123 HTTP 协议的响应部分（Response）组成部分：响应行、响应头、响应体 12345678910111213141516171819HTTP/1.1 200 OKServer: Apache-Coyote/1.1Accept-Ranges: bytesETag: W/&quot;147-1455670867735&quot;Last-Modified: Wed, 17 Feb 2016 01:01:07 GMTContent-Type: text/htmlContent-Length: 147Date: Wed, 17 Feb 2016 01:17:06 GMT&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Java&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Java学习&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应行响应行：响应信息的第一行。 格式：协议/版本 状态码 状态码说明 例如：HTTP/1.1 200 OK 状态码： 200 正常响应成功 302 重定向 304 读缓存 404 用户操作资源不存在 500 服务器内部异常 响应头响应头：从响应信息的第二行到空行结束。 格式:key：value(value可以是多个值) 常见的响应头： 响应头 描述 ★ Location: http://www.it315.org/index.jsp 跳转方向 和302一起使用的 Server:apache tomcat 服务器型号 Content-Encoding: gzip 数据压缩 Content-Length: 80 数据长度 Content-Language: zh-cn 语言环境 ★ Content-Type: text/html; charset=GB2312 数据类型 ★ Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 最后的修改文件的事件.与 If-Modified-Since 一起使用 ★ Refresh: 1;url=http://www.it315.org 定时刷新 ★ Content-Disposition: attachment; filename=aaa.zip 下载 ★ Set-Cookie:SS=Q0=5Lb_nQ; path=/search Expires: -1 缓存 Cache-Control: no-cache 缓存 Pragma: no-cache 缓存 Connection: Keep-Alive 连接 响应体响应体：页面上展示的内容。 Servlet概念Servlet 是运行在服务器端的一个 Java 小程序，动态的 web 开发技术，主要功能在于交互式地浏览和修改数据，生成动态 web 内容。 Servlet = Service + Applet Servlet 实现过程 客户端发送请求至服务器端； 服务器将请求信息发送至 Servlet； Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求； 服务器将响应返回给客户端。 编写一个 Servlet 步骤1、编写一个类: a. 继承 HttpServlet， b. 重写 doGet 或者 doPost 方法； 2、编写配置文件（web-inf/web.xml）: a. 注册 Servlet; b. 绑定路径 3、访问：http://主机:端口号/项目名/路径 接收参数格式:key=value 1Sting value=request.getParameter(\"key\") 例如: http://localhost/day09/hello?username=tom request.getParameter(“username”) 就可以获取 tom 值 回写内容1response.getWriter().print(\"success\"); 处理响应数据中文乱码: 1response.setContentType(\"text/html;charset=utf-8\"); //建议放在方法中的第一行 编写配置文件配置文件路径：web-inf/web.xml 配置 Servlet 到 WEB 服务器。 123456789101112131415&lt;!-- 配置Servlet --&gt;&lt;servlet&gt; &lt;!-- Servlet的名称 --&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;!-- Servlet的类的全路径 --&gt; &lt;servlet-class&gt;com.servlet.demo1.DemoServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 配置Servlet的映射 --&gt;&lt;servlet-mapping&gt; &lt;!-- Servlet的名称 --&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;!-- Servlet的访问路径 --&gt; &lt;url-pattern&gt;/servletDemo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; url-pattern的配置: ★ 方式1：完全匹配 必须以&quot;/&quot;开始 例如: /hello /a/b/c 方式2：目录匹配 必须&quot;/&quot;开始 以&quot;*&quot;结束 例如: /a/* /* 方式3：后缀名匹配 以&quot;*&quot;开始 以字符结尾 例如: *.jsp *.do *.action 优先级: 完全匹配 &gt; 目录匹配 &gt; 后缀名匹配 练习: 有如下的一些映射关系： Servlet1 映射到 /abc/* Servlet2 映射到 /* Servlet3 映射到 /abc Servlet4 映射到 *.do 问题: 当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/abc”时，“/*”和“/abc”都匹配，哪个servlet响应 Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2. 当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 配置 Servlet 的启动时加载在 web.xml 中 &lt;servlet&gt; 标签中配置 1&lt;load-on-startup&gt;2&lt;/load-on-startup&gt; 作用：用来修改 servlet 的初始化时机 取值：正整数，值越大优先级越低 当我们的配置文件里面没有指定配置的话，会查找 tomcat 的 web.xml，若请求我们自己的项目处理不了,tomcat 的默认的 servlet 会帮我们处理信息。 路径的写法相对路径： 当前路径 ./ 或者 什么都不写 上一级路径 ../ 绝对路径：(我们使用) 带主机和协议的绝对路径（访问站外资源） http://www.itheima.com/xxxx http://localhost:80/day09/hello 不带主机和协议的绝对路径 /day09/hello（经常使用） Servlet 结构与方法servlet的体系结构:Servlet:接口 | GenericServlet:抽象类 | HttpServlet:抽象类 | 自定义servlet Servlet 常用方法: void init(ServletConfig config):初始化 void service(ServletRequest request,ServletResponse response):服务 处理业务逻辑 void destroy():销毁 ServletConfig getServletConfig():获取当前 servlet 的配置对象 GenericServlet 常用方法:除了 service 方法没有显示，其他都实现了 空参的 init()，若我们自己想对 servlet 进行初始化操作，重写这个 init() 方法即可 HttpServlet 常用方法：service 做了实现，把参数强转，调用了重载的 service 方法 重载的 service 方法获取请求的方式，根据请求方式的不同调用相应 doXxx() 方法 doGet 和 doPost 方法 Servlet 的生命周期生命周期指的是一个对象从创建到销毁的过程。 Servlet 的生命周期，指的是 Servlet 对象从创建到销毁的过程。 void init(ServletConfig config):初始化 * 初始化方法 * 执行者:服务器 * 执行次数:一次 * 执行时机:默认第一次访问的时候 void service(ServletRequest request,ServletResponse response):服务 处理业务逻辑 * 服务 * 执行者:服务器 * 执行次数:请求一次执行一次 * 执行时机:请求来的时候 void destroy():销毁 * 销毁 * 执行者:服务器 * 执行次数:只执行一次 * 执行时机:当servlet被移除的时候或者服务器正常关闭的时候 Serlvet是单实例多线程 默认客户端第一次访问 Servlet 的时候，服务器创建一个 Servlet 对象，并调用 init 实现初始化操作。并调用一次 service 方法，每当请求来的时候，服务器创建一个线程，调用 service 方法执行自己的业务逻辑。当 Servlet 被移除的时候或者服务器正常关闭的时候，Servlet 对象就会被销毁，服务器调用 Servlet 的 destroy 方法实现销毁操作。 补充常见的响应头——refreshrefresh（定时刷新） 响应头格式: refresh:秒数;url=跳转的路径 123//设置响应头：//设置字符串形式的响应头response.setHeader(String key,String value); 12//追加响应头，若之前设置过这个头，则追加；若没有设置过，则设置response.addHeader(String key,String value); 12//设置定时刷新：response.setHeader(\"refresh\",\"3;url=/day0901/login.htm\"); 另： 可以通过html页面中的一个标签设置头信息 &lt;meta&gt; 标签，跳转到指定路径。 1&lt;meta http-equiv=\"Refresh\" content=\"5;url=/WEB09/succ.html\"&gt; ServletContextServletContext ：全局管理者（上下文），是一个项目的引用，代表了当前项目。 当项目启动的时候，服务器会为每一个 web 项目创建一个 servletContext 对象。 当项目被移除的时候或者服务器关闭的时候 servletContext 销毁。 servletContext 接口是 Servlet 中最大的一个接口，呈现了 web 应用的 Servlet 视图。 ServletContext 实例是通过 getServletContext() 方法获得的，由于 HttpServlet 继承 GenericServlet 的关系，GenericServlet 类和 HttpServlet 类同时具有该方法。 作用: 获取全局的初始化参数 共享资源(xxxAttribute) 获取文件资源 其他操作 获取 servletcontext方式1：了解 getServletConfig().getServletContext() 方式2： getServletContext() 常用方法 了解 12String getInitParameter(String key)//通过名称获取指定的参数值Enumeration getInitParameterNames()//获取所有的参数名称 在根标签下有一个 context-param 子标签，用来存放初始化参数： 1234&lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/context-param&gt; xxxAttribute（set,get） 12345String getRealPath(String path)//获取文件部署到tomcat上的真实路径(带tomcat路径)getRealPath(\"/\")//D:\\javaTools\\apache-tomcat-7.0.52\\webapps\\day09\\InputStream getResourceAsStream(String path)//以流的形式返回一个文件 获取文件的 mime 类型（大类型/小类型） 1String getMimeType(String 文件名称) 域对象 ★★★servletcontext 可以被当成map集合。 常用方法: xxxAttribute() servletcontext 创建和销毁： 当项目启动的时候服务器为每一个 web 项目创建一个 servletcontext 对象。当项目被移除的时候或者服务器关闭的时候 servletcontext 销毁。 存放: 共享的数据 获取文件的路径通过类加载器获取文件：2.txt 放在 classes 目录下无论是 java 项目还是 web 项目都可以。 1类.class.getClassLoader().getResource(\"2.txt\").getPath();","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"ArcGIS Engine 空间关系之判断点在面内","slug":"ArcGIS-Engine-PointInPolygon","date":"2018-03-23T02:36:45.000Z","updated":"2018-08-10T06:49:31.245Z","comments":true,"path":"ArcGIS-Engine-PointInPolygon.html","link":"","permalink":"http://yoursite.com/ArcGIS-Engine-PointInPolygon.html","excerpt":"做项目遇到的问题。寥寥几行代码轻松解决，记录一下。","text":"做项目遇到的问题。寥寥几行代码轻松解决，记录一下。 几何对象之间的空间关系主要有包含、相等、在内部、相交等。矢量数据的空间关系运算需要用到 IRelationalOperation 接口，通过该接口的不同方法判定两个几何对象之间的关系是否存在。关系运算符用于比较两个几何体，并返回一个布尔类型值来说明某种控件关系是否存在。 空间包含关系（Contains &amp; Within）空间包含（Contains）表示当前几何对象包含输入几何对象。在内部（Within）表示当前几何对象在输入几何对象的内部。Contains 和 Within 是相对的关系，即 Contains 的反面就是 Within。 交叉（Crosses）交叉（Crosses）表示线和线或者线和面的边界之间有相交。 相离（Disjoint）相离（Disjoint）表示两个几何对象之间没有任何公共部分。 重叠（Overlaps）重叠（Overlaps）表示两个同一维度的几何对象具有公共部分，并且公共部分和输入集合对象具有相同的维度。 相等（Equals）相等（Equals）表示两个几何对象具有相同的几何维度、顶点集合等。对于多边形和线几何类型，如果它们具有相等关系，则 SymmetricDifference 方法返回值为空。 相接（Touches）相接（Touches）表示两个几何对象的边界相交。如果两个几何对象相接，那么它们的交集不为空，但是集合对象的内部交集为空。 IRelationalOperator的一些关系类型: 关系类型 描述 Contains 判断一个图形是否包含另外一个图形 Within 判断一个图形是否被另外一个图形所包含。 Crosses 判断两个图形是否在维数较少的那个图形的内部相交 Disjoint 判断两个图形间是否没有相同点 Equals 判断两个图形是否是同一个类型并且在平面上的点是否是相同的位置。如果返回值为真，则它们应该包含（Contains）另外一个图形同时也被另外一个图形所包含(Within)。 Overlaps 判断两个图形的交集是否和其中的一个图形拥有相同的维数，并且他们交集不能和其中任何一个图形相等。该方法只使用与两个Polyline 之间或者两个Polygon 之间。 Touches 判断两个图形的边界是否相交，如果两个图形的交集不为空，但两个图形内部的交集为空，则返回值为真。 本文主要实现了判断点在面内（空间包含关系） AE 代码见 Github：PointInPolygon (AE 版本 10.1，VS 版本 2017) 若代码不能运行，请添加如下引用： 12345678910111213141516using ESRI.ArcGIS.Carto;using ESRI.ArcGIS.esriSystem;using ESRI.ArcGIS.Geodatabase;using ESRI.ArcGIS.Geoprocessing;using ESRI.ArcGIS.AnalysisTools;using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ESRI.ArcGIS.Geoprocessor;using ESRI.ArcGIS.Geometry; 我主要实现了 判断点在面内 的方法，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void pointInPolygonButton_Click(object sender, EventArgs e)&#123; // 获得点图层 int PointId = 1; IFeatureLayer PointLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; PointLayer = axMapControl1.get_Layer(i) as IFeatureLayer; if (PointLayer is IFeatureLayer &amp;&amp; PointLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPoint) &#123; PointId = i; &#125; &#125; if (PointId == -1) &#123; MessageBox.Show(\"找不到质点图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; // 获得面图层 int PolygonId = -1; IFeatureLayer PolygonLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; PolygonLayer = axMapControl1.get_Layer(i) as IFeatureLayer; if (PolygonLayer is IFeatureLayer &amp;&amp; PolygonLayer.FeatureClass.ShapeType == esriGeometryType.esriGeometryPolygon) &#123; PolygonId = i; &#125; &#125; if (PolygonId == -1) &#123; MessageBox.Show(\"找不到边界图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; PointLayer = axMapControl1.get_Layer(PointId) as IFeatureLayer; PolygonLayer = axMapControl1.get_Layer(PolygonId) as IFeatureLayer; IFeatureCursor PointFeatureCursor = PointLayer.Search(null, true); IFeature PointFeature = PointFeatureCursor.NextFeature(); IFeatureCursor PolygonFeatureCursor = PolygonLayer.Search(null, true); IFeature PolygonFeature = PolygonFeatureCursor.NextFeature(); IRelationalOperator pRelationalOperator = PolygonFeature.Shape as IRelationalOperator; if (pRelationalOperator.Contains(PointFeature.Shape)) &#123; MessageBox.Show(\"点在面内！\", \"恭喜你！\", MessageBoxButtons.OK, MessageBoxIcon.Information); return; &#125; else &#123; MessageBox.Show(\"点在面外！\", \"很遗憾！\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125;&#125; 运行结果：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"ArcGIS Engine 之 GP 工具实现矢量转栅格","slug":"ArcGIS-Engine-PointToRaster","date":"2018-03-21T09:02:30.000Z","updated":"2018-08-10T06:49:37.421Z","comments":true,"path":"ArcGIS-Engine-PointToRaster.html","link":"","permalink":"http://yoursite.com/ArcGIS-Engine-PointToRaster.html","excerpt":"做项目遇到需要将矢量数据转换成栅格数据的问题，走了很多弯路，后来发现使用 GP 工具很轻松就解决了，记录一下。","text":"做项目遇到需要将矢量数据转换成栅格数据的问题，走了很多弯路，后来发现使用 GP 工具很轻松就解决了，记录一下。 ArcGIS 软件中 ArcToolbox 中的工具几乎都可以使用 GP 工具来完成。矢量转栅格的工具主要在 ArcToolbox --&gt; Conversion Tools --&gt; To Raster 下，包括 Feature to Raster、Point to Raster、Polygon to Raster 和 Polyline to Raster。其中 Feature to Raster 与其他三种效果相同。 ArcGIS 中 Feature to Raster 方法如下图所示： 官方文档给出的工具语法如下： FeatureToRaster_conversion (in_features, field, out_raster, {cell_size}) Parameter Explanation Data Type in_features The input feature dataset to be converted to a raster dataset. Feature Layer field The field used to assign values to the output raster.It can be any field of the input feature dataset’s attribute table.If the Shape field of a point or multipoint dataset contains z or m values, then either of these can be used. Field out_raster The output raster dataset to be created.When not saving to a geodatabase, specify .tif for a TIFF file format, .img for an ERDAS IMAGINE file format, or no extension for an Esri Grid raster format. Raster Dataset cell_size(Optional) The cell size for the output raster dataset.The default cell size is the shortest of the width or height of the extent of the input feature dataset, in the output spatial reference, divided by 250. Analysis Cell Size AE 代码见 Github：PointToRaster (AE 版本 10.1，VS 版本 2017) 若代码不能运行，请添加如下引用： 12345678910111213141516using ESRI.ArcGIS.Carto;using ESRI.ArcGIS.esriSystem;using ESRI.ArcGIS.Geodatabase;using ESRI.ArcGIS.Geoprocessing;using ESRI.ArcGIS.AnalysisTools;using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ESRI.ArcGIS.Geoprocessor;using ESRI.ArcGIS.DataSourcesRaster; 我主要实现了 点转栅格 的方法，核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void toRaster_Click(object sender, EventArgs e)&#123; Geoprocessor gp = new Geoprocessor(); gp.OverwriteOutput = true; int pLayerId = -1; ILayer pLayer = null; for (int i = 0; i &lt; axMapControl1.LayerCount; i++) &#123; pLayer = axMapControl1.get_Layer(i); //if (pLayer is IFeatureLayer &amp;&amp; pLayer.Name == \"质点\") if (pLayer is IFeatureLayer) &#123; pLayerId = i; &#125; &#125; if (pLayerId == -1) &#123; MessageBox.Show(\"找不到点图层，请重新加载\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125; try &#123; ESRI.ArcGIS.ConversionTools.FeatureToRaster ptr = new ESRI.ArcGIS.ConversionTools.FeatureToRaster(); // 获得点图层 IFeatureLayer pfeatureLayer = axMapControl1.get_Layer(pLayerId) as IFeatureLayer; IFeatureClass feaureClass = pfeatureLayer.FeatureClass; ptr.in_features = pfeatureLayer; string filepath = @\"d:\\gis\\\"; ptr.out_raster = filepath + pfeatureLayer.Name + \".tif\"; // 将转换结果保存为tif格式 ptr.field = \"id\"; // 设置根据那个字段进行转换 ptr.cell_size = 64; // 设置转换后的栅格像元大小 gp.Execute(ptr, null); // 执行 GP 工具 MessageBox.Show(\"转换成功！\", \"恭喜你！\", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); // 加载栅格 IWorkspaceFactory pWorkspaceFactory = new RasterWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filepath, 0); IRasterWorkspace pRasterWorkspace = pWorkspace as IRasterWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pfeatureLayer.Name + \".tif\"); IRaster pRaster= pRasterDataset.CreateDefaultRaster(); IRasterLayer pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromRaster(pRaster); ILayer layer = pRasterLayer as ILayer; axMapControl1.AddLayer(layer, 0); &#125; catch (Exception ex) &#123; MessageBox.Show(\"转换失败！\", \"很遗憾！\", MessageBoxButtons.OK, MessageBoxIcon.Error); return; &#125;&#125; 运行结果： 经测试，该代码同样适用与 面数据转换栅格：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"2018 要酷酷的","slug":"2017-2018singledogsingledog","date":"2017-12-31T09:37:34.000Z","updated":"2018-08-10T06:50:35.549Z","comments":true,"path":"2017-2018singledogsingledog.html","link":"","permalink":"http://yoursite.com/2017-2018singledogsingledog.html","excerpt":"本想写个年终总结的。","text":"本想写个年终总结的。 年末刷微博的时候，突然看到这幅漫画，瞬间泪奔。 2017 对我很好，他没有亏待我，是我自己不争气，辜负了 2017，浪费了 2017 的大好时光。 2017 再见，抱歉虚度了你，有太多抱怨不解难过与孤独，但都自己一个人撑过来。若是我有做的不好的地方，还请你宽容我，请原谅我这一年的放纵不羁，原谅最后的我没有给你一个满意的答卷。若是 2018 对我不好，我还是会想你的。 对于 2018 我不敢承诺什么，但是我还是要说： 2018，请你对这个傻逼好点！拜托啦！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"Java 泛型：T/K/V/E含义","slug":"java-generic-means-TKVE","date":"2017-12-02T11:54:51.000Z","updated":"2017-12-02T12:32:05.746Z","comments":true,"path":"java-generic-means-TKVE.html","link":"","permalink":"http://yoursite.com/java-generic-means-TKVE.html","excerpt":"从 Java 5 之后，Java 引入了 “参数化类型（parameterized type）” 的概念，允许程序在创建集合时指定集合元素的类型。例如 List&lt;String&gt; ，这表明该 List 只能保存字符串类型的对象。Java 的参数化类型被称为 泛型（Generic）。 看了很多的泛型，T、K、V、E 的字眼层出不穷，却不知道是什么意思。网上查了一些资料，学习了！","text":"从 Java 5 之后，Java 引入了 “参数化类型（parameterized type）” 的概念，允许程序在创建集合时指定集合元素的类型。例如 List&lt;String&gt; ，这表明该 List 只能保存字符串类型的对象。Java 的参数化类型被称为 泛型（Generic）。 看了很多的泛型，T、K、V、E 的字眼层出不穷，却不知道是什么意思。网上查了一些资料，学习了！ Java 泛型中的标记符含义： ？：表示不确定的 java 类型。 T：表示 java 类型。 K、V：分别代表 java 键值中的 Key、Value。 E：表示 enum 枚举。 Object：java 中所有类的父类。 jdk 中的 K，V，T，E 等泛型名称很多人以为是固定写法，其实这些名称是可以改的，比如改成 zhangsan，lisi 都可以，jdk 为了容易看懂，所以用 K 表示键，V 表示值，T 表示 type 类型，E 表示 enum 枚举，其实这四个都只是符号，都是表示泛型名称，T 全部可以换成 E，也可以换成 K，V，zhangsan，都没关系。 Object 跟这些标记符代表的 java 类型有什么区别呢？Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型 T、E 等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。 代码摘自网络： 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;//T1,T2都是随便定义的东西，注意1:他们不会关联到其他类，只是在本类中通用，只是告诉我们new的时候要加入泛型public class Test&lt;T1, T2&gt; &#123; public static void main(String[] args) &#123; System.out.println(new Test().getaa()); new Test&lt;String, String&gt; ().getbb(\"\"); new Test().getcc(Test.class); //注意下6:面这个HashMap的括号里面不能是T,E,T1,T2等不确定的东西,但可以是? HashMap&lt;Object, String&gt; map = new HashMap&lt;Object, String&gt;(); List&lt;?&gt; list = new ArrayList&lt;String&gt;(); &#125; T2 getaa() &#123; //注意2:T2将自动转型为String,这个不需要去担心 return (T2) \"few\"; &#125; public &lt;T&gt; void getbb(T x) &#123; //注意3:Class&lt;T&gt;前面缺少&lt;T&gt;将编译错误 System.out.println(x.getClass().getName()); &#125; public &lt;T&gt; Class&lt;?&gt; getcc(Class&lt;T&gt; a) &#123; //getcc前面的Class&lt;T&gt;前面缺少&lt;T&gt;将编译错误,注意4:Class&lt;?&gt;里面的问号可以换成T System.out.println(a.getClass().getName()); //注意5:参数里面的Class&lt;T&gt;最大的好处是如果方法里面定义了泛型，可以自动获取类型值，比如如下的List&lt;T&gt;可以自动获取到a的类型，不必强调死 List&lt;T&gt; aa=new ArrayList&lt;T&gt;(); System.out.println(aa); return a; &#125;&#125; 运行结果： 1234fewjava.lang.Stringjava.lang.Class[]","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"滇池实验——昆明之旅","slug":"experiment-in-Kunming-Dianchi","date":"2017-11-20T02:02:56.000Z","updated":"2018-08-10T07:00:53.075Z","comments":true,"path":"experiment-in-Kunming-Dianchi.html","link":"","permalink":"http://yoursite.com/experiment-in-Kunming-Dianchi.html","excerpt":"于我而言，对这趟“滇池实验”充满着期待…第一次出差，第一次去云南，第一次坐飞机，第一次冲上云霄，…… 内含多图，流量慎点！","text":"于我而言，对这趟“滇池实验”充满着期待…第一次出差，第一次去云南，第一次坐飞机，第一次冲上云霄，…… 内含多图，流量慎点！ 讲真，从小到大第一次坐飞机，对一切都是陌生又期待的。天生的贪玩属性，出差不仅要做好本职工作，还要好好地玩~ 飞机篇 没坐过飞机的人看见什么都是充满新奇的~ 工作篇 采水样，做实验，实地考察滇池，做汇报。工作先行，游玩次之~ 海鸥篇 这么铺天盖地的海鸥还是第一次见，抑制不住的兴奋~ 滇池篇 讲真，滇池的水真的脏，真 · 青山绿水 风景篇 昆明的天气一直都那么好，随手一拍都是美美的照片 蓝蓝的天，白白的云，太阳直射，暖洋洋 文艺篇 找到了一家西西弗书店，灯光及装饰都给人温暖的感觉 在矢量咖啡点上一杯咖啡，轻柔的音乐响起，无比惬意！ 还去了猫的天空之城概念书店、花生书店。这两家店都太小了，远不如西西弗书店大气。尤其是不消费还赶人！！！ 美食篇 云大附近的园西路，很多好吃的 海埂公园附近的小吃一条街 满足的两个吃货 人物篇 和师姐同游昆明，帮师姐拍了很多美美的照片 我自己的照片很少，满屏幕都是师姐的照片 哼😒等我瘦下来！ 总结昆明之旅很开心，很满足。 最重要的是，看到了和别人的差距，自我感觉别人的 web 平台做的真的很好，而我们的单机版系统不仅从界面还是可视化都感觉很 low。 后面滇池的项目得我接手了，继续学习，继续努力，远离农药，提高代码功底，像师姐学习！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"秦时明月之风林火山集结","slug":"video-qsmoon-flhs","date":"2017-08-31T13:02:14.000Z","updated":"2018-08-10T07:13:25.143Z","comments":true,"path":"video-qsmoon-flhs.html","link":"","permalink":"http://yoursite.com/video-qsmoon-flhs.html","excerpt":"","text":"楚虽三户，亡秦必楚！ 想要成就霸王之业 你需要找到四个重要的人 这四个人就是传承兵道的 风 林 火 山 秦时明月视频纯剪辑 素材：秦时明月之君临天下（第19集-楚之军魂、第68集-一血一脉） 软件：Corel VideoStudio X9 插件：Xvid 分辨率：1920 × 1080","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Video","slug":"Video","permalink":"http://yoursite.com/tags/Video/"}]},{"title":"CSS 基础学习笔记","slug":"css-basic-learning-notes","date":"2017-08-31T03:05:17.000Z","updated":"2018-08-10T06:30:26.330Z","comments":true,"path":"css-basic-learning-notes.html","link":"","permalink":"http://yoursite.com/css-basic-learning-notes.html","excerpt":"自学 CSS 基础笔记。笔记整理中，未完待续……","text":"自学 CSS 基础笔记。笔记整理中，未完待续…… CSS 重点内容： 选择器 浮动 盒子模型 定位 前言CSS 概念 CSS（Cascading Style Sheet，可译为 层叠样式表 或 级联样式表 ）是一组 格式设置规则，用于控制 Web 页面的外观。 通过使用CSS样式设置页面的格式，可将页面的 内容与表现形式分离。页面内容存放在HTML文档中，而用于定义表现形式的CSS规则则存放在另一个文件中或HTML文档的某一部分，通常为文件头部分。 将内容与表现形式分离，不仅可使 维护站点的外观更加容易，而且还可以使HTML文档代码更加简练， 缩短浏览器的加载时间 。 可以用 CSS 做什么？ CSS 是一种 样式表语言 ，用于 为HTML文档定义布局 。例如，CSS 涉及字体、颜色、边距、高度、宽度、背景图像、高级定位等方面。 HTML 可以用于为网站添加布局效果，但有可能被误用。而CSS则提供了更多选择，而且更为精确、完善。现在所有浏览器都支持CSS。 你可以制作自己的CSS样式表，为自己的网站增添花样。 CSS 和 HTML 的区别在哪里？HTML 用于结构化内容CSS 用于格式化结构化的内容 CSS 以 html 为基础的。 CSS 主要设置的就是 html 标签中的属性样式，css进行网页布局。 结构 作用 HTML 结构层 负责从 语义的角度 搭建页面结构 CSS 样式层 负责从 审美的角度 美化页面 JavaScript 行为层 负责从 交互的角度 提升用户体验 采用CSS有哪些好处？ CSS 是 Web 设计界的一次革命。 CSS 的具体优点包括： 通过单个样式表控制多个文档的布局； 更精确的布局控制； 为不同的媒体类型（屏幕、打印等）采取不同的布局； 无数高级、先进的技巧… 采用CSS布局相对于传统的 TABLE 网页布局而具有以下4个显著优势： 表现和内容相分离 将设计部分剥离出来放在一个独立样式文件中，HTML文件中只存放文本信息。这样的页面对搜索引擎更加友好。 提高页面浏览速度 对于同一个页面视觉效果，采用 CSS 布局的页面容量要比 TABLE 编码的页面文件容量小得多，前者一般只有后者的1/2大小。浏览器就不用去编译大量冗长的标签。 易于维护和改版 你只要简单的修改几个 CSS 文件就可以重新设计整个网站的页面。 使用CSS布局更符合现在的 W3C 标准 W3C 组织并不是 ISO 国际标准组织的成员，而是自成一派的万维网联盟(World Wide Web Consortium)，又称 W3C 理事会，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。 CSS 工作原理CSS 语法1选择器&#123;属性:值; 属性:值;.... &#125; 选择器：就是一个选择谁的过程。 参数说明：属性和属性值之间用 冒号(:) 隔开，定义多个属性时，属性之间用英文输入法下的 分号(;) 隔开。 属性 赋值 介绍 color color: red; 前景色（文字颜色） font-size font-size: 20px; 设置文字大小 width width: 30px; 设置宽度 height height: 30px; 设置高度 background-color background-color: red; 设置背景颜色 text-align text-align: center; left/right 文字居中 text-indent text-indent: 2em; 首行缩进 注意：text-align: center; 在块级元素中可以使文字居中显示 CSS 书写位置介绍方法1：行内样式表（style属性） 为 HTML 应用 CSS 的一种方法是使用 HTML 属性 style 。 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; 例子 &lt;/title&gt;&lt;/head&gt;&lt;body style=\"background-color: #FF0000;\"&gt; &lt;p style=\"color:green;font-size:30px;\"&gt;这个页面背景是红色的!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 方法2：内部样式表（style元素） 为 HTML 应用 CSS 的另一种方法是采用 HTML 元素 style 。比如像这样： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;例子&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123;background-color: #FF0000;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这个页面是红色的&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 方法3：外部样式表（引用一个样式表文件）更推荐采用这种引用外部样式表的方法。 外部样式表就是一个扩展名为 css 的文本文件。跟其他文件一样，你可以把样式表文件放在Web服务器上或者本地硬盘上。 例如，比方说你的样式表文件名为 style.css ，它通常被存放于名为style的目录中。可以像下面的方法一样引用： 12&lt;!-- 引用外部样式表 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" /&gt; 注意： 要在href属性里给出样式表文件的地址。 这行代码必须被插入 HTML 代码的头部（header），即放在标签 &lt;head&gt; 和标签 &lt;/head&gt; 之间。就像这样： 12345678&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;我的文档&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" /&gt;&lt;/head&gt;&lt;body&gt; .... 这个链接告诉浏览器：在显示该 HTML 文件时，应使用给出的 CSS 文件进行布局。 这种方法的优越之处在于：多个 HTML 文档可以同时引用一个样式表。换句话说，可以用一个 CSS 文件来控制多个 HTML 文档的布局。 CSS 书写方式之间的区别内嵌式写法： 代码可维护性较差，没有实现css代码与html结构的完全分离 影响的范围只有当前页面 行内是写法： 代码可维护性极差，css代码和html结构没有实现分离 影响的范围只有当前标签 外联式写法： 代码可维护性高，css与html结构完全分离 影响范围广，当前整个网页站点。 选择器选择器分类 基础选择器 标签选择器 类选择器 （⭐⭐⭐⭐⭐） id 选择器 通配符选择器 复合选择器 标签指定式选择器 （⭐⭐⭐⭐） 后代选择器 （⭐⭐⭐⭐⭐） 并集选择器 标签选择器标签：就是 html 中的标签 用法1234标签名&#123; 属性: 值; 属性: 值;&#125; 例如：12345678910111213141516171819&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标签选择器&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;!-- 设置 p 标签的样式 --&gt; p&#123; color: red; font-size: 25px; width: 200px; height: 50px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个p标签&lt;/p&gt;&lt;/body&gt; 补充颜色的显示方式： 直接设置对应颜色的名称 1color：red; 通过十六进制显示：以 # 开头，0-ff 1color: #2934de; 通过 rgb 方式显示：R：红色，0-255；G：绿色，0-255；B：蓝色，0-255 1color: rgb(4,255,20); 通过 rgba 显示：a 设置透明度（alpha），范围 0-1 1background-color: rgba(0,0,0,0.1); 类选择器（重点）用法123.自定义名称&#123; 属性: 值;&#125; 调用：标签通过 class 属性调用类样式。 1234567891011121314&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;类选择器&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;!-- 类样式的定义 --&gt; .fontcolor&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 调用类选择器 --&gt; &lt;p class=\"fontcolor\"&gt;类选择器例子&lt;/p&gt;&lt;/body&gt; 特点 谁调用谁改变，多个标签可以同时调用一个类样式 一个标签可以调用多个类样式（相当于人的名字） 例如：12&lt;!-- 调用多个类样式 --&gt;&lt;p class=\"fontcolor fontsize\"&gt;调用多个类样式&lt;/p&gt; 类的命名规范 不能以纯数字或者以数字开头定义类名 不推荐使用汉字定义类名 不能以特殊符号或者以特殊符号开头（“_”除外）定义类名 不建议使用标签名或者属性名定义类名 常用的命名： 中文 英文 头 header 内容 content/container 尾 footer 导航 nav 侧栏 sidebar 栏目 column 页面外围控制整体布局宽度 wrapper 左右中 left/right/center 登陆条 loginbar 标志 logo 广告 banner 页面主体 main 热点 hot 新闻 news 下载 download 子导航 subnav 菜单 menu 子菜单 submenu 搜索 search 友情链接 friendlink 页脚 footer 版权 copyright 滚动 scroll 内容 content id 选择器用法1234#id名称&#123; 属性: 值; ……&#125; 调用：通过 id 属性调用样式 1&lt;p id=\"p_color\"&gt;p1&lt;/p&gt; 特点 不建议多个标签使用同一 id 选择器的样式（id 和 js 配合使用） 一个标签只能调用一个 id 样式 通配符选择器用法1234*&#123; 属性: 值； ……&#125; 例如： 1234*&#123; color: red; font-size: 20px;&#125; 特点 将页面中的所有标签都选中，设置样式； 可以用来进行页面样式的初始化。 字体相关属性 属性 描述 color 设置文字颜色 font-size 设置文字大小 font-family 设置文字字体 font-weight 设置文字加粗 font-style 设置文字斜体 line-height 行高 font-family 直接设置汉字 123p&#123; font-family: 微软雅黑;&#125; 设置对应字体的英文 设置 unicode 编码 字体名称 英文名称 unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 microsoft yahei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 font-family 可以设置多个值： 123body&#123; font-family: \"SimSun\",\"Arial Narrow\",\"微软雅黑\",\"\\5B8B\\4F53\";&#125; font-weight取值方式： 直接设置数字，范围 100-900 bold (字体加粗) 效果为 700-900 normal(文字字体正常显示) 注意：文字加粗显示，推荐使用 font-weight:700; 1234567p&#123; font-weight: normal; &lt;!-- 文字加粗 --&gt; &lt;!-- font-weight: 900; --&gt; &lt;!-- font-weight: bold; --&gt;&#125; font-style italic：文字斜体显示 normal：文字正常显示 font 属性联写用法： 1font: font-style font-weight font-size/line-height font-family 例如： 123p&#123; font: italic 700 30px 宋体;&#125; 注意： font属性联写必须有 font-size 和 font-family （其他属性可以不写）； font-size 和 font-family 的 顺序不能换。 标签指定式选择器标签指定式选择器又称交集选择器，由两个选择器构成，其中第一个为标记选择器，第二个为 class 选择器或 id 选择器，两个选择器之间不能有空格。如： 123h1.one或h1#two 用法： 1234标签名.选择器名&#123; 属性:值; 属性:值;&#125; 特点关系： 既……又…… 实例： 1234567p.one&#123; color: yellow;&#125; */div#div1&#123; color: red;&#125; 后代选择器后代选择器用来选择元素或元素组的后代，其写法就是把外层标记写在前面，内层标记写在后面，中间用空格分隔。当标记发生嵌套时，内层标记就成为外层标记的后代。 用法： 1234选择器 + 空格 + 选择器&#123; 属性: 值； 属性: 值;&#125; 特点： 标签之间必须属于嵌套关系 选择器之间必须有空格 关系：父与子 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;style type=\"text/css\"&gt; /* p&#123; color: red; &#125; */ /* div p&#123; color: red; &#125; */ /* .one p&#123; color: red; &#125; */ p.one span&#123; color: red; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"one\"&gt; &lt;span&gt; 文字 &lt;/span&gt; &lt;/p&gt; &lt;p class=\"two\"&gt; &lt;span&gt; 文字 &lt;/span&gt; &lt;/p&gt; &lt;!-- &lt;div class=\"one\"&gt; &lt;p&gt; 幸福的p &lt;/p&gt; &lt;/div&gt; &lt;p&gt; 孤独的p &lt;/p&gt; --&gt;&lt;/body&gt; 并集选择器并集选择器是各个选择器通过逗号连接而成的，任何形式的选择器（包括标记选择器、class 类选择器、id 选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 用法： 1234选择器,选择器,选择器&#123; 属性: 值; ……&#125; 作用：将样式集体声明，css 样式初始化 特点：并集选择器之间必须用逗号隔开！ 123456789101112131415161718div,p,span&#123; color: red;&#125;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; div,p,span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;p&gt;567&lt;/p&gt; &lt;span&gt;asdf&lt;/span&gt;&lt;/body&gt; CSS 书写位置及 Html 标签分类CSS 书写位置外部样式表1&lt;link rel=”stylesheet” href=””&gt; 新建一个文件，后缀名以 .css 命名（css文件） 在 html 页面中通过 &lt;link rel=”stylesheet” href=””&gt; 标签将 css 文件引入. 例如： 123456&lt;head&gt; &lt;title&gt;外部样式表&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"1/1.css\"&gt;&lt;/head&gt;&lt;body&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 123456789&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内部样式表&lt;/title&gt; &lt;style type=\"text/css\"&gt; p &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; 内联样式表由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。 123&lt;body&gt; &lt;p style=\"color:red;font-size: 30px;font-family: 华文宋体;font-weight: 900;\"&gt;p中的文字&lt;/p&gt;&lt;/body&gt; CSS 书写方式之间的区别 内嵌式写法： ◆ 代码可维护性较差，没有实现 css 代码与 html 结构的完全分离 ◆ 影响的范围只有当前页面 行内式写法： ◆ 代码可维护性极差，css 代码和 html 结构没有实现分离 ◆ 影响的范围只有当前标签 外联式写法： ◆ 代码可维护性高，css 与 html 结构完全分离 ◆ 影响范围广，当前整个网页站点。 HTML 标签的分类块级标签例如： div,p,h1-h6,ul,li,dl,dt,dd 特点： 元素自己独占一行显示，不与其他元素待在同一行 可以设置宽度和高度 当嵌套一个块级元素，子元素如果不设置宽度，那么该子元素的宽度为父元素的宽度。 行级标签例如： a，span,strong,u 特点： 元素在一行上显示 不能直接设置宽度和高度 行内块元素例如： img,input,textarea 特点： 元素在一行上显示 可以设置宽度和高度 元素之间的转换123display:inline // 将元素转化为行内元素display:inline-block // 将元素转化行内块元素display:block // 将元素转化为块元素 实例： 1234567891011121314151617a&#123; width: 300px; height: 300px; background-color: red; /* display: inline-block; */ /* 将行内元素转化为行内块元素 */ display: block; /* 将行内元素转化为块元素 */&#125;div&#123; width: 300px; height: 300px; background-color: pink; /* 将行内元素转化为行内元素 */ display: inline;&#125; 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12","categories":[{"name":"HTML+CSS+JS","slug":"HTML-CSS-JS","permalink":"http://yoursite.com/categories/HTML-CSS-JS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML 基础学习笔记","slug":"html-basic-learning-notes","date":"2017-08-22T06:17:00.000Z","updated":"2018-08-10T06:27:44.261Z","comments":true,"path":"html-basic-learning-notes.html","link":"","permalink":"http://yoursite.com/html-basic-learning-notes.html","excerpt":"自学 html 基础笔记。","text":"自学 html 基础笔记。 Web 前端简单介绍web 前端包含： pc 端页面 移动端页面 web 前端首先要解决用户体验的问题 认识网页网页的组成网页主要由文字、图片和按钮等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及 Flash 等。 Web 标准1：w3c 万维网联盟组织：用来制定 web 标准的机构（组织） 2：web 标准：制作网页要遵循的规范 3：web 标准规范的分类：结构标准；表现标准；行为标准 结构标准：html（用来制作网页的） 表现标准：css（对网页进行美化的） 行为标准：javascript（让网页动起来，具有生命力） 4：web 标准总结： 结构标准：相当于人的身体 表现标准：相当于人的衣服 行为标准：相当于人的动作 浏览器介绍浏览器是网页运行的平台，常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。 浏览器内核：也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内 ，容以及页面的格式信息。 IE Google/Opera FireFox Safari trident blink gecko webkit 浏览器与服务器1：浏览器向服务器发送请求（通过http协议） 2：http协议：超文本传输协议，也就是浏览器和服务器端的网页传输数据的约束和规范 3：https：加密处理 4：url协议:平时我们写的网址就是 url 地址 url协议：规定 url 地址的格式 协议规定格式： scheme://host.domain:port/path/filename scheme: 定义因特网服务的类型。常见的就是httphost: 定义域主机（http 的默认主机是www）domain: 定义因特网域名 比如：w3school.com.cn:port 定义端口号（网页默认端口 :80）path: 网页所在服务器上的路径filename: 文件名称 认识 html概念html (Hyper Text Markup Language ) 中文译为 超文本标记语言，主要是通过 html 标记对网页中的文本，图片，声音等内容进行描述。 HTML 之所以称为超文本标记语言，不仅是因为他通过标记描述网页内容，同时也由于文本中包含了所谓的 超级链接，通过超链接可以实现网页的跳转。从而构成了丰富多彩的 Web 页面。 html 结构基本结构如下：1234567&lt;! Doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 各部分的含义：12&lt;!-- 文档类型 --&gt;&lt;! Doctype html&gt; 12&lt;!-- 根标签 --&gt;&lt;html&gt;&lt;/html&gt; &lt;html&gt;&lt;/html&gt; 用于告知浏览器其自身是一个 HTML 文档，&lt;/html&gt; 标记标志着 HTML 文档的开始，&lt;/html&gt; 标记标志着 HTML 文档的结束，在他们之间的是文档的头部和主体内容。 12&lt;!-- &lt;html lang=\"en\"&gt; 向搜索引擎表示该页面是html语言，并且语言为英文网站 --&gt;&lt;html lang=\"en\"&gt; 这个主要是给搜索引擎看的，搜索引擎不会去判断该站点是中文站还是英文站，所以这句话就是让搜索引擎知道，你的站点是中文站，对 html 页面本身不会有影响。 12&lt;!-- html文档头部分 --&gt;&lt;head&gt;&lt;/head&gt; 主要用来封装其他位于文档头部的标记。一个 HTML 文档只能含有一对 &lt;head&gt; 标记，绝大多数文档头部包含的数据都不会真正作为内容显示在页面中。 12&lt;!-- 网页的标题 --&gt;&lt;title&gt;&lt;/title&gt; &lt;title&gt; 标记用于定义HTML页面的标题，&lt;title&gt;&lt;/title&gt; 之间的内容将显示在浏即给网页取一个名字，必须位于 &lt;head&gt; 标记之内。一个HTML文档只能含有一对 &lt;title&gt;&lt;/title&gt; 标记，将显示在浏览器窗口的标题栏中。 12&lt;!-- html结构的主体部分 --&gt;&lt;body&gt;&lt;/body&gt; &lt;body&gt; 标记用于定义 HTML 文档所要显示的内容，也称为主体标记。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于 &lt;body&gt; 标记内，&lt;body&gt; 标记中的信息才是最终展示给用户看的。一个HTML文档只能含有一对 &lt;body&gt; 标记，且 &lt;body&gt; 标记必须在 &lt;html&gt; 标记内，位于 &lt;head&gt; 头部标记之后。 标签的分类HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;； HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;； 标签对中的第一个标签是开始标签，第二个标签是结束标签； 开始和结束标签也被称为开放标签和闭合标签； HTML标记—双标记双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：123&lt;标记名&gt;&lt;/标记名&gt;&lt;!-- 例如： --&gt;&lt;body&gt;&lt;/body&gt; 该语法中 &lt;标记名&gt; 表示该标记的作用开始，一般称为 开始标记（start tag），&lt;/标记名&gt; 表示该标记的作用结束，一般称为 结束标记（end tag）。和开始标记相比，结束标记只是在前面加了一个关闭符 /。 HTML标记—单标记单标记也称空标记，只有开始标签没有结束标签：123&lt;标记名&gt;&lt;!-- 例如： --&gt;&lt;! doctype html&gt; 标签关系 嵌套关系：类似父亲和儿子之间的关系 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 并列关系：类似与兄弟之间的关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; html 标签介绍单标签文本注释标签1&lt;!-- 文本注释标签 Ctrl+/ --&gt; 文本换行标签1你好&lt;br&gt;我来自中国 效果演示：你好我来自中国 横线标签1&lt;hr&gt; 效果演示： 双标签段落标签12&lt;p&gt;这是一行文字&lt;/p&gt;&lt;p&gt;这也是一行文字&lt;/p&gt; 效果演示：这是一行文字这也是一行文字 标题标签 注意：标题标签只能取到数字 1-6 123456&lt;h1&gt;这是一个标题1&lt;/h1&gt;&lt;h2&gt;这是一个标题2&lt;/h2&gt;&lt;h3&gt;这是一个标题3&lt;/h3&gt;&lt;h4&gt;这是一个标题4&lt;/h4&gt;&lt;h5&gt;这是一个标题5&lt;/h5&gt;&lt;h6&gt;这是一个标题6&lt;/h6&gt; 文本标签1&lt;font&gt;&lt;/font&gt; 例如：1&lt;font size=\"10\" color=\"red\"&gt;优美的文字&lt;/font&gt; 效果演示： 优美的文字 文本格式化标签文字加粗显示1&lt;strong&gt;该减肥了！&lt;/strong&gt; 效果演示：该减肥了！ 文字斜体1&lt;em&gt;这行字是斜的&lt;/em&gt; 效果演示：这行字是斜的 文字下横线12&lt;ins&gt;文字下横线&lt;/ins&gt;&lt;u&gt;文字下横线&lt;/u&gt; 效果演示：文字下横线文字下横线 文字删除线12&lt;del&gt;删除线&lt;/del&gt;&lt;s&gt;删除线&lt;/s&gt; 效果演示：删除线删除线 图片标签1&lt;img&gt; 属性 描述 src 设置显示图片（图片名称或者图片路径） title 用来设置鼠标放在图片上显示的文字 alt 当图片无法正常显示的时候，对图片的描述 width 用来设置图片宽度 height 用来设置图片的高度 12&lt;!-- 下图来自百度图片 --&gt;&lt;img src=\"www.baidu.com/imags/1.png\" title=\"HTML\" alt=\"测试图片\" width=\"200\" height=\"200\"&gt; 效果演示： 相对路径 当图片和文件（html）在同一个文件夹中时，src 属性中直接写上图片名称即可。 1&lt;img src=\"1.jpg\"&gt; 当图片在文件（html）的下一级目录中时，src 属性中写上图片所在的文件夹名 +“/” + 图片名称 1&lt;img src=\"1/1.jpg\"&gt; 当图片在文件（html）的上一级目录中时，src 属性中写上 ../图片所在文件夹名 + “/” + 图片名称 1&lt;img src=\"../2/1.jpg\"&gt; 绝对路径凡是带有 磁盘路径 的都是绝对路径，或者带有 网站地址 的也是绝对路径。 12&lt;img src=\"D:\\a\\1.png\"&gt;&lt;img src=\"www.baidu.com/imags/1.png\"&gt; 超链接在HTML中创建超链接非常简单，只需用 &lt;a&gt;&lt;/a&gt; 标记环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt; 属性 描述 href 用于指定链接目标的 url 地址，当为 &lt;a&gt; 标记应用 href 属性时，它就具有了超链接的功能。 target 用于指定链接页面的打开方式，其取值有 _self 和 _blank 两种，其中 _self 为默认值， _blank 为在新窗口中打开方式。 在 &lt;head&gt; 标签中使用 &lt;base&gt; 标签可以设置网页整体链接的打开状态。 123&lt;head&gt; &lt;base target=\"_blank\"&gt;&lt;/head&gt; 实例：12&lt;a href=\"http://www.baidu.com\" target=\"_blank\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.renkaigis.com\" target=\"_blank\"&gt;Kai's Blog&lt;/a&gt; 效果演示：百度Kai’s Blog 注意: （1）暂时没有确定链接目标时，通常将 &lt;a&gt; 标记的 href 属性值定义为“#”(即 href=&quot;#&quot; )，表示该链接暂时为一个空链接。 （2）不仅可以创建文本超链接，在网页中各种网页元素，如 图像、表格、音频、视频 等都可以添加超链接。 锚链接通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 使用 “ &lt;a href=&quot;#id名&quot;&gt; 链接文本 &lt;/a&gt; ” 创建链接文本； 使用相应的 id 名标注跳转目标的位置。 12345&lt;!-- 例如在网页顶部写个你好 --&gt;&lt;p id=\"db\"&gt;你好&lt;/p&gt;&lt;!-- 给 a 标签设置 href 属性 \"#id名称\" --&gt;&lt;a href=\"#db\"&gt;返回顶部&lt;/a&gt; 效果演示： 你好返回顶部 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方（上标2） &amp;sup2; ³ 立方（上标3） &amp;sup3; 列表无序列表（ul）12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; 列表项 &lt;li&gt;&lt;/li&gt; ......&lt;/ul&gt; 例如：12345678大家喜欢吃什么水果&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;水蜜桃&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt;&lt;/ul&gt; 效果演示：大家喜欢吃什么水果苹果香蕉菠萝 属性：type （默认值）实心圆点：disc 实心方块：square 空心圆圈：circle 实例：123456789101112&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type=\"square\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type=\"circle\"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 有序列表（ol）1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 属性：type A（ABCD排序），a（abcd排序），i（小写的罗马数字），I（大写的罗马数字） 属性：start=”3”，表示从第几个数开始 123456把大象放冰箱分几步？&lt;ol type=\"a\" start=\"3\"&gt; &lt;li&gt;打开冰箱门&lt;/li&gt; &lt;li&gt;把大象放进去&lt;/li&gt; &lt;li&gt;关上冰箱门&lt;/li&gt;&lt;/ol&gt; 效果演示： 把大象放冰箱分几步？打开冰箱门把大象放进去关上冰箱门 自定义列表（dl）自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; 小标题 &lt;dd&gt;&lt;/dd&gt; 列表项 &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 一般用于网页的底部，例如：1234567&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;售后服务&lt;/dt&gt; &lt;dd&gt;收货地址&lt;/dd&gt; &lt;dd&gt;在线支付&lt;/dd&gt; &lt;dd&gt;联系客服&lt;/dd&gt;&lt;/dl&gt; 效果演示： 售后服务收货地址在线支付联系客服 小补充页面背景音乐1&lt;embed src=\"1.mp3\" hidden=\"true\"&gt; 属性： src：设置音乐路径 hidden：隐藏播放按钮，true 隐藏，false 显示 页面滚动效果1234&lt;!-- 中间的内容可以为 文字、图片，也可以是由程序生成的文字或图片 --&gt;&lt;marquee&gt; ...&lt;/marquee&gt; 实例展示： 1&lt;marquee bgcolor=\"blue\" &gt;我会滚动&lt;/marquee&gt; 效果演示： 我会滚动 属性 描述 height 设置高度 width 设置宽度 bgcolor 设置背景颜色 behavior 设定滚动的方式：alternate：表示在两端之间来回滚动；scroll：表示由一端滚动到另一端，会重复；slide：表示由一端滚动到另一端，不会重复。 direction 设定滚动的时间：down：向下滚动；left：向左滚动；right：向右滚动；up：向上滚动。 loop 设置滚动次数，-1 表示一直滚下去 Meta标签和Link标签Meta 标签meta 的属性有两种：name 和 http-equiv。 name 属性主要用于描述网页，对应于 content（网页内容）。 1、用来说明网页使用的字符集，即编码格式 1&lt;meta charset=\"utf-8\"&gt; 2、用以说明生成工具（如Microsoft FrontPage 4.0）等； 1&lt;meta name=\"generator\" contect=\"\"&gt; 3、向搜索引擎说明你的网页的关键词； 1&lt;meta name=\"keywords\" contect=\"\"&gt; 4、告诉搜索引擎你的站点的主要内容； 1&lt;meta name=\"description\" contect=\"\"&gt; 5、告诉搜索引擎你的站点的制作的作者； 1&lt;meta name=\"author\" contect=\"你的姓名\"&gt; 6、有时候会有一些站点内容，不希望被ROBOTS抓取而公开。为了解决这个问题，ROBOTS开发界提供了两个办法：一个是robots.txt，另一个是 The Robots META 标签。 1&lt;meta name=\"robots\" contect= \"all|none|index|noindex|follow|nofollow\"&gt; robots 其中的属性说明如下： 设定为 all：文件将被检索，且页面上的链接可以被查询； 设定为 none：文件将不被检索，且页面上的链接不可以被查询； 设定为 index：文件将被检索； 设定为 follow：页面上的链接可以被查询； 设定为 noindex：文件将不被检索，但页面上的链接可以被查询； 设定为 nofollow`：文件将不被检索，页面上的链接可以被查询。 http-equiv 属性1&lt;meta http-equiv=\"refresh\" content=\"5;url=http://www.baidu.com\" /&gt; 网页重定向，表示的是 5 秒后网页自动跳转到指定网址。 Link 标签1&lt;link rel=\"icon\" href=\"favicon.ico\"&gt; 给网页 titile 中放置小图标1&lt;link rel=\"stylesheet\" href=\"1.css\"&gt; 引入外部样式表 表格（table）表格基本结构在 HTML 语言中，表格至少由 &lt;TABLE&gt; 标签、&lt;TR&gt; 标签和 &lt;TD&gt; 标签这 3 对标签组成。 1.&lt;table&gt;&lt;table&gt;...&lt;/table&gt; 标签用于在HTML文档中创建表格。它包含表名和表格本身内容的代码。表格的基本单元是单元格，用 &lt;td&gt;...&lt;/td&gt; 标签定义。 2.&lt;tr&gt;表格行用 &lt;tr&gt; 标签定义，由单元格构成。多个行结合在一起就构成一个表格，这反映在用于创建表格的HTML语法中。表格的每一行都用 &lt;tr&gt; 标签表示，并用相应的 &lt;/tr&gt; 结束. 3.&lt;td&gt;表格的每一行又有若干表格单元格，用 &lt;td&gt;...&lt;/td&gt; 标签表示。td 是”表格数据(Table Data)”的英文缩写。&lt;td&gt; 标签定义一个列，嵌套于 &lt;tr&gt; 标签内。border 属性是最常用的属性，可用于定义表格的单元格和结构。该属性指定边框的厚度，如果其值设置为零(0)，则不显示边框。 基本语法：12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;职业&lt;/td&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 属性介绍： bord：设置表格边框的厚度 width：设置表格宽度 height：设置表格高度 cellspacing：设置单元格之间的距离 cellpadding：文字距离单元格边框的距离 bgcolor=”red”：设置背景颜色 align=”center” | left | right：给 tr 或者 td 设置让文字居中，给 table 设置让表格居中 属性名 含义 常用属性值 border 设置边框，默认为0，没有边框 单位为 px 像素值 cellspacing 设置单元格与单元格之间的距离 单位为 px 像素值，默认为 2px cellpadding 设置文字与单元格之间的距离 默认 1px width 设置表格的宽度 单位 px height 设置表格的高度 单位 px align 设置表格在网页中的对其方式 left 左rigth 右center 居中 bgcolor 设置背景颜色 white，red，green等 设置表格表头，用法和 td 一样表头一般位于表格的第一行或第一列，其文本加粗居中。1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18码农江苏 表格属性设置示例：1234567891011121314&lt;table border=\"1\" width=\"200\" height=\"300\" cellspacing=\"0\" cellpadding=\"20\" bgcolor=\"red\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示：（本应整个表格都是 bgcolor 的，这里显示有问题） 姓名年龄职业籍贯小明18码农江苏 设置表格标题：caption 标签必须紧随 table 标签之后。只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。12345678910111213141516&lt;table&gt; &lt;!-- 设置表格标题 --&gt; &lt;caption&gt; &lt;h3&gt;人员信息表&lt;/h3&gt;&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 人员信息表姓名年龄职业籍贯小明18码农江苏 表格结构12345&lt;table&gt; &lt;thead&gt;&lt;/thead&gt; 头 &lt;tbody&gt;&lt;/tbody&gt; 身体 &lt;tfoot&gt;&lt;/tfoot&gt; 脚&lt;/table&gt; 在使用表格进行布局时，可以将表格划分为头部、主体和页脚，具体如下所示： &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部，必须位于 &lt;table&gt;&lt;/table&gt; 标记中，一般包含网页的logo和导航等头部信息。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;thead&gt;&lt;/thead&gt; 标记之后，一般包含网页中除头部和底部之外的其他内容。 &lt;tfoot&gt;&lt;/tfoot&gt;：用于定义表格的页脚，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;tbody&gt;&lt;/tbody&gt; 标记之后，一般包含网页底部的企业信息等。 补充知识：单元格的合并横向合并12345&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415&lt;!-- 实例展示 --&gt;&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"20\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan=\"2\"&gt;年龄&lt;/th&gt; &lt;!--&lt;th&gt;职业&lt;/th&gt;--&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄籍贯小明18码农江苏 纵向合并12345678910&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;!--&lt;td&gt;&lt;/td&gt;--&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415161718192021&lt;!-- 实例展示 --&gt;&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"20\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td rowspan=\"2\"&gt;码农&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;!--&lt;td&gt;前端&lt;/td&gt;--&gt; &lt;td&gt;北京&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18程序猿江苏小白21北京 表单（form）表单介绍表单的作用：主要负责数据采集功能。 对于表单构成中的表单控件、提示信息和表单域，对他们的具体解释如下： 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 基本语法：1&lt;form name=\"form_name\" action=\"url\" method=\"get|post\"&gt;…&lt;/form&gt; 属性介绍： Name ：定义表单的名称； Action ：用来指定表单处理程序的位置（服务器端脚本处理程序）； Method: 定义表单结果从浏览器传送到服务器的方式，默认参数为：get。 get数据提交：① 通过地址栏的方式进行数据提交，将用户输入的信息显出来；② get提交安全性差。 post提交：① 数据通过后台进行提交，不会将用户信息显示出来；② 安全性比较好。 表单域123&lt;form action=\"\"&gt; …&lt;/form&gt; 容纳表单空间和提示信息的一个区域。 表单控件input 控件语法：1&lt;input type=“控件类型”&gt; 在上面的语法中，&lt;input&gt; 标记为单标记，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input&gt; 标记还可以定义很多其他的属性，其常用属性如下表所示。 属性 属性值 描述 type textpasswordradiocheckboxbuttonsubmitresetimagehiddenfile 单行文本输入框密码输入框单选按钮复选框普通按钮提交按钮重置按钮图像形式的提交按钮隐藏域文件域 name 由用户自定义 控件的名称 value 由用户自定义 input 控件中的默认文本值 size 正整数 input 控件在页面中的显示宽度 readonly readonly 该控件内容为只读（不能编辑修改） disabled disabled 第一次加载页面时禁用该控件（显示为灰色） 文本输入框12&lt;!-- 文本输入框 --&gt;用户名：&lt;input type=\"text\" maxlength=\"6\" name=\"username\" value=\"1234\" &gt; 效果演示：用户名： 属性: maxlength：设置文本输入框最多能输多少字符 readonly=”readonly”：设置文本输入框为只读（不能编辑） disabled+”disabled”：控件属于非激活状态 name=”username”：给输入框设置名称 value：设置默认显示的值 密码输入框12&lt;!-- 密码输入框 --&gt;密码：&lt;input type=\"password\" name=\"pwd\" value=\"123\"&gt; 效果演示：密码： 属性用法与文本输入框的用法一样。 单选按钮1234&lt;!-- 单选按钮 --&gt;性别：&lt;input type=\"radio\" name=\"xb\" checked=\"checked\" value=\"nan\"&gt;男&lt;input type=\"radio\" name=\"xb\" value=\"nv\" &gt;女 效果演示：性别：男 女 注意：实现单选效果一定要给控件设置相同的名称 属性： checked=”checked”：设置默认选中项 多选控件1234兴趣爱好：&lt;input type=\"checkbox\" checked=\"checked\"&gt;抽烟&lt;input type=\"checkbox\" checked=\"checked\"&gt;喝酒&lt;input type=\"checkbox\" checked=\"checked\"&gt;烫头 效果演示：兴趣爱好：抽烟喝酒烫头 属性： checked=”checked”：设置默认选中项 图片上传控件12头像：&lt;input type=\"file\"&gt; 效果演示：头像： 表单提交按钮12&lt;!-- 表单提交按钮 --&gt;&lt;input type=\"submit\" value=\"登录\"&gt; 效果演示： 普通按钮12&lt;!-- 普通按钮 --&gt;&lt;input type=\"button\" value=\"普通按钮\"&gt; 效果演示： 注意：该按钮不能进行表单提交。通常和 js 代码配合使用。 重置按钮清空所有表单数据，恢复到初始状态12&lt;!-- 重置按钮 --&gt;&lt;input type=\"reset\"&gt; 效果演示： 图片按钮12&lt;!-- 图片按钮 --&gt;&lt;input type=\"image\" src=\"按钮.jpg\"&gt; 注意：该控件也可以进行表单的提交。 select 控件在 HTML 中，要想制作下拉菜单，就需要使用select控件。 下拉列表123456789出生地：省：&lt;select multiple=\"multiple\"&gt; &lt;option&gt;山东&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;option&gt;河南&lt;/option&gt; &lt;option&gt;河北&lt;/option&gt; &lt;option selected=\"selected\"&gt;北京&lt;/option&gt;&lt;/select&gt; 效果演示：出生地：省： 山东 山西 河南 河北 北京 属性： selected=”selected”：设置默认选中项 multiple=”multiple”：可以实现多选效果 下拉列表分组显示123456789101112131415市(区)：&lt;select id=\"name\"&gt; &lt;optgroup label=\"北京市\"&gt; &lt;option&gt;西城区 &lt;/option&gt; &lt;option&gt;东城区&lt;/option&gt; &lt;option&gt;海淀区&lt;/option&gt; &lt;option&gt;昌平区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"上海市\"&gt; &lt;option&gt;黄浦区 &lt;/option&gt; &lt;option&gt;松江区&lt;/option&gt; &lt;option&gt;浦东新区&lt;/option&gt; &lt;option&gt;静安区&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 效果演示：市(区)： 西城区 东城区 海淀区 昌平区 黄浦区 松江区 浦东新区 静安区 textarea 控件如果需要输入大量的信息，就需要用到 &lt;textarea&gt;&lt;/textarea&gt; 标记。通过 textarea 控件可以轻松地创建多行文本输入框，其基本语法格式如下：123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 文本内容&lt;/textarea&gt; 属性： cols：相当于宽度 rows：相当于高度 123自我介绍：&lt;textarea cols=\"20\" rows=\"5\"&gt;&lt;/textarea&gt; 效果演示：自我介绍： 组合表单fieldset 用于表单分组。语法：123&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt;&lt;/fieldset&gt; 举例：1234567&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; 用户名：&lt;input type=\"text\" maxlength=\"6\" name=\"username\" value=\"\" &gt; &lt;br&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"pwd\" value=\"123\"&gt;&lt;/fieldset&gt; 效果演示： 用户注册 用户名： 密码： 表单补充判断网址123&lt;!-- 判断网址 --&gt;&lt;input type=\"url\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 判断邮箱123&lt;!-- 判断邮箱 --&gt;&lt;input type=\"email\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 日期控件123&lt;!-- 日期控件 --&gt;&lt;input type=\"date\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 时间控件123&lt;!-- 时间控件 --&gt;&lt;input type=\"time\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 带有 spinner 控件的数字字段123&lt;!-- 带有 spinner 控件的数字字段 --&gt;&lt;input type=\"number\"&gt;&lt;input type=\"submit\"&gt; 属性： step：表示每次加减的值（即步长） 效果演示： 带有 slider 控件的数字字段123&lt;!-- 带有 slider 控件的数字字段 --&gt;&lt;input type=\"range\"&gt;&lt;input type=\"submit\"&gt; 属性： max：最大值 min：最小值 step：每次加减的值（即步长） 效果演示： 定义拾色器123&lt;!-- 定义拾色器 --&gt;&lt;input type=\"color\"&gt;&lt;input type=\"submit\"&gt; 效果演示： 标签语义化 标签语义化概念： 根据内容的结构化（内容语义化），选择合适的标签（代码语义化） 标签语义化意义： 1: 网页结构合理 2: 有利于 SEO :和搜索引擎建立良好沟通，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取； 3: 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）; 4: 便于团队开发和维护. 标签语义化（注意事项） 1：尽可能少的使用无语义的标签 div 和 span ； 2：在语义不明显时，既可以使用 div 或者 p 时，尽量用 p, 因为 p 在默认情况下有上下间距，对兼容特殊终端有利； 3：不要使用纯样式标签，如：b、font、u 等，改用 css 设置。 4：需要强调的文本，可以包含在 strong 或者 em 标签中。strong 默认样式是加粗（不要用b），em 是斜体（不用 i ）； 总结我的 html 基础学习是跟着传智播客2016年的视频课程学习的，基础就这些内容，特别整理下来以加深记忆。内容或多或少会与网络上的内容有些许出入。总的来说 html 很简单，很容易上手。但这只是基础，html + css + javascript 才能做出真正漂亮的网页。 千里之行，始于足下，接下来的路，加油！","categories":[{"name":"HTML+CSS+JS","slug":"HTML-CSS-JS","permalink":"http://yoursite.com/categories/HTML-CSS-JS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"观建军90周年阅兵之感悟","slug":"view-of-army-building-90th","date":"2017-07-30T05:45:20.000Z","updated":"2018-08-10T06:23:24.014Z","comments":true,"path":"view-of-army-building-90th.html","link":"","permalink":"http://yoursite.com/view-of-army-building-90th.html","excerpt":"恰逢 中国人民解放军建军 90 周年 ，下一个百年会是什么样的盛况？十年后的今天，肯定特别隆重，中国军队更加现代化，中国的综合实力更加强胜。2017 年 7 月 30 日，一个小阅兵式，不比 2015 年的 9.3 阅兵，但也足以展示中国军队的强势！","text":"恰逢 中国人民解放军建军 90 周年 ，下一个百年会是什么样的盛况？十年后的今天，肯定特别隆重，中国军队更加现代化，中国的综合实力更加强胜。2017 年 7 月 30 日，一个小阅兵式，不比 2015 年的 9.3 阅兵，但也足以展示中国军队的强势！ 2017 年 7 月 30 日 9 时，在朱日和训练基地隆重举行了庆祝建军 90 周年阅兵式。中共中央总书记、国家主席、中央军委主席习近平检阅部队并发表重要讲话。 政治觉悟强、思想素质高的我专门观看了这场直播。看的真是个热血沸腾！尤其是国歌响起的时候，看到我们的军队气势如虹，中国已经不是以前的模样了！她那么年轻，又那么富有活力，最重要的是有一群铁骨铮铮的人的在守卫着她的每一寸土地和国民。 从 1927 到 2017 ，中国军队走过了漫长的岁月，中国军队日益强大。车牌 1927 和 2017 相互对接，是一种历史的传承。 《国歌》 国歌响起的刹那，热泪盈眶。每一个中国人都熟悉的一首歌，竟这样好听。习大大在主席台上也跟着音乐在哼唱着。 《检阅进行曲》 习大大身着迷彩登上车牌 2017 的野战车的时候，《检阅进行曲》响起，一排排列队整齐的军队，一辆辆现代化的作战车辆，一架架直升机、空中梯队，严阵以待，等待着党和人民的检阅。 《分列式进行曲》 这就是我们的军队，这是人民的军队。 时至今日，兔子们已经把种花家变成了蓝星最牛的堂口之一，他走过骨血硝烟，走过繁花似锦，曾跌入泥潭，也能踏上云端。 每一只兔子都有一个大国梦。今生不悔入华夏，来世还愿种花家。 『 幸福并感激着！ 』","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"Chrome 浏览器设置 XX-Net 的方法（Windows）","slug":"method-setup-XX-Net-Chrome-Windows","date":"2017-07-27T02:11:01.000Z","updated":"2017-08-26T13:40:25.860Z","comments":true,"path":"method-setup-XX-Net-Chrome-Windows.html","link":"","permalink":"http://yoursite.com/method-setup-XX-Net-Chrome-Windows.html","excerpt":"本文详细介绍如何在一台 Windows 电脑上架设起 Chrome + XX-Net 的上网渠道。XX-Net 对于需要翻墙的用户来说非常方便。尤其是配置了自己的私有 appid 后，浏览外网毫无压力。在整个部署过程中可能有部分网页需要翻墙才可以进入，可以暂时使用 Lantern 进行翻墙。Lantern 下载地址：&nbsp;&nbsp;Download Now","text":"本文详细介绍如何在一台 Windows 电脑上架设起 Chrome + XX-Net 的上网渠道。XX-Net 对于需要翻墙的用户来说非常方便。尤其是配置了自己的私有 appid 后，浏览外网毫无压力。在整个部署过程中可能有部分网页需要翻墙才可以进入，可以暂时使用 Lantern 进行翻墙。Lantern 下载地址：&nbsp;&nbsp;Download Now 下载安装 Chrome 浏览器 Chrome 下载地址：https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html这一步很简单，直接跳过。 获取和运行 XX-Net 打开链接，选择稳定版下载。https://github.com/XX-net/XX-Net/blob/master/code/default/download.md 下载完毕后解压缩文件夹，运行文件夹中 start.vbs 文件。 如果弹出管理员权限请求（用户账户控制），请允许。 首次运行可能会弹出防火墙警告，请允许访问。 设置代理方法一：简单方法 启动 XX-Net 后，右下角会出现托盘图标。右键单击托盘图标，点击“全局 PAC 智能代理”即可。 方法二：安装和使用代理切换插件 打开 XX-Net/SwitchyOmega 文件夹；打开 Chrome 浏览器的扩展程序页面 chrome://extensions 。把 SwitchyOmega.crx 文件拖放到浏览器扩展程序页面安装。如图: 此时。浏览器上方会出现对话框，点击添加扩展程序。 进入 SwitchOmega 页面，第一次进来，选择跳过教程； 点击界面左侧栏的导入/导出，选择从备份文件恢复： 点击从备份文件中恢复后，找到 XX-Net/SwitchyOmega/OmegaOptions.bak 文件，点击打开： 点击左侧栏“情景模式”下的 XX-Net自动切换； 下拉点击立即更新情景模式 点击 Chrome 右上角的 SwitchOmega，切换成 “XX-Net自动切换”； 到此，浏览器端设置代理也就完成了，还需最后一步，把 XX-Net 切换为“取消全局代理”，就可以畅游网络了。 但是此时用的是 公共 APPID，因为资源有限，使用上存在限制，建议部署私有 APPID。 配置个人 APPID登录 Google 账户 https://www.google.com/ncr (若无帐户，需注册) 创建 APPID 打开 https://console.cloud.google.com/start ，点击选择项目，然后点击创建项目： 输入项目名称后，会自动帮你匹配可用ID，然后左击创建(请细读此教程底部说明) 设置 APPID 的 App 引擎 点击激活 Google云端Shell，点击启动云端SHELL进入Shell； 在页面底部输入 gcloud config set project 项目ID,按下键盘的enter键； 然后输入 gcloud beta app create --region us-central ，再按一次enter； 当底部出现 Success! The app is now created. Please use &#39;gcloud app deploy&#39; to deploy your first app. 时，创建 appid 成功。此时可以重复前面两步，创建更多的 appid； 部署服务器端 打开 XX-Net 的设置页：http://127.0.0.1:8085 ，切换到部署服务端； 输入AppID（多个APPID中间使用 | 隔开），“Show Debug Log”选择为 On ，点击 开始部署 ； 弹出授权窗口，点击 Allow（允许），然后就会进行服务端的部署； 日志 里面显示如下信息，则说明部署完成； 部署完成后，切换到 配置 ，输入部署好的 APPID 后点击 保存。 切换到 状态 来确认部署的状态，如果一切正常，那么恭喜你，现在可以流畅的翻墙喽~~~ 说明 每个 AppID 每天1G流量，一般每个 Google 帐户最多12个 AppID； AppID 的数量只影响流量，不影响速度； 若部署过程中始终无法弹出窗口 , 建议使用ss部署服务端； 若部署一直失败，可以安装 Google Cloud SDK，gcloud init 设置代理，gcloud app deploy 上传 gae 文件夹，在 app.yaml 中不要指定 application 和 version。","categories":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"},{"name":"XX-Net","slug":"XX-Net","permalink":"http://yoursite.com/tags/XX-Net/"}]},{"title":"ArcGIS Engine 地图操作基础——地图文档保存","slug":"ArcGIS-Engine-map-basic-save-documents","date":"2017-06-13T13:15:30.000Z","updated":"2017-08-24T05:55:16.087Z","comments":true,"path":"ArcGIS-Engine-map-basic-save-documents.html","link":"","permalink":"http://yoursite.com/ArcGIS-Engine-map-basic-save-documents.html","excerpt":"在对地图文档进行修改后，经常需要对其进行保存。地图文档的保存分为直接保存和另存为两种。这里的保存仅仅只是修改地图文档文件记录的信息，并不会对数据进行更改。保存地图文档的一般格式是 *.mxd 格式。","text":"在对地图文档进行修改后，经常需要对其进行保存。地图文档的保存分为直接保存和另存为两种。这里的保存仅仅只是修改地图文档文件记录的信息，并不会对数据进行更改。保存地图文档的一般格式是 *.mxd 格式。 地图文档保存实例程序实现思路 (1) 地图文档的保存主要使用 IMapDocument 接口。首先使用 IMxdContents 接口读取已打开地图文档的内容，并使之替换 IMapDocument 接口的实例对象。 (2) 保存时使用 IMapDocument 接口的 Save 方法，函数原型为 public void Save(bool bUseRelativePaths, bool bCreateThumnbail) 参数 描述 bUseRelativePaths 是否保存为相对路径（区别于绝对路径） bCreateThumnbail 表示保存的地图在 ArcCatalog 中查看时是否显示缩略图 1234567891011121314151617181920212223242526272829303132333435363738394041424344//保存地图private void SaveMap_Click(object sender, EventArgs e)&#123; try &#123; string sMxdFileName = mainMapControl.DocumentFilename; IMapDocument pMapDocument = new MapDocumentClass(); if (sMxdFileName!=null &amp;&amp; mainMapControl.CheckMxFile(sMxdFileName)) &#123; if (pMapDocument.get_IsReadOnly(sMxdFileName)) &#123; MessageBox.Show(\"本地图文档是只读的，不能保存!\"); pMapDocument.Close(); return; &#125; &#125; else &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = \"请选择保存路径\"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = \"ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt\"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; sMxdFileName = pSaveFileDialog.FileName; &#125; else &#123; return; &#125; &#125; pMapDocument.New(sMxdFileName); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(pMapDocument.UsesRelativePaths, true); pMapDocument.Close(); MessageBox.Show(\"保存地图文档成功!\"); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125;&#125; 地图文档另存为实例程序实现思路 (1) 地图文档的另存为与保存的方法类似，保存前需判断保存的路径里是否存在相同的文件； (2) 另存为需要用 IMapDocument 接口的 New 方法创建新的路径。 123456789101112131415161718192021222324252627282930//地图另存为private void btnSaveAsMap_Click(object sender, EventArgs e)&#123; try &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = \"另存为\"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = \"ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt\"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; string sFilePath = pSaveFileDialog.FileName; IMapDocument pMapDocument = new MapDocumentClass(); pMapDocument.New(sFilePath); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(true, true); pMapDocument.Close(); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; //也可以使用 ArcGIS Engine 中封装好的类库资源 ControlsSaveAsDocCommandClass 实现地图文档的另存为： //ICommand command = new ControlsSaveAsDocCommandClass(); //command.OnCreate(mainMapControl.Object); //command.OnClick();&#125;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"Hexo+Github 搭建个人博客（小白版图文教程）","slug":"Hexo-Github-build-blog-so-easy","date":"2017-06-09T15:13:15.000Z","updated":"2017-11-20T02:33:27.406Z","comments":true,"path":"Hexo-Github-build-blog-so-easy.html","link":"","permalink":"http://yoursite.com/Hexo-Github-build-blog-so-easy.html","excerpt":"本人技术小白，折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了个人博客。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。有过经历，才知道好的教程的重要性。因而我将自己的经验分享出来~","text":"本人技术小白，折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了个人博客。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。有过经历，才知道好的教程的重要性。因而我将自己的经验分享出来~ 写在前面最近兴趣使然，想要搭建一个个人博客。每次看到别人拥有自己的个人主页都特别羡慕，一直想着自己有一个博客该有多好啊。就这样折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。由于自己是技术小白，很多大神写的教程看了依旧操作错误。多么希望有人能手把手的教你每一步做什么。有过经历，才知道好的教程的重要性。因而我将自己建站的步骤详细记录下来，以供参考。希望后面想要建站的人不要走弯路了哦~ 搭建环境配置 Node.js 环境下载 Node.js 安装文件，根据自己电脑的位数，选择下载32位或者64位的：http://nodejs.cn/download/然后安装下载的文件，保持默认设置就好了，一路点 Next ，很快就安装完成了。接着检查一下 Node 是否安装好，打开运行窗口，输入 cmd ，打开命令行： 在命令行分别输入以下命令：12node -vnpm -v 如果出现下图界面，则说明 node 安装正确。可以进入下一步了。 配置 Git 环境去官网下载 Git 安装文件: https://git-scm.com/downloads 接着进行安装，如下图，在 Windows Explorer integration 这一项及下边的两项都打上勾： 然后一直 Next 就可以了，安装完成后同样检查一下 Git 是否正确安装。 Github账户的注册和代码库的创建Github帐号注册，打开链接：https://github.com/，申请一个 Github 帐号；注册好之后还需要确认邮箱，打开注册的邮箱，确认注册，然后进入下一步；点击页面右上角自己的头像，点击下拉菜单的New repository，创建一个新的代码库：代码库的名字最好与你的用户名相同，格式为 yourname.github.io ，比如我的用户名是 renkaitest，那我的代码库名即为 renkaitest.github.io创建成功后出现下图所示界面，点击右边的复制按钮，复制这个地址： 配置 Github pages随便找一个目录，右击鼠标，选择Git Bash Here，打开一个类似命令行的界面，输入以下代码：1$ git clone https://github.com/username/username.github.io clone 后面的链接即就是上一步复制的那个链接，比如我的就是下面的代码： 1$ git clone https://github.com/renkaitest/renkaitest.github.io 然后输入 cd 你的代码库名 ，例如 cd renkaitest.github.io ，也可以直接进入该目录下的一个名为 renkaitest.github.io 的文件夹。1$ cd renkaitest.github.io 然后输入： 1$ echo \"Hello World\" &gt; index.html 接着输入：12$ git add --all$ git commit -m \"Initial commit\" 这里会出现一个错误，是因为我们没有设置Git的 user name 和 email ，此时输入以下代码： 12$ git config --global user.email \"541638321@qq.com\"$ git config --global user.name \"renkaitest\" 注意：上面的 name 和 email 都要换成自己的邮箱和用户名 此时继续执行以下代码： 1$ git commit -m \"Initial commit\" 下面 push 到你的代码库，输入代码：1$ git push -u origin master 可能会弹出以下界面让你登录，使用 Github 帐号登录即可。 此时你的 Github Pages 已经配置好了，打开 yourname.github,io 这个网址就能看到你的博客了，yourname 替换成你自己的用户名。 Hexo安装找一个目录，我是在 d:\\Hexo 目录下，鼠标右击打开 Git Bash Here，输入：1$ npm install hexo-cli -g 可能会看到一个 WARN，但是没关系的，进入下一步。输入：1$ npm install hexo --save 等一段时间，他安装完之后检查一下是否安装成功，输入： 1$ hexo -v 看到相关的版本信息则说明安装成功。 Hexo配置初始化 Hexo，首先需要找一个目录，这个目录即就是你的博客的所有文件存放的目录，最好路径不要太深，我选择的是 D:\\Hexo\\blog 。在这个路径下打开 Git Bash Here ，输入代码：1$ hexo init 然后输入：1$ npm install 这里 npm 会自动帮你安装你需要的组件。继续输入：1$ hexo g 生成博客。输入：1$ hexo s 启动服务，会提示以下信息：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器打开 http://localhost:4000/ ，将会看到自己的 hexo 博客： 关联 Hexo 与 Github Page配置Git个人信息如果你之前已经配置好git个人信息，请跳过这一个步骤，直接来到步骤2设置Git的user name和email：（如果是第一次的话）12$ git config --global user.name \"renkaitset\"$ git config --global user.email \"541638321@qq.com\" 生成密钥1$ ssh-keygen -t rsa -C \"541638321@qq.com\" 输入代码后一直按回车就好了，不用自己定义目录，生成的 ssh 会存放在 C:\\Users\\用户名\\.ssh 目录下，如果找不到 .ssh 目录，请在文件夹选项中显示隐藏的项目。 配置 SSH 密匙进入 Github 网页，点击右上角自己的头像，选择 Settings ：配置 SSH and GPG keys ，点击 New SSH key：用 txt 打开刚才生成的 Key，复制到下图所示区域，点击 Add SSH key： 配置 Deployment打开博客目录下的站点配置文件 _config.yml ，比如我的博客目录是 D:\\Hexo\\blog，找到该目录下的 _config.yml。打开他，在最末尾找到 Deployment ，然后按照如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 上面的 yourname 都要替换成自己的用户名，以我的为例：1234deploy: type: git repo: git@github.com:renkaitest/renkaitest.github.io.git branch: master 这样就配置好了，接下来就可以写博客了。 发布博文新建一篇博文，在博客存放的目录里面 Git Bash Here ，执行命令：1$ hexo new post \"我的第一篇博文\" 然后就会在电脑的目录下 D:\\Hexo\\blog\\source\\_posts 看到一个 我的第一篇博文.md 文件，使用 MarkDown 编辑这篇文章就可以了。文章编辑好后，运行生成、部署命令。但是此时还缺少一个扩展，因而不能部署，先要执行以下命令：1$ npm install hexo-deployer-git --save 如果没有执行这个命令，将会提醒： deloyer not found:git 现在开始执行：12$ hexo g // 生成$ hexo d // 部署 也可以将这两个命令一起执行：1$ hexo d -g //在部署前先生成 若出现如下图所示的信息 INFO Deploy done: git ，则表示部署成功，已经上传到你的代码库。此时访问你的地址 https://yourname.github.io ，将会看到刚才写的文章了。注：我的主题是自己换过的，可能与你的显示结果有所不同，做到这一步，你已经成功搭建了自己的博客。已经大功告成了！恭喜你~ 总结以后发布博文，就是以下的步骤： 写博文： 1$ hexo new post \"博文名字\" 生成博文： 1$ hexo g 部署博文： 1$ hexo d 由于网络原因，进入你的网页可能不会立即显示最新的信息。过几分钟就好了~","categories":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"},{"name":"Hexo","slug":"Github/Hexo","permalink":"http://yoursite.com/categories/Github/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]},{"title":"ArcGIS Engine 地图操作基础——数据加载","slug":"ArcGIS-Engine-map-basic-load-data","date":"2017-06-05T04:47:44.000Z","updated":"2017-06-13T14:27:20.221Z","comments":true,"path":"ArcGIS-Engine-map-basic-load-data.html","link":"","permalink":"http://yoursite.com/ArcGIS-Engine-map-basic-load-data.html","excerpt":"数据加载是 ArcGIS Engine 中最基础的操作，AE 支持的数据广泛，包含矢量数据、栅格数据、CAD 数据、Excel数据等等，这些数据的加载有助于我们使用 AE 做进一步的数据处理与分析。","text":"数据加载是 ArcGIS Engine 中最基础的操作，AE 支持的数据广泛，包含矢量数据、栅格数据、CAD 数据、Excel数据等等，这些数据的加载有助于我们使用 AE 做进一步的数据处理与分析。 加载地图文档地图文档可以是一个ArcMap文档（*.mxd）或者ArcMap模版（*.mxt）或ArcReader文件（*.pmf）。 加载地图文档的方式有三种： 使用 IMapControl 接口的 LoadMxFile 方法加载； 通过 IMapDocument 接口加载; 使用 ArcGIS Engine 中封装好的类库资源 ControlsOpenDocCommandClass 加载。 LoadMxFile 方法加载地图文档文件1234567891011121314151617181920212223242526272829303132333435private void BtnLoadMxFile_Click(object sender, EventArgs e)&#123; //加载数据前如果有数据则清空 try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开地图文档\"; pOpenFileDialog.Filter = \"ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf\"; pOpenFileDialog.Multiselect = false; //不允许多个文件同时选择 pOpenFileDialog.RestoreDirectory = true; //存储打开的文件路径 if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == \"\") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; ClearAllData(); mainMapControl.LoadMxFile(pFileName); &#125; else &#123; MessageBox.Show(pFileName + \"是无效的地图文档!\", \"信息提示\"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(\"打开地图文档失败\" + ex.Message); &#125;&#125; 关于 ClearAllData 函数: 1234567891011121314151617private void ClearAllData()&#123; if (mainMapControl.Map != null &amp;&amp; mainMapControl.Map.LayerCount &gt; 0) &#123; //新建mainMapControl中Map IMap dataMap = new MapClass(); dataMap.Name = \"Map\"; mainMapControl.DocumentFilename = string.Empty; mainMapControl.Map = dataMap; //新建EagleEyeMapControl中Map IMap eagleEyeMap = new MapClass(); eagleEyeMap.Name = \"eagleEyeMap\"; EagleEyeMapControl.DocumentFilename = string.Empty; EagleEyeMapControl.Map = eagleEyeMap; &#125;&#125; IMapDocument 方法加载 Mxd 文档文件123456789101112131415161718192021222324252627282930313233343536373839private void BtnIMapDocument_Click(object sender, EventArgs e)&#123; try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开地图文档\"; pOpenFileDialog.Filter = \"ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf\"; pOpenFileDialog.Multiselect = false; pOpenFileDialog.RestoreDirectory = true; if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == \"\") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; //将数据载入pMapDocument并与Map控件关联 IMapDocument pMapDocument = new MapDocument();//using ESRI.ArcGIS.Carto; pMapDocument.Open(pFileName, \"\"); //获取Map中激活的地图文档 mainMapControl.Map = pMapDocument.ActiveView.FocusMap; mainMapControl.ActiveView.Refresh(); &#125; else &#123; MessageBox.Show(pFileName + \"是无效的地图文档!\", \"信息提示\"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(\"打开地图文档失败\" + ex.Message); &#125;&#125; ControlsOpenDocCommandClass 加载地图123456private void BtncontrolsOpenDocCommandClass_Click(object sender, EventArgs e)&#123; ICommand command = new ControlsOpenDocCommandClass(); command.OnCreate(mainMapControl.Object); command.OnClick();&#125; 加载 Shapefile 数据加载 Shapefile 数据的方式有两种： 通过工作空间加载； 通过 MapControl 空间的 AddShapefile 方法加载 通过工作空间加载实例程序实现思路： (1) 创建 ShapefileWorkspaceFactory 实例 pWorkspaceFactory ，使用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 pFeatureWorkspace 中存储的基于 Shapefile 的工作区。 (2) 创建 FeatureLayer 的实例 pFeatureLayer ，并定义数据集。 (3) 使用 IMap 接口的 AddLayer 方法加载 pFeatureLayer 到当前地图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void AddShp_Click(object sender, EventArgs e)&#123; //ClearAllData(); try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Shape文件\"; pOpenFileDialog.Filter = \"Shape文件（*.shp）|*.shp\"; pOpenFileDialog.ShowDialog(); ////获取文件路径,此即为第二种方法 //FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName); //string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); //mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 获取文件路径 IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") return; int pIndex = pFullPath.LastIndexOf(\"\\\\\"); //lastIndexOf是从字符串末尾开始检索，检索到子字符，则返回子字符在字符串中的位置，（位置从前向后数，最小位为0，也就是从第0位开始算起）未检测到则返回-1。 string pFilePath = pFullPath.Substring(0, pIndex); //文件路径 string pFileName = pFullPath.Substring(pIndex + 1); //文件名 /*substring(参数)是java中截取字符串的一个方法 有两种传参方式 一种是 public String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 另一种是 public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 */ //实例化ShapefileWorkspaceFactory工作空间，打开Shape文件 pWorkspaceFactory = new ShapefileWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //创建并实例化要素集 IFeatureClass pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName); pFeatureLayer = new FeatureLayer(); pFeatureLayer.FeatureClass = pFeatureClass; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName;//获取别名 ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer);//加载图层 mainMapControl.ActiveView.Refresh(); //同步鹰眼.可有可无 SynchronizeEagleEye(); &#125; catch (Exception ex) &#123; MessageBox.Show(\"图层加载失败！\" + ex.Message); &#125;&#125; 通过 MapControl 空间的 AddShapefile 方法加载 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。 1234567891011121314private void AddShp2_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Shape文件\"; pOpenFileDialog.Filter = \"Shape文件（*.shp）|*.shp\"; pOpenFileDialog.ShowDialog(); //获取文件路径 FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName);//FileInfo需要using system.IO string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。&#125; 加载栅格数据实例程序实现思路： 在加载栅格文件时，需引用 ESRI.ArcGIS.DataSourcesRaster 命名空间。 (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得栅格文件的工作区； (2) 用 IRasterWorkspace 接口的 OpenRasterDataset 方法获得栅格文件的数据集，实例化栅格文件对象，并对栅格数据集是否具有金字塔进行判断（这里栅格文件如果不具有金字塔则创建金字塔，可以提高大数据量图像的显示效率）； (3) 创建 RasterLayer 类的实例 pRasterLayer ，并定义其数据集； (4) 使用 MapControl 控件的 AllLayer 方法将 pRasterLayer 添加至当前地图。 123456789101112131415161718192021222324252627282930313233343536373839private void AddRaster_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = \"打开Raster文件\"; pOpenFileDialog.Filter = \"栅格文件 (*.*)|*.bmp;*.tif;*.jpg;*.img|(*.bmp)|*.bmp|(*.tif)|*.tif|(*.jpg)|*.jpg|(*.img)|*.img\"; pOpenFileDialog.ShowDialog(); string pRasterFileName = pOpenFileDialog.FileName; if (pRasterFileName == \"\") &#123; return; &#125; string pPath = System.IO.Path.GetDirectoryName(pRasterFileName); string pFileName = System.IO.Path.GetFileName(pRasterFileName); IWorkspaceFactory pWorkspaceFactory = new RasterWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(pPath, 0); IRasterWorkspace pRasterWorkspace = pWorkspace as IRasterWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pFileName); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRaster pRaster; pRaster = pRasterDataset.CreateDefaultRaster(); IRasterLayer pRasterLayer; pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromRaster(pRaster); mainMapControl.Map.AddLayer(pLayer);//加载shp文件时是这样弄得，经过尝试这样也是可以的，具体有什么区别不可知 //mainMapControl.AddLayer(pLayer, 0);//这是书上的源代码&#125; 加载 CAD 数据对于 ArcGIS Engine 来说，有两种不同的方式使用 CAD 数据：① 作为要素图层，以矢量数据来使用；② 作为地图背景，以栅格数据来使用。对于前者， ArcGIS Engine 使用与 FeatureLayer 一样的方法来管理，对于后者则采用 CadLayer 对象来管理。 CAD 文件作为矢量图层加载分图层加载实例程序实现思路： (1) CAD 图可以分为点、线、面、标注，它们可以分别被加载到 MapControl 中。与加载其他数据一样，首先定义一个工作空间，用 CadWorkspaceFactoryClass 实例化工作空间，并打开相应的工作空间； (2) 创建 FeatureLayer 的实例，定义数据集，使用 IMap 接口的 AddLayer 方法将要素图层添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435363738394041private void AddCADByLayer_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureClass pFeatureClass; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pWorkspaceFactory = new CadWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //加载CAD文件中的线文件 pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":polyline\"); //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":polygon\");//打开多边形 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":point\");//打开点 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":multipatch\");//打开多面体 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + \":annotation\");//打开标注是这样吗？自己尝试失败，打开的是点，什么鬼？搞不懂。。。 pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFileName; pFeatureLayer.FeatureClass = pFeatureClass; ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer); mainMapControl.ActiveView.Refresh(); //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; 整幅图加载实例程序实现思路： 将 CAD 作为整幅图加载时，在得到相应的工作空间之后对 CAD 文件中的要素进行遍历，并判断是否为注记图层，如果是注记则需要使用 CadAnnotationLayer 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void AddWholeCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureDataset pFeatureDataset; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); //打开CAD数据集 pWorkspaceFactory = new CadWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesFile; pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //打开一个要素集 pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pFileName); //IFeatureClassContainer可以管理IFeatureDataset中的每个要素类 IFeatureClassContainer pFeatClassContainer = (IFeatureClassContainer)pFeatureDataset; ClearAllData(); //新增删除数据 //对CAD文件中的要素进行遍历处理 for (int i = 0; i &lt; pFeatClassContainer.ClassCount; i++) &#123; IFeatureClass pFeatClass = pFeatClassContainer.get_Class(i); //如果是注记，则添加注记层 if (pFeatClass.FeatureType == esriFeatureType.esriFTCoverageAnnotation) &#123; pFeatureLayer = new CadAnnotationLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; else //如果是点、线、面则添加要素层 &#123; pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; mainMapControl.ActiveView.Refresh(); &#125; //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; CAD 文件作为栅格图层加载实例程序实现思路： (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得 CAD 文件的工作区； (2) 用 ICadDrawingWorkspace 接口的 OpenCadDrawingDataset 方法获得 CAD 文件的数据集，并将其赋值给 CadLayerClass 类的实例对象 pCadLayer 的 CadDrawingDataset 属性； (3) 使用 IMap 接口的 AddLayer 方法将 pCadLayer 添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435private void AddRasterByCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pCadWorkspaceFactory; IWorkspace pWorkspace; ICadDrawingWorkspace pCadDrawingWorkspace; ICadDrawingDataset pCadDrawingDataset; ICadLayer pCadLayer; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"CAD(*.dwg)|*.dwg\"; pOpenFileDialog.Title = \"打开CAD数据文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf(\"\\\\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pCadWorkspaceFactory = new CadWorkspaceFactoryClass(); pWorkspace = pCadWorkspaceFactory.OpenFromFile(pFilePath, 0); pCadDrawingWorkspace = (ICadDrawingWorkspace)pWorkspace; //获得CAD文件的数据集 pCadDrawingDataset = pCadDrawingWorkspace.OpenCadDrawingDataset(pFileName); pCadLayer = new CadLayerClass(); pCadLayer.CadDrawingDataset = pCadDrawingDataset; pCadLayer.Name = pFileName;//书中代码没有这一句，打开的结果是TOC面板里面没有文件的名字，故而自己添上了这一句 mainMapControl.Map.AddLayer(pCadLayer); mainMapControl.ActiveView.Refresh();&#125; 加载个人地理数据库个人地理数据库（Personal Geodatabase）使用 Micorosoft Access 文件（*.mdb）进行空间数据的存储与管理，它将不同的数据同一纳入 Access 文件中，便于数据的管理与迁移，容量限制为2GB。个人地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 创建 AccessWorkspaceFactory 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 *.mdb 数据集的工作空间，对工作空间里面的数据进行加载。 1234567891011121314151617181920212223private void AddPersonGDB_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pAccessWorkspaceFactory; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = \"Personal Geodatabase(*.mdb)|*.mdb\"; pOpenFileDialog.Title = \"打开PersonGeodatabase文件\"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == \"\") &#123; return; &#125; pAccessWorkspaceFactory = new AccessWorkspaceFactory(); //using ESRI.ArcGIS.DataSourcesGDB; //获取工作空间 IWorkspace pWorkspace = pAccessWorkspaceFactory.OpenFromFile(pFullPath, 0); ClearAllData(); //新增删除数据 //加载工作空间里的数据 AddAllDataset(pWorkspace, mainMapControl);&#125; 这里对加载工作空间中数据的方法进行了封装，自定义了 AddAllDataset 函数，以便对其他空间数据库（文件地理数据库、ArcSDE 空间数据库）加载时可直接调用。 以上代码主要介绍矢量和栅格数据的加载（其实不止这两种数据格式，加载其他类型的数据也是采用相同的方法，只是采用不同的工作空间而已）。 自定义函数 AddAllDataset 核心代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// 加载工作空间里面的要素和栅格数据/// &lt;/summary&gt;/// &lt;param name=\"pWorkspace\"&gt;&lt;/param&gt;private void AddAllDataset(IWorkspace pWorkspace, AxMapControl mapControl)&#123; IEnumDataset pEnumDataset = pWorkspace.get_Datasets(ESRI.ArcGIS.Geodatabase.esriDatasetType.esriDTAny); pEnumDataset.Reset(); //将Enum数据集中的数据一个个读到DataSet中 IDataset pDataset = pEnumDataset.Next(); //判断数据集是否有数据 while (pDataset != null) &#123; if (pDataset is IFeatureDataset) //要素数据集 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureDataset pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pDataset.Name); IEnumDataset pEnumDataset1 = pFeatureDataset.Subsets; pEnumDataset1.Reset(); IGroupLayer pGroupLayer = new GroupLayerClass(); pGroupLayer.Name = pFeatureDataset.Name; IDataset pDataset1 = pEnumDataset1.Next(); while (pDataset1 != null) &#123; if (pDataset1 is IFeatureClass) //要素类 &#123; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset1.Name); if (pFeatureLayer.FeatureClass != null) &#123; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; pGroupLayer.Add(pFeatureLayer); mapControl.Map.AddLayer(pFeatureLayer); &#125; &#125; pDataset1 = pEnumDataset1.Next(); &#125; &#125; else if (pDataset is IFeatureClass) //要素类 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset.Name); pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; mapControl.Map.AddLayer(pFeatureLayer); &#125; else if (pDataset is IRasterDataset) //栅格数据集 &#123; IRasterWorkspaceEx pRasterWorkspace = (IRasterWorkspaceEx)pWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pDataset.Name); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRasterLayer pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromDataset(pRasterDataset); ILayer pLayer = pRasterLayer as ILayer; mapControl.AddLayer(pLayer, 0); &#125; pDataset = pEnumDataset.Next(); &#125; mapControl.ActiveView.Refresh(); //同步鹰眼 SynchronizeEagleEye();&#125; 加载文件地理数据库数据文件地理数据库（File Geodatabase）是以文件夹形式存储各种类型的 GIS 数据集，可以存储、查询和管理空间数据和非空间数据，支持的地理数据库的大小最大为 1 TB。文件地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 由于文件地理数据库是以文件夹的形式存在的，因此可以使用 FolderBrowserDialog 选择文件夹进行加载。首先创建 FileGDBWorkspaceFactoryClass 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开文件地理数据库的工作空间，对工作空间里面的数据进行加载。 12345678910111213141516171819202122#region 加载文件地理数据库数据private void AddFileDatabase_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pFileGDBWorkspaceFactory; FolderBrowserDialog dlg = new FolderBrowserDialog(); if (dlg.ShowDialog() != DialogResult.OK) return; string pFullPath = dlg.SelectedPath; if (pFullPath == \"\") &#123; return; &#125; pFileGDBWorkspaceFactory = new FileGDBWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesGDB; ClearAllData(); //新增删除数据 //获取工作空间 IWorkspace pWorkspace = pFileGDBWorkspaceFactory.OpenFromFile(pFullPath, 0); AddAllDataset(pWorkspace, mainMapControl);&#125;#endregion 加载 ArcSDE 空间数据库数据ArcSDE（Spatial Database Engine，空间搜索引擎）是在现有的关系型数据库上进行的空间扩展，它使空间数据能保存在关系数据库中（如 Oracle、SQLServer等）。ArcSDE 空间数据库的一个重要特点是支持多用户并发操作，并且可以通过版本来表现空间数据编辑的状态。 ArcSDE 的组成： ArcSDE 服务器管理进程负责维护 ArcSDE 和监听来自客户端的连接请求。ArcSDE 启动就是启动 ArcSDE 服务器管理进程，利用管理员账户管理 ArcSDE 与 RDBMS 的连接，处理客户端的连接请求。 专用服务器进程由 ArcSDE 服务器管理进程穿件，用于每一个特定的客户端应用程序与数据库的连接。 ArcSDE 客户端通过 ArcSDE 服务器管理进程和专用服务器进程建立和 RDBMS 的连接，实现对数据库的操作。 ArcSDE 提供了应用服务器连接和直接连接两种连接方式。当服务器性能较好时可采用应用服务器连接，否则采用直接连接。为了减轻服务器的压力，建议采用直接连接的方式进行连接。 两种连接方式的异同：直接连接就是通过 ArcSDE 访问数据表，并在本地完成对数据的各种操作（如空间分析、编辑等）；而应用服务器连接就是通过 ArcSDE 访问数据表后，在服务器端完成对数据的各种操作，再把操作结果返回客户端。 实例程序实现思路： (1) 创建 SDEWorksapceFactoryClass 类的实例； (2) 通过 SDE 连接的连接属性打开 SDE 数据库的工作空间，对工作空间里面的数据进行加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 这里以基于 Oracle 11g 的 ArcSDE 10.0 连接为例对两种连接方式进行说明。#region 加载 ArcSDE 数据库/// &lt;summary&gt;/// 服务器连接/// &lt;/summary&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"e\"&gt;&lt;/param&gt;private void AddSDEByService_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; pWorkspace = arcSDEWorkspaceOpen(\"192.168.70.110\", \"esri_sde\", \"sde\", \"sde\", \"\", \"SDE.DEFAULT\"); //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 直连/// &lt;/summary&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"e\"&gt;&lt;/param&gt;private void AddSDEByDirect_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 通过SDE连接打开SDE数据库/// &lt;/summary&gt;/// &lt;param name=\"server\"&gt;服务器IP&lt;/param&gt;/// &lt;param name=\"instance\"&gt;数据库实例，应用服务器连接为：5151或esri_sde，直连为sde:oracle11g:orcl(orcl为服务名)&lt;/param&gt;/// &lt;param name=\"user\"&gt;SDE用户名&lt;/param&gt;/// &lt;param name=\"password\"&gt;用户密码&lt;/param&gt;/// &lt;param name=\"database\"&gt;数据库&lt;/param&gt;/// &lt;param name=\"version\"&gt;SDE版本，缺省为\"SDE.DEFAULT\"&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private IWorkspace arcSDEWorkspaceOpen(string server, string instance, string user, string password, string database, string version)&#123; IWorkspace pWorkSpace = null; //创建和实例化数据集 IPropertySet pPropertySet = new PropertySetClass(); pPropertySet.SetProperty(\"SERVER\", server); pPropertySet.SetProperty(\"INSTANCE\", instance); pPropertySet.SetProperty(\"USER\", user); pPropertySet.SetProperty(\"PASSWORD\", password); pPropertySet.SetProperty(\"DATABASE\", database); pPropertySet.SetProperty(\"VERSION\", version); IWorkspaceFactory2 pWorkspaceFactory = new SdeWorkspaceFactoryClass(); try &#123; pWorkSpace = pWorkspaceFactory.Open(pPropertySet, 0); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; return pWorkSpace;&#125;#endregion 加载文本文件数据野外测量的数据通常为含有 X、Y 坐标的 Excel 文件或者文本文件。实例程序实现思路： (1) 根据 Excel 或者 *.txt 文件等获取点的坐标信息； (2) 根据点的坐标创建 Shapefile 图层； (3) 加载该 Shapefile 图层。 坐标信息的提取 (1) 创建一个点结构，进行点信息的存储。 123456struct CPoint&#123; public string Name; public double X; public double Y;&#125; (2) 创建并实例化一个 CPoint 类型的数组，将所有的点信息进行存储。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647List&lt;string&gt; pColumns = new List&lt;string&gt;();private List&lt;CPoint&gt; GetPoints(string surveyDataFullName)&#123; try &#123; List&lt;CPoint&gt; pList = new List&lt;CPoint&gt;(); char[] charArray = new char[] &#123; ',', ' ', '\\t' &#125;; //常用的分隔符为逗号、空格、制表符 //文本信息读取 FileStream fs = new FileStream(surveyDataFullName, FileMode.Open); StreamReader sr = new StreamReader(fs, Encoding.Default); string strLine = sr.ReadLine(); if (strLine != null) &#123; string[] strArray = strLine.Split(charArray); if (strArray.Length &gt; 0) &#123; for (int i = 0; i &lt; strArray.Length; i++) &#123; pColumns.Add(strArray[i]); &#125; &#125; while ((strLine= sr.ReadLine())!=null) &#123; //点信息的读取 strArray = strLine.Split(charArray); CPoint pCPoint = new CPoint(); pCPoint.Name = strArray[0].Trim(); pCPoint.X = Convert.ToDouble(strArray[1]); pCPoint.Y = Convert.ToDouble(strArray[2]); pList.Add(pCPoint); &#125; &#125; else &#123; return null; &#125; sr.Close(); return pList; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); return null; &#125;&#125; 根据点坐标创建 Shapefile 图层 (1) 创建表的工作空间，通过 IFields、IFieldsEdit、IField 等接口创建属性字段，添加到要素集中。 (2) 根据获得的点坐标信息为属性字段赋值，进而得到图层的要素集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private IFeatureLayer CreateShpFromPoints(List&lt;CPoint&gt; cPointList, string filePath)&#123; int index = filePath.LastIndexOf('\\\\'); string folder = filePath.Substring(0, index);//路径切分得到文件夹名 string shapeName = filePath.Substring(index + 1); //路径切分得到文件名 IWorkspaceFactory pWSF = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pFWS = (IFeatureWorkspace)pWSF.OpenFromFile(folder, 0); IFields pFields = new FieldsClass(); IFieldsEdit pFieldsEdit; pFieldsEdit = (IFieldsEdit)pFields; IField pField = new FieldClass(); IFieldEdit pFieldEdit = (IFieldEdit)pField; pFieldEdit.Name_2 = \"Shape\"; pFieldEdit.Type_2 = esriFieldType.esriFieldTypeGeometry; IGeometryDef pGeometryDef = new GeometryDefClass(); IGeometryDefEdit pGDefEdit = (IGeometryDefEdit)pGeometryDef; pGDefEdit.GeometryType_2 = esriGeometryType.esriGeometryPoint; //定义坐标系 ISpatialReferenceFactory pSRF = new SpatialReferenceEnvironmentClass(); ISpatialReference pSpatialReference = pSRF.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_Beijing1954); pGDefEdit.SpatialReference_2 = pSpatialReference; pFieldEdit.GeometryDef_2 = pGeometryDef; pFieldsEdit.AddField(pField); IFeatureClass pFeatureClass; pFeatureClass = pFWS.CreateFeatureClass(shapeName, pFields, null, null, esriFeatureType.esriFTSimple, \"Shape\", \"\"); IPoint pPoint = new PointClass(); for (int j = 0; j &lt; cPointList.Count; j++) &#123; pPoint.X = cPointList[j].X; pPoint.Y = cPointList[j].Y; IFeature pFeature = pFeatureClass.CreateFeature(); pFeature.Shape = pPoint; pFeature.Store(); &#125; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = shapeName; pFeatureLayer.FeatureClass = pFeatureClass; return pFeatureLayer;&#125; Shapefile 图层的加载1234567891011121314151617private void btnCreate_Click(object sender, EventArgs e)&#123; if (ValidateTxtbox()) &#123; List&lt;CPoint&gt; pCPointList = GetPoints(txtSource.Text); if (pCPointList == null) &#123; MessageBox.Show(\"所选文件为空，请重新选择！\"); &#125; else &#123; IFeatureLayer pFeatureLayer = CreateShpFromPoints(pCPointList, txtSave.Text); buddyMap.Map.AddLayer(pFeatureLayer); this.Close(); &#125; &#125;&#125; 总结根据上述 ArcGIS Engine 加载几种常用的数据源的方法，可以看出 ArcGIS Engine 加载空间数据一般具有以下五个步骤： 创建数据对应的工作空间工厂（WorkspaceFactory）； 使用 WorkspaceFactory 创建要加载数据的工作空间（Workspace）; 使用 Workspace 打开并得到图层的数据集 DataSet ; 将 DataSet 赋值给新建图层的数据源； 添加图层到 MapControl。","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://yoursite.com/tags/ArcGIS/"},{"name":"AE","slug":"AE","permalink":"http://yoursite.com/tags/AE/"}]},{"title":"2014年赴中科院安塞水土保持综合试验站三下乡视频","slug":"video-for-ansai-practical-activity","date":"2014-08-24T08:23:31.000Z","updated":"2018-08-10T07:13:04.596Z","comments":true,"path":"video-for-ansai-practical-activity.html","link":"","permalink":"http://yoursite.com/video-for-ansai-practical-activity.html","excerpt":"搬运旧时视频。","text":"搬运旧时视频。 配音：王亚利同学","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"时间都去哪了","slug":"i-love-dad-and-mom","date":"2014-03-01T03:55:24.000Z","updated":"2018-08-10T07:11:25.862Z","comments":true,"path":"i-love-dad-and-mom.html","link":"","permalink":"http://yoursite.com/i-love-dad-and-mom.html","excerpt":"搬运旧时文章。 以前太感性，太矫情。现在的我，更偏向于理性。但于父母，爱大于一切。 ——2017.08","text":"搬运旧时文章。 以前太感性，太矫情。现在的我，更偏向于理性。但于父母，爱大于一切。 ——2017.08 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间真的过得好快啊，眨眼，寒假就过完了，眨眼，我已是奔三的年纪。时间都去了哪儿，将我身边的人慢慢变老。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看着爸妈对我呵护备至，想起他们对我的一点一滴，再看到妈妈眼角的皱纹，我总是对自己说，我一定要对他们好，我一定不要再淘气了。因为我爱他们！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;妈妈总是要我隔三差五就给她打电话，因为她想我，她想我过得好不好，有没有生病，有没有什么不顺，只想和我说说话，就足够了。这便是爱，我们谁都不愿意说出口，但却能从只言片语中深切感受得到。我想，再也没有一个人像妈妈这样对我好的了，这世界上有妈妈在时刻想念着我，想念着他的儿子。我爱我的妈妈，但我不说出来，我能做到的就是不惹她生气，不给她添麻烦。去年暑假妈妈让我把一周岁的照片给她的手机做屏保，还给我讲很多我小时候的事，或许只有妈妈才能记得我小时候的每一个瞬间吧，即使我自己已经渐渐遗忘了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总是听到妈妈从百里之外的家中电话告诉我，我不想你回家，我不要你回家。因为你回一次家，我的心就会痛一次。她总是不忍分别的那一刻，她告诉我，她在看到我坐上去往西安的高客后，心就一阵一阵的痛，一直看到车驶出视野，才一路哭着回了家。晚上到我的房间，一摸被子没有人，再摸还是没有人，整间屋子空荡荡的，就又开始流泪。我听到她讲，总是不以为然的，我不懂这样的爱，但有一天我应该会懂。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我总是在别人面前提起我的妈妈怎么怎么样，却从来没有提到过爸爸。都说了，父爱是伟大的，严厉的，但我却总是不觉得，因为我和爸爸接触很少，我只是非常非常听他的话，我和妈妈犟好久的事只要他开口，我绝对执行。我继承了爸爸的性格，都是言语特别少的人，我们没有认真谈过心，也没有通过电话，只是坐在一起看看电视，爬爬山。但爸爸对我的好，我看在眼里。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我爱我的爸爸妈妈！ 记忆中的小脚丫，肉嘟嘟的小嘴巴，一生把爱交给他，只为那一声爸妈。”","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Emotion","slug":"Emotion","permalink":"http://yoursite.com/tags/Emotion/"}]},{"title":"蓝天净土（Video）","slug":"video-for-lantianjingtu","date":"2014-01-01T08:05:54.000Z","updated":"2017-11-20T02:06:16.615Z","comments":true,"path":"video-for-lantianjingtu.html","link":"","permalink":"http://yoursite.com/video-for-lantianjingtu.html","excerpt":"搬运旧时视频。 2014年一手策划的 蓝天净土 视频，当时制作视频的水平很 low，用的软件是会声会影，当然现在的水平还不及那时吧！现在再回顾，感触颇深。对这个大家庭还是有很深的感情的，虽然后面我主动退出了，虽然现在她可能已经被“领导们”取缔了……——2017.08","text":"搬运旧时视频。 2014年一手策划的 蓝天净土 视频，当时制作视频的水平很 low，用的软件是会声会影，当然现在的水平还不及那时吧！现在再回顾，感触颇深。对这个大家庭还是有很深的感情的，虽然后面我主动退出了，虽然现在她可能已经被“领导们”取缔了……——2017.08","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"【书评】穆斯林的葬礼","slug":"view-of-muslim-funeral","date":"2013-08-03T03:10:45.000Z","updated":"2018-08-10T07:14:07.385Z","comments":true,"path":"view-of-muslim-funeral.html","link":"","permalink":"http://yoursite.com/view-of-muslim-funeral.html","excerpt":"搬运旧时文章。年轻时的我，还是个文艺小青年。 ——2017.08 速葬、薄葬，是穆斯林的美德，伊斯兰教的葬礼是世界上各种族、各宗教中最简朴的葬礼，没有精美的棺木，没有华贵的寿衣，没有花里胡哨的纸车、纸轿、纸人、纸马，没有旗、锣、伞、扇的仪仗，没有吹吹打打的乐队，也没有漫天抛撒的纸钱……一心向主的穆斯林，不需要任何身外之物来粉饰自己。","text":"搬运旧时文章。年轻时的我，还是个文艺小青年。 ——2017.08 速葬、薄葬，是穆斯林的美德，伊斯兰教的葬礼是世界上各种族、各宗教中最简朴的葬礼，没有精美的棺木，没有华贵的寿衣，没有花里胡哨的纸车、纸轿、纸人、纸马，没有旗、锣、伞、扇的仪仗，没有吹吹打打的乐队，也没有漫天抛撒的纸钱……一心向主的穆斯林，不需要任何身外之物来粉饰自己。 “一个穆斯林家族，六十年间的兴衰，三代人命运的沉浮，两个发生在不同时代、有着不同内容却又交错扭结的爱情悲剧。”两根故事线，一大家子人的悲欢离合，就这样交织重叠地，从作者笔下娓娓流出。“一道门，隔着两个世界。”——一个是玉的世界，一个是月的世界。 这是一本非常值得一读的书，精彩与感动交织……曲终掩卷，荡气回肠，久久地沉浸在书中故事情节当中，为书中人物的喜而乐，为他们的忧而愁。 【人物】梁亦清：“玉器梁”的传人，人性善良，安分守己，虔诚的信奉着真主，一生酷爱琢玉，玉相伴其一生，生于玉，也死于玉，如此固执又如此爱玉的一个人最终还是一口鲜血喷在了未完成的“宝船”上。一代琢玉高手，玉殒人亡，千古遗恨啊。 梁君壁：年轻时的君壁是多么善良，多么单纯，多么害羞的女孩儿，还记得她很娇羞地喊着“奇哥哥”的样子，然后遭遇了父亲的变故后，子奇忍辱负重三年学艺归来，两人潦草地结为连理。当然也一直是贤妻良母，但性情变了，变暴躁了，尤其是日军侵华时与妹妹和子奇因是否逃往英国还大吵了一番，后又因为逃亡归来的子奇和冰玉有了一个女儿，而彻底将冰玉赶出家门。作为姨妈的她，对新月冷言冷语，不曾给过一分关怀，同时，毁了新月，亦毁了天星的爱情，当然也逼着子奇一步一步走向毁灭。 梁冰玉：冰玉和女儿新月一样，都是有文化、有修养的知识分子，敢爱敢恨，最终在英国和姐夫子奇产生了所谓的爱情，觉得家中容不得她便弃身而去。待到三十多年后，人老珠黄的她归来时，却已物是人非，她所牵挂的所有人都死了，姐姐死了，奇哥哥死了，她最最心爱却又不曾给过母爱的女儿新月也死去了…… 韩子奇：易卜拉欣初到梁家，便被璀璨的珠玉所吸引，立志献身于迷人的玉器。拜梁亦清为师，改名韩子奇，两人亲如父子。然后师父死在了玉上，自己偷学技艺三年，与君壁结婚，因战乱跑到英国与冰玉产生了真正的爱情，产有一女名为新月。非常心疼小女新月，却因为自己做了对不起君壁的事而心存悔恨，低声下气的，想爱可怜的新月却是那么的难啊！最后的最后，自己守了一辈子的美玉被红卫兵们搬走了，毫无音信。临死前给心爱的冰玉写了一封信（被天星烧了），他要在死之前，对未了的情、未熄的火、未还的债、未赎的罪得以清算，要求得到那个不能忘怀的人的宽恕。精彩、神奇却又悲惨的一生就这样在疾病中结束了…… 韩天星：知道新月的身世，待新月极好了。可怜自己的爱情被妈妈从中拆散，为了家庭却只能忍气吞声。他看不惯妈妈对新月的态度，却也无可奈何。 陈淑彦：多么好的一位姑娘，新月的好朋友，天星的好妻子。对韩家劳心劳力，深爱着木讷的天星。 楚雁潮：如此如此深深地爱着新月，为了新月，他愿意做任何事情。在新月生病住院的时候，不舍昼夜地守候在她的身边，给她带来活下去的希望，激励她勇敢地活下去。可是却未能见到新月最后一面，新月就离他而去了。二十多年后的他，在新月生日这天，依旧在新月的坟前，为她拉着那曲《梁山伯与祝英台》，想念着那个他心心念念想着的人儿…… 姑妈：她在文中一直扮演着和事佬，就像韩家的奴仆一样为这个家操劳着、奉献着自己的一生。她早年遭遇悲惨，丈夫和儿子都被日军抓走，所幸自己得以被韩家收留，并将天星视为自己的儿子一样看待，对新月也如同亲生女儿一样疼爱有加。她也是一位心脏病人啊，可是韩家哪个人真正关心和注意过她呢，最后可怜的她在新月追问自己的生母的哭声中死于急性心肌梗塞。她从来没有心疼过自己，血肉耗尽了，心操碎了，终于倒下去了，再也没有起来。 韩新月：新月，我有太多的词来形容你。你感动了我，你便是整篇文章的精魂，我宁愿相信《穆斯林的葬礼》其实便说的是你的葬礼。给我最多感动的新月，愿真主祥助你！（有太多话想说，却不知道从何说起，此处略去一千字） 【书评】《穆斯林的葬礼》，书中对穆斯林的生活细节详细的加以描述，不仅仅以极重的笔墨描写穆斯林的葬礼，也详细的描述了穆斯林的婚礼。我固执的以为这场葬礼说的是新月的葬礼，这个可怜的姑娘的葬礼。 但这场葬礼却并非那么简单，书的最后韩子奇说出了一个天大的秘密 “我……不是回回！” 这也许才是真正的穆斯林的葬礼，一直虔诚信奉真主的梁家（韩家）后代身上竟然流着回、汉两族的血液啊！这可谓是对这个穆斯林家族及其沉重的打击。 看过这本书，就好像陪主人公走过了那段岁月，心灵仿佛受到了一次的洗礼。 什么是善？什么是恶？什么是丑？什么是美？什么是爱？什么是恨？ 当这些与我们的心灵碰撞的时候，我们能说得清吗? 【精彩段落】 楚雁潮痴痴地凝望着新月……他看见新月走进燕园，穿着白色的衬衫，蓝色的长裤，手里提着沉重的皮箱和网袋……他看见在未名湖畔迷路的新月，正惊喜地朝他跑来……他看见在红枫掩映的湖心小岛上，新月朝他蓦然回首……他看见了那锁住新月的病床，听见了那刻骨铭心的话语：“老师，我们之间是……爱情吗？”“告诉你，新月！几乎可以这样说，自从见到你的第一天，我就在悄悄地爱着你！”“啊，那是命运，让您等着我，让我遇到您！”“我们付出了爱，也得到了爱，爱得深沉，爱得强烈，爱得长久……”“正因为爱得太深，才惟恐它不能长久，总有一天我会把您丢下……”“任何时候我都不会丢下你，两个生命合在一起该有多大的力量？我扶着你、背着你、拖着你，也要向前走，走出‘阿拉斯加’，我们就有美好的明天！”“‘人生得一知己足矣’，我已经可以死而无憾！”“楚老师，不要为我悲伤，您对我说过：自知是一种幸运，现在我终于自知了，也算是一个幸运的人了。感谢您过去所给予我的全部关怀，但愿我今后不再打扰您了！”他似乎也看见了新月在最后的时刻嘴唇艰难地嚅动，听见了她痛苦的呼唤：“楚……”“新月！我在这儿呢，在你身边！”他痴痴地回答，凝望着新月的遗体。新月再也没有任何回应。她静静地躺在这最后的归宿，低垂的眼睑仿佛还在苦思，紧闭的嘴唇似乎蕴含着万语千言。谁也不知道她的灵魂在想什么，要说什么。她的脸朝向西&gt; 方，她的主宰、她的祖先召唤着她，告别尘世的一切，到该去的地方去……","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}]},{"title":"游革命圣地延安","slug":"travel-to-yanan","date":"2013-04-07T08:35:06.000Z","updated":"2018-08-10T07:12:29.106Z","comments":true,"path":"travel-to-yanan.html","link":"","permalink":"http://yoursite.com/travel-to-yanan.html","excerpt":"游记篇——朝花夕拾。","text":"游记篇——朝花夕拾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“清明时节雨纷纷，路上行人欲断魂”，仿佛是为了迎合这句古诗，在清明这天，三秦大地上落下了一场小雨，它洗去污浊，褪去铅华，平息了城市的喧哗。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这场春雨并不能浇灭人们出游的热情。清明，万物都开始焕发生机，此正是外出踏青的好时节。而我，则邀好友一同去往红色革命圣地延安。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延安，这个从小到大“耳熟”得不能再熟的地方，我终于见到了它的庐山真面目。延安依群山傍延河，宝塔山、清凉山、凤凰山三山鼎峙，黄河支流从这里流过。无论站在这个城市的哪个地方，都可以看见那座著名的“宝塔山”，以及山上随处可见的一个个圆拱形的窑洞。这里的每个角落都透露着一股宁静、幽雅、古朴而又不失厚重的气息。走在灯红酒绿的繁华市区，虽然天空中仍有小雨在淅淅沥沥地飘落，但我依旧能从中感受到这座城市的勃勃生机，它真不愧是中国革命圣地。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清明假期，我游历了杨家岭革命旧址、枣园革命旧址、延安革命纪念馆、凤凰山革命旧址等地，我进入了曾经召开过第七次党代会的中央大礼堂，我参观了毛泽东、周恩来、朱德、杨尚昆、任弼时等重要革命人曾经居住过的窑洞，我目睹了神奇的非物质文化遗产——剪纸艺术。身处圣地延安，任红色春风肆意吹拂，身临其境的我仿佛依稀可见革命人艰苦奋斗的岁月，心中不由升起浓浓的敬意。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一片净土，曾孕育了光照千秋的延安精神。我也终于在这片红色热土上悟得了延安精神，其实就是艰苦奋斗的精神。待到坐上返程的列车，心中只有不舍，舍不得离开这里，而更多的是舍不得和朋友分开。这一别，不知下次到延安，会是以什么原因，以什么目的，又是以什么心情，更重要的是要找寻什么样的人儿？ 2013年4月7日记任凯","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://yoursite.com/tags/Travel/"}]},{"title":"乐在西农的日子","slug":"happy-in-nwsuaf","date":"2012-12-30T04:46:37.000Z","updated":"2018-08-10T07:10:58.587Z","comments":true,"path":"happy-in-nwsuaf.html","link":"","permalink":"http://yoursite.com/happy-in-nwsuaf.html","excerpt":"搬运旧时文章。","text":"搬运旧时文章。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;站在2012的尾巴上，我仿佛已看到2013的轨迹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;九月份，我体会了大学的生活。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纪律严明的军训，坑爹的各种面试，轻松愉快的团组织活动，冷死人的工程训练，集体补高数作业的星期天晚上…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有看着别人整天满课而偷笑，为各种强迫去做的事而抱怨，为时间总是不能合理安排而头痛…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最最重要的事是，我在漫长的三个月里和我的伙伴们用汗水和辛劳学会了舞狮，感谢我们的队长高金龙，陪我们走过每一个夜晚，感谢他悉心地指导我们的每一个动作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，2012年即将结束，我们舞狮队联合腰鼓秧歌共给动医学院、理学院、林学院的元旦晚会上演出了三场。至此，2012年的所有演出已经告一段落。虽有缺陷和失误，但台上的掌声和尖叫告诉我们，我们的演出很成功，期待下一年的更多演出，我们会越做越好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，虽坐落在杨凌这个小城镇里，但她自身就相当于一个城市一样，她包容了一切，在这里，只有你想不到的，没有她办不到的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我很快乐。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我拥有可以陪伴去自习的人，我拥有五个奇葩的舍友，我还有蓝天净土的广阔天地…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，有很多的高中同学们，有很多帮助我的学长学姐们，有很多很多的人…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，汇聚了来自全国各地的同学。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，有各种不同的习俗文化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，她神奇的在五台山上，在南校就可以看到高大的八号楼。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，她拥有亚洲第一的葡萄酒学院。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;西农，我们生活的地方。我们另外一个家。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;期待我明天在校元旦晚会开场舞上的表演。虽然只是拿着“糖葫芦”打酱油，但我感到很荣幸。 2013年，迎新年，祝福西农！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"成长","slug":"grow-up-18th","date":"2011-04-28T14:27:07.000Z","updated":"2017-11-20T02:05:20.027Z","comments":true,"path":"grow-up-18th.html","link":"","permalink":"http://yoursite.com/grow-up-18th.html","excerpt":"搬运旧时文章。谨以此文纪念我的十八岁","text":"搬运旧时文章。谨以此文纪念我的十八岁 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匆匆，太匆匆。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时光流逝，岁月无痕。一眨眼，一晃神，才发现十八个年头已经过去了。从呱呱坠地咿呀学语到逐渐趋于成熟，我经历了很多很多。渐渐地，看惯了花开花败；渐渐地，看惯了阴晴圆缺；渐渐地，看惯了悲欢离合……总之，我已经在这人世间走过一遭，却来得干净，亦活得干净，没有在已逝的岁月里留下一丝痕迹。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个人都喜欢恋旧，都会将现在和过去比较，然后在记忆中搜寻已渐渐丢失的记忆碎片浅浅的怀念。我也不例外，时常陷在回忆的漩涡中无法自拔，时至今日，亦未完全成熟，毕竟还未入世，还未真正领略到社会的残酷、人心的险恶……但我喜欢做单纯的自己，很单纯地喜欢一个人，很单纯地迷恋一首歌，很单纯地行走于暗夜中…… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;禁不住想起自己成长的每个细节，虽已渐渐模糊，却也常常想起感伤满怀。隐隐记得，小学时期的自己是很淘气的男孩儿，像每个男生的童年一样活泼好动，总是三五成群的下河去捉鱼，或相约去打电玩，优哉游哉的生活，乐得自由，乐得童真！然而随着渐渐的长大，我的性格也变得内敛，沉默，不善于别人沟通，更不愿去与任何人交谈，尤其面对女生更是显得不知所措。升入高中，初期时我还和一群大男生疯玩，预计着和他们一起“混迹天涯”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许嵩说：“我满意于自己依旧那么的不会做人。对喜欢的人笑脸相待。对厌烦的人敷衍了事。”我想，我是和他一样，爱憎分明，不会娇柔做作，更不会虚伪的伪装自己。全倩曾经说我和邓很相像，原因是我们两个人对每个人都很好，甚至是那些极其让人厌恶的人…我只能说，这很对，但不完全对，我也有讨厌的人。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天是我的十八岁生日，度过今日，便已不再年轻，人生还有多少个十八年容得我去荒废？今日如我所愿，没有太多人知道，悄悄地过18岁，妈妈为我买了两个蛋糕，高兴的我合不拢嘴，还有那些记得我生日的朋友们，谢谢啊！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今最大的愿望就是在即将到来的高考中我能取得让自己满意的成绩，我绝不会让我的十二年学习生涯悲剧结尾。Believe me！我我定会创造奇迹，让自己的人生绽放光彩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我是有富裕的家底，还是有帅气的外表，还是有非凡的才华？呜呼！我什么都没有。但我有的是信心决心耐心，加油！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，祝我生日快乐！","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"living","slug":"living","permalink":"http://yoursite.com/tags/living/"}]},{"title":"『我不恨你们』——感巴以战争","slug":"novel-about-israeli-palestinian-war","date":"2009-01-18T03:33:09.000Z","updated":"2017-08-24T14:46:09.213Z","comments":true,"path":"novel-about-israeli-palestinian-war.html","link":"","permalink":"http://yoursite.com/novel-about-israeli-palestinian-war.html","excerpt":"搬运旧时文章。 高中时期随便写的一个小说。 ——2017.08 背景资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴以（巴勒斯坦和以色列）冲突(The Israeli Palestinian Conflict)是中东地区冲突的热点之一，冲突的背后隐藏着深刻的历史根源，既有宗教的、文化的、民族的因素，更重要的是大国干预等外部因素，各种因素互相影响、激化，使得巴以冲突的复杂性非同一般。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008年的平安夜，当哈马斯组织发射的50多枚火箭弹划破夜空，落在以色列南部后，几乎没有人会否认以色列将使用武力，但恐怕没人想到竟会是这样的规模：以色列对加沙地区发动大规模空袭和地面攻击造成数千人的伤亡。而以军也在战争中损失巨大。战争就在你攻我守的循环中持续到了2009年，原本就处于“冷对峙”状态的巴以局势，发展成全面的“热冲突”。这场战争，给巴以双方造成了难以估量的损失，尤其是两国人民所遭受的痛苦，一时是难以消除的。","text":"搬运旧时文章。 高中时期随便写的一个小说。 ——2017.08 背景资料&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴以（巴勒斯坦和以色列）冲突(The Israeli Palestinian Conflict)是中东地区冲突的热点之一，冲突的背后隐藏着深刻的历史根源，既有宗教的、文化的、民族的因素，更重要的是大国干预等外部因素，各种因素互相影响、激化，使得巴以冲突的复杂性非同一般。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008年的平安夜，当哈马斯组织发射的50多枚火箭弹划破夜空，落在以色列南部后，几乎没有人会否认以色列将使用武力，但恐怕没人想到竟会是这样的规模：以色列对加沙地区发动大规模空袭和地面攻击造成数千人的伤亡。而以军也在战争中损失巨大。战争就在你攻我守的循环中持续到了2009年，原本就处于“冷对峙”状态的巴以局势，发展成全面的“热冲突”。这场战争，给巴以双方造成了难以估量的损失，尤其是两国人民所遭受的痛苦，一时是难以消除的。 “这不过是政府间的矛盾罢了，何苦连累人民呢？”“这儿没有水，没有电，没有面包，我们只有靠呼吸空气活着。”——题 记 普尔和他的同伴被派遣出来搜索加沙附近村庄，呼啸而过的炮火随时可能威胁到他们的性命。但他们是军人，上战场是他们的职责。 普尔不过是以色列的一名普通士兵。他此时正端着重型机枪和同伴在丛林中行走，时不时有炮弹在这附近炸开，依旧无法阻挠他们行进的脚步。 因为战争的原因，普尔已经有好几个夜晚没有睡觉了，她想念妻子和孩子，他没有尽到做丈夫和爸爸的责任。他讨厌战争，他想要一个和睦的家。 可他现在却在战场上。 丛林中的鸟儿在唱歌，树叶沙沙的在风中摇摆，炮火一如既往的在加沙地区轰隆作响。炸飞了鸟儿，扰乱了林中的宁静。 穿行在丛林中，感受到树叶刮在脸上辣辣的疼，他为自己的行为愧疚。为了所谓的国家的荣誉，出卖了人格。以色列对加沙的数天轰炸，已造成近千人死亡，可是以色列政府依旧打着和平主义的旗号面对其他国家的劝战。 走出了这大片的丛林，是一座小村庄。普尔笑了笑，他终于可以歇息一下了，他已经很累了。 他们走到一户已被炸成废墟的房内，随地躺下。他们有的在聊天，有的在翻看随身携带的杂志，有的紧张的望着外面，而普尔则眯上眼睛，开始休息。 第二天清早，和煦的阳光挥洒下来，照亮了四周。他们又要继续进行搜索工作了。 普尔架着抢，跟着同伴进入一处比较完好的住所。他发现墙角有两个人影闪动。走近一瞧，是一位老妇人和一个孩子。 普尔看着那个孩子渴望的眼神，想到了自己的两个仍在襁褓中的女儿，他们还都没有断奶。在他离开她们时，她们也刚学会叫他一声爸爸。 作为父亲的他，趁着同伴不注意，将他们藏在角落里，装作什么也没有发生的样子，就走开了。他们一家一户的搜索着可能存活的加沙人，而空中盘旋着的飞机仍在不停地空袭加沙城。 普尔仰起头，看天。浓烟包裹了四周，明媚蔚蓝的天空不复存在。忽然，他看到一架战斗机投下一枚火箭弹，而坠落的地方正是他们现在站立的地方。普尔急忙对同伴们呼喊：“快趴下。” “轰隆”的响声已经压住了他的话语，火箭弹在他们中央炸开了。空中飞舞着人的断肢残臂，地上熊熊大火燃着了他们的衣服，猎猎作响。普尔只感到脑袋快要涨裂了，胸中沉闷得像压了几石重石。 迷迷糊糊间看到有一个人影向他走来，飘飘忽忽……… 头依旧痛得厉害，普尔缓缓睁开眼睛，轻微的挪动身体，可左胳膊完全没了知觉，使不上劲。 普尔发现自己现在正在一间破败的房间内，旁边站着一个小女孩。女孩蓝色的眼珠滴溜溜转着，脸上是茫然和无知，还夹杂着孩子共有的天真。 普尔微笑的看着她，眼中是说不尽的慈爱。右手颤抖的抚在女孩的脸上，温柔的抚摸着，就像丈夫抚摸妻子的脸一般。不同的是，这完全是父爱。 这使普尔再一次想到了自己的女儿，那两个只有四岁的女儿。她们也是这样的可爱，普尔经常会带她们去屋后的花园中去捉蝴蝶，她们一左一右在普尔身边，奶声奶气地喊着不太正确的发音，“爸爸……爸爸………” 那声音似乎响在耳边。 女孩看到身边的普尔醒了，连忙对着已经没了玻璃的窗子，喜悦地喊，“奶奶，这位叔叔醒了。” 从外面蹒跚地走进一位老妇人，他手中捧着一碗冒着热气的水，走到普尔身边，递过手中的碗，平静地说，“你好，先生，我是贝恩·劳德拉，谢谢你今天使我和孙女躲过了他们的搜索。你身上的伤不是很严重，但你最好不要乱动，你的胳膊大片被烧伤……和你一起来的战友都死了……唉，惨不忍睹！” 普尔试着抬起左手，可左手就是不受他的控制。普尔无奈地摇了摇头，转而笑着说：“没关系的，上帝保佑，我还活着。是你救了我吧？真不知道该怎么感谢你，劳德拉女士。”说着，他一口气喝掉了碗中的热水，温热的感觉滋养了他残损的心。 普尔忽然想起了自己的职责，面带愧疚的低声说，“真对不起，劳德拉女士。我也不想这样，我很讨厌战争。这不过是政府间的矛盾罢了，何苦连累人民呢？” 老妇人转过身，喃喃地说，“这儿没有水，没有电，没有面包，我们只有靠呼吸空气活着。你刚才喝的那杯水，也是我跑到几里外取来的。” 普尔连忙拽过身后的背包，取出两块面包递给老人和孩子。只见她们狼吞虎咽的很快就吃完了。女孩吃完后，可怜兮兮的望着普尔。普尔耸肩，示意已经没有了。 老妇人嗫懦地说，“谢谢你的面包，小伙子。我不恨你们，这只能怪领导人，是他们发起了战争，你和我们一样也是受害者。” 普尔忍痛站起身来，搀扶住老人，“劳德拉女士，感谢您能饶恕我的罪过。不过，我要走了。” 说着，脚一跛一跛的走向外面，老妇人和女孩一直望着他。 普尔走了一段，转过头深深的向这里鞠躬。然后眼睛落在了那个女孩身上，她正在喜滋滋地把玩着手中的玩具。 普尔继续向前走。身边的炮火声不间断。 突然，他的心中一震，他明显地听到有一声熟悉的炮声在身后响开了。普尔的眼睛湿润了，脑中女孩的可爱模样和老妇人的慈祥关爱一一浮现出来。 他转过身，身后的废墟在冒着浓烟，空气中散发着浓重的血腥味。普尔的眼泪似决堤的洪水，不停的流。他重重地跪在地上，手中的拳头发出叭叭的骨节磨动的轻响。 “我不恨你们……”老妇人的话语，响在耳边。普尔悔恨的用完好的右手捶着地面。 这位战场上无比坚强的军人又一次痛哭起来。","categories":[{"name":"Mine","slug":"Mine","permalink":"http://yoursite.com/categories/Mine/"}],"tags":[{"name":"Novel","slug":"Novel","permalink":"http://yoursite.com/tags/Novel/"}]}]}