<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML基础学习笔记]]></title>
    <url>%2Fposts%2Fhtml-css-js%2F2017-08-21-html-basic-learning-notes.html</url>
    <content type="text"><![CDATA[自学 html 基础笔记。 Web 前端简单介绍web 前端包含： pc 端页面 移动端页面 web 前端首先要解决用户体验的问题 认识网页网页的组成网页主要由文字、图片和按钮等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及 Flash 等。 Web 标准1：w3c 万维网联盟组织：用来制定 web 标准的机构（组织） 2：web 标准：制作网页要遵循的规范 3：web 标准规范的分类：结构标准；表现标准；行为标准 结构标准：html（用来制作网页的） 表现标准：css（对网页进行美化的） 行为标准：javascript（让网页动起来，具有生命力） 4：web 标准总结： 结构标准：相当于人的身体 表现标准：相当于人的衣服 行为标准：相当于人的动作 浏览器介绍浏览器是网页运行的平台，常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。 浏览器内核：也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内 ，容以及页面的格式信息。 IE Google/Opera FireFox Safari trident blink gecko webkit 浏览器与服务器1：浏览器向服务器发送请求（通过http协议） 2：http协议：超文本传输协议，也就是浏览器和服务器端的网页传输数据的约束和规范 3：https：加密处理 4：url协议:平时我们写的网址就是 url 地址 url协议：规定 url 地址的格式 协议规定格式： scheme://host.domain:port/path/filename scheme: 定义因特网服务的类型。常见的就是httphost: 定义域主机（http 的默认主机是www）domain: 定义因特网域名 比如：w3school.com.cn:port 定义端口号（网页默认端口 :80）path: 网页所在服务器上的路径filename: 文件名称 认识 html概念html (Hyper Text Markup Language ) 中文译为 超文本标记语言，主要是通过 html 标记对网页中的文本，图片，声音等内容进行描述。 HTML 之所以称为超文本标记语言，不仅是因为他通过标记描述网页内容，同时也由于文本中包含了所谓的 超级链接，通过超链接可以实现网页的跳转。从而构成了丰富多彩的 Web 页面。 html 结构基本结构如下：1234567&lt;! Doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 各部分的含义：12&lt;!-- 文档类型 --&gt;&lt;! Doctype html&gt; 12&lt;!-- 根标签 --&gt;&lt;html&gt;&lt;/html&gt; &lt;html&gt;&lt;/html&gt; 用于告知浏览器其自身是一个 HTML 文档，&lt;/html&gt; 标记标志着 HTML 文档的开始，&lt;/html&gt; 标记标志着 HTML 文档的结束，在他们之间的是文档的头部和主体内容。 12&lt;!-- &lt;html lang="en"&gt; 向搜索引擎表示该页面是html语言，并且语言为英文网站 --&gt;&lt;html lang="en"&gt; 这个主要是给搜索引擎看的，搜索引擎不会去判断该站点是中文站还是英文站，所以这句话就是让搜索引擎知道，你的站点是中文站，对 html 页面本身不会有影响。 12&lt;!-- html文档头部分 --&gt;&lt;head&gt;&lt;/head&gt; 主要用来封装其他位于文档头部的标记。一个 HTML 文档只能含有一对 &lt;head&gt; 标记，绝大多数文档头部包含的数据都不会真正作为内容显示在页面中。 12&lt;!-- 网页的标题 --&gt;&lt;title&gt;&lt;/title&gt; &lt;title&gt; 标记用于定义HTML页面的标题，&lt;title&gt;&lt;/title&gt; 之间的内容将显示在浏即给网页取一个名字，必须位于 &lt;head&gt; 标记之内。一个HTML文档只能含有一对 &lt;title&gt;&lt;/title&gt; 标记，将显示在浏览器窗口的标题栏中。 12&lt;!-- html结构的主体部分 --&gt;&lt;body&gt;&lt;/body&gt; &lt;body&gt; 标记用于定义 HTML 文档所要显示的内容，也称为主体标记。浏览器中显示的所有文本、图像、音频和视频等信息都必须位于 &lt;body&gt; 标记内，&lt;body&gt; 标记中的信息才是最终展示给用户看的。一个HTML文档只能含有一对 &lt;body&gt; 标记，且 &lt;body&gt; 标记必须在 &lt;html&gt; 标记内，位于 &lt;head&gt; 头部标记之后。 标签的分类HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;； HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;； 标签对中的第一个标签是开始标签，第二个标签是结束标签； 开始和结束标签也被称为开放标签和闭合标签； HTML标记—双标记双标记也称体标记，是指由开始和结束两个标记符组成的标记。其基本语法格式如下：123&lt;标记名&gt;&lt;/标记名&gt;&lt;!-- 例如： --&gt;&lt;body&gt;&lt;/body&gt; 该语法中 &lt;标记名&gt; 表示该标记的作用开始，一般称为 开始标记（start tag），&lt;/标记名&gt; 表示该标记的作用结束，一般称为 结束标记（end tag）。和开始标记相比，结束标记只是在前面加了一个关闭符 /。 HTML标记—单标记单标记也称空标记，只有开始标签没有结束标签：123&lt;标记名&gt;&lt;!-- 例如： --&gt;&lt;! doctype html&gt; 标签关系 嵌套关系：类似父亲和儿子之间的关系 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 并列关系：类似与兄弟之间的关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; html 标签介绍单标签文本注释标签1&lt;!-- 文本注释标签 Ctrl+/ --&gt; 文本换行标签1你好&lt;br&gt;我来自中国 效果演示：你好我来自中国 横线标签1&lt;hr&gt; 效果演示： 双标签段落标签12&lt;p&gt;这是一行文字&lt;/p&gt;&lt;p&gt;这也是一行文字&lt;/p&gt; 效果演示：这是一行文字这也是一行文字 标题标签 注意：标题标签只能取到数字 1-6 123456&lt;h1&gt;这是一个标题1&lt;/h1&gt;&lt;h2&gt;这是一个标题2&lt;/h2&gt;&lt;h3&gt;这是一个标题3&lt;/h3&gt;&lt;h4&gt;这是一个标题4&lt;/h4&gt;&lt;h5&gt;这是一个标题5&lt;/h5&gt;&lt;h6&gt;这是一个标题6&lt;/h6&gt; 文本标签1&lt;font&gt;&lt;/font&gt; 例如：1&lt;font size="10" color="red"&gt;优美的文字&lt;/font&gt; 效果演示： 优美的文字 文本格式化标签文字加粗显示1&lt;strong&gt;该减肥了！&lt;/strong&gt; 效果演示：该减肥了！ 文字斜体1&lt;em&gt;这行字是斜的&lt;/em&gt; 效果演示：这行字是斜的 文字下横线12&lt;ins&gt;文字下横线&lt;/ins&gt;&lt;u&gt;文字下横线&lt;/u&gt; 效果演示：文字下横线文字下横线 文字删除线12&lt;del&gt;删除线&lt;/del&gt;&lt;s&gt;删除线&lt;/s&gt; 效果演示：删除线删除线 图片标签1&lt;img&gt; 属性 描述 src 设置显示图片（图片名称或者图片路径） title 用来设置鼠标放在图片上显示的文字 alt 当图片无法正常显示的时候，对图片的描述 width 用来设置图片宽度 height 用来设置图片的高度 12&lt;!-- 下图来自百度图片 --&gt;&lt;img src="www.baidu.com/imags/1.png" title="HTML" alt="测试图片" width="200" height="200"&gt; 效果演示： 相对路径 当图片和文件（html）在同一个文件夹中时，src 属性中直接写上图片名称即可。 1&lt;img src="1.jpg"&gt; 当图片在文件（html）的下一级目录中时，src 属性中写上图片所在的文件夹名 +“/” + 图片名称 1&lt;img src="1/1.jpg"&gt; 当图片在文件（html）的上一级目录中时，src 属性中写上 ../图片所在文件夹名 + “/” + 图片名称 1&lt;img src="../2/1.jpg"&gt; 绝对路径凡是带有 磁盘路径 的都是绝对路径，或者带有 网站地址 的也是绝对路径。 12&lt;img src="D:\a\1.png"&gt;&lt;img src="www.baidu.com/imags/1.png"&gt; 超链接在HTML中创建超链接非常简单，只需用 &lt;a&gt;&lt;/a&gt; 标记环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; 属性 描述 href 用于指定链接目标的 url 地址，当为 &lt;a&gt; 标记应用 href 属性时，它就具有了超链接的功能。 target 用于指定链接页面的打开方式，其取值有 _self 和 _blank 两种，其中 _self 为默认值， _blank 为在新窗口中打开方式。 在 &lt;head&gt; 标签中使用 &lt;base&gt; 标签可以设置网页整体链接的打开状态。 123&lt;head&gt; &lt;base target="_blank"&gt;&lt;/head&gt; 实例：12&lt;a href="http://www.baidu.com" target="_blank"&gt;百度&lt;/a&gt;&lt;a href="http://www.renkaigis.com" target="_blank"&gt;Kai's Blog&lt;/a&gt; 效果演示：百度Kai’s Blog 注意: （1）暂时没有确定链接目标时，通常将 &lt;a&gt; 标记的 href 属性值定义为“#”(即 href=&quot;#&quot; )，表示该链接暂时为一个空链接。 （2）不仅可以创建文本超链接，在网页中各种网页元素，如 图像、表格、音频、视频 等都可以添加超链接。 锚链接通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 使用 “ &lt;a href=&quot;#id名&quot;&gt; 链接文本 &lt;/a&gt; ” 创建链接文本； 使用相应的 id 名标注跳转目标的位置。 12345&lt;!-- 例如在网页顶部写个你好 --&gt;&lt;p id="db"&gt;你好&lt;/p&gt;&lt;!-- 给 a 标签设置 href 属性 "#id名称" --&gt;&lt;a href="#db"&gt;返回顶部&lt;/a&gt; 效果演示： 你好返回顶部 特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方（上标2） &amp;sup2; ³ 立方（上标3） &amp;sup3; 列表无序列表（ul）12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; 列表项 &lt;li&gt;&lt;/li&gt; ......&lt;/ul&gt; 例如：12345678大家喜欢吃什么水果&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;水蜜桃&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt;&lt;/ul&gt; 效果演示：大家喜欢吃什么水果苹果香蕉菠萝 属性：type （默认值）实心圆点：disc 实心方块：square 空心圆圈：circle 实例：123456789101112&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type="square"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt;&lt;ul type="circle"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 有序列表（ol）1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 属性：type A（ABCD排序），a（abcd排序），i（小写的罗马数字），I（大写的罗马数字） 属性：start=”3”，表示从第几个数开始 123456把大象放冰箱分几步？&lt;ol type="a" start="3"&gt; &lt;li&gt;打开冰箱门&lt;/li&gt; &lt;li&gt;把大象放进去&lt;/li&gt; &lt;li&gt;关上冰箱门&lt;/li&gt;&lt;/ol&gt; 效果演示： 把大象放冰箱分几步？打开冰箱门把大象放进去关上冰箱门 自定义列表（dl）自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; 小标题 &lt;dd&gt;&lt;/dd&gt; 列表项 &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 一般用于网页的底部，例如：1234567&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;售后服务&lt;/dt&gt; &lt;dd&gt;收货地址&lt;/dd&gt; &lt;dd&gt;在线支付&lt;/dd&gt; &lt;dd&gt;联系客服&lt;/dd&gt;&lt;/dl&gt; 效果演示： 售后服务收货地址在线支付联系客服 小补充页面背景音乐1&lt;embed src="1.mp3" hidden="true"&gt; 属性： src：设置音乐路径 hidden：隐藏播放按钮，true 隐藏，false 显示 页面滚动效果1234&lt;!-- 中间的内容可以为 文字、图片，也可以是由程序生成的文字或图片 --&gt;&lt;marquee&gt; ...&lt;/marquee&gt; 实例展示： 1&lt;marquee bgcolor="blue" &gt;我会滚动&lt;/marquee&gt; 效果演示： 我会滚动 属性 描述 height 设置高度 width 设置宽度 bgcolor 设置背景颜色 behavior 设定滚动的方式：alternate：表示在两端之间来回滚动；scroll：表示由一端滚动到另一端，会重复；slide：表示由一端滚动到另一端，不会重复。 direction 设定滚动的时间：down：向下滚动；left：向左滚动；right：向右滚动；up：向上滚动。 loop 设置滚动次数，-1 表示一直滚下去 Meta标签和Link标签Meta 标签meta 的属性有两种：name 和 http-equiv。 name 属性主要用于描述网页，对应于 content（网页内容）。 1、用来说明网页使用的字符集，即编码格式 1&lt;meta charset="utf-8"&gt; 2、用以说明生成工具（如Microsoft FrontPage 4.0）等； 1&lt;meta name="generator" contect=""&gt; 3、向搜索引擎说明你的网页的关键词； 1&lt;meta name="keywords" contect=""&gt; 4、告诉搜索引擎你的站点的主要内容； 1&lt;meta name="description" contect=""&gt; 5、告诉搜索引擎你的站点的制作的作者； 1&lt;meta name="author" contect="你的姓名"&gt; 6、有时候会有一些站点内容，不希望被ROBOTS抓取而公开。为了解决这个问题，ROBOTS开发界提供了两个办法：一个是robots.txt，另一个是 The Robots META 标签。 1&lt;meta name="robots" contect= "all|none|index|noindex|follow|nofollow"&gt; robots 其中的属性说明如下： 设定为 all：文件将被检索，且页面上的链接可以被查询； 设定为 none：文件将不被检索，且页面上的链接不可以被查询； 设定为 index：文件将被检索； 设定为 follow：页面上的链接可以被查询； 设定为 noindex：文件将不被检索，但页面上的链接可以被查询； 设定为 nofollow`：文件将不被检索，页面上的链接可以被查询。 http-equiv 属性1&lt;meta http-equiv="refresh" content="5;url=http://www.baidu.com" /&gt; 网页重定向，表示的是 5 秒后网页自动跳转到指定网址。 Link 标签1&lt;link rel="icon" href="favicon.ico"&gt; 给网页 titile 中放置小图标1&lt;link rel="stylesheet" href="1.css"&gt; 引入外部样式表 表格（table）表格基本结构在 HTML 语言中，表格至少由 &lt;TABLE&gt; 标签、&lt;TR&gt; 标签和 &lt;TD&gt; 标签这 3 对标签组成。 1.&lt;table&gt;&lt;table&gt;...&lt;/table&gt; 标签用于在HTML文档中创建表格。它包含表名和表格本身内容的代码。表格的基本单元是单元格，用 &lt;td&gt;...&lt;/td&gt; 标签定义。 2.&lt;tr&gt;表格行用 &lt;tr&gt; 标签定义，由单元格构成。多个行结合在一起就构成一个表格，这反映在用于创建表格的HTML语法中。表格的每一行都用 &lt;tr&gt; 标签表示，并用相应的 &lt;/tr&gt; 结束. 3.&lt;td&gt;表格的每一行又有若干表格单元格，用 &lt;td&gt;...&lt;/td&gt; 标签表示。td 是”表格数据(Table Data)”的英文缩写。&lt;td&gt; 标签定义一个列，嵌套于 &lt;tr&gt; 标签内。border 属性是最常用的属性，可用于定义表格的单元格和结构。该属性指定边框的厚度，如果其值设置为零(0)，则不显示边框。 基本语法：12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;职业&lt;/td&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 属性介绍： bord：设置表格边框的厚度 width：设置表格宽度 height：设置表格高度 cellspacing：设置单元格之间的距离 cellpadding：文字距离单元格边框的距离 bgcolor=”red”：设置背景颜色 align=”center” | left | right：给 tr 或者 td 设置让文字居中，给 table 设置让表格居中 属性名 含义 常用属性值 border 设置边框，默认为0，没有边框 单位为 px 像素值 cellspacing 设置单元格与单元格之间的距离 单位为 px 像素值，默认为 2px cellpadding 设置文字与单元格之间的距离 默认 1px width 设置表格的宽度 单位 px height 设置表格的高度 单位 px align 设置表格在网页中的对其方式 left 左rigth 右center 居中 bgcolor 设置背景颜色 white，red，green等 设置表格表头，用法和 td 一样表头一般位于表格的第一行或第一列，其文本加粗居中。1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18码农江苏 表格属性设置示例：1234567891011121314&lt;table border="1" width="200" height="300" cellspacing="0" cellpadding="20" bgcolor="red"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示：（本应整个表格都是 bgcolor 的，这里显示有问题） 姓名年龄职业籍贯小明18码农江苏 设置表格标题：caption 标签必须紧随 table 标签之后。只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。12345678910111213141516&lt;table&gt; &lt;!-- 设置表格标题 --&gt; &lt;caption&gt; &lt;h3&gt;人员信息表&lt;/h3&gt;&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 人员信息表姓名年龄职业籍贯小明18码农江苏 表格结构12345&lt;table&gt; &lt;thead&gt;&lt;/thead&gt; 头 &lt;tbody&gt;&lt;/tbody&gt; 身体 &lt;tfoot&gt;&lt;/tfoot&gt; 脚&lt;/table&gt; 在使用表格进行布局时，可以将表格划分为头部、主体和页脚，具体如下所示： &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部，必须位于 &lt;table&gt;&lt;/table&gt; 标记中，一般包含网页的logo和导航等头部信息。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;thead&gt;&lt;/thead&gt; 标记之后，一般包含网页中除头部和底部之外的其他内容。 &lt;tfoot&gt;&lt;/tfoot&gt;：用于定义表格的页脚，位于 &lt;table&gt;&lt;/table&gt; 标记中 &lt;tbody&gt;&lt;/tbody&gt; 标记之后，一般包含网页底部的企业信息等。 补充知识：单元格的合并横向合并12345&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan="2"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415&lt;!-- 实例展示 --&gt;&lt;table border="1" cellspacing="0" cellpadding="20"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan="2"&gt;年龄&lt;/th&gt; &lt;!--&lt;th&gt;职业&lt;/th&gt;--&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;码农&lt;/td&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄籍贯小明18码农江苏 纵向合并12345678910&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan="2"&gt;&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;!--&lt;td&gt;&lt;/td&gt;--&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 实例展示：123456789101112131415161718192021&lt;!-- 实例展示 --&gt;&lt;table border="1" cellspacing="0" cellpadding="20"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td rowspan="2"&gt;码农&lt;/td&gt; &lt;!-- 纵向合并 --&gt; &lt;td&gt;江苏&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;!--&lt;td&gt;前端&lt;/td&gt;--&gt; &lt;td&gt;北京&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果演示： 姓名年龄职业籍贯小明18程序猿江苏小白21北京 表单（form）表单介绍表单的作用：主要负责数据采集功能。 对于表单构成中的表单控件、提示信息和表单域，对他们的具体解释如下： 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 基本语法：1&lt;form name="form_name" action="url" method="get|post"&gt;…&lt;/form&gt; 属性介绍： Name ：定义表单的名称； Action ：用来指定表单处理程序的位置（服务器端脚本处理程序）； Method: 定义表单结果从浏览器传送到服务器的方式，默认参数为：get。 get数据提交：① 通过地址栏的方式进行数据提交，将用户输入的信息显出来；② get提交安全性差。 post提交：① 数据通过后台进行提交，不会将用户信息显示出来；② 安全性比较好。 表单域123&lt;form action=""&gt; …&lt;/form&gt; 容纳表单空间和提示信息的一个区域。 表单控件input 控件语法：1&lt;input type=“控件类型”&gt; 在上面的语法中，&lt;input&gt; 标记为单标记，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input&gt; 标记还可以定义很多其他的属性，其常用属性如下表所示。 属性 属性值 描述 type textpasswordradiocheckboxbuttonsubmitresetimagehiddenfile 单行文本输入框密码输入框单选按钮复选框普通按钮提交按钮重置按钮图像形式的提交按钮隐藏域文件域 name 由用户自定义 控件的名称 value 由用户自定义 input 控件中的默认文本值 size 正整数 input 控件在页面中的显示宽度 readonly readonly 该控件内容为只读（不能编辑修改） disabled disabled 第一次加载页面时禁用该控件（显示为灰色） 文本输入框12&lt;!-- 文本输入框 --&gt;用户名：&lt;input type="text" maxlength="6" name="username" value="1234" &gt; 效果演示：用户名： 属性: maxlength：设置文本输入框最多能输多少字符 readonly=”readonly”：设置文本输入框为只读（不能编辑） disabled+”disabled”：控件属于非激活状态 name=”username”：给输入框设置名称 value：设置默认显示的值 密码输入框12&lt;!-- 密码输入框 --&gt;密码：&lt;input type="password" name="pwd" value="123"&gt; 效果演示：密码： 属性用法与文本输入框的用法一样。 单选按钮1234&lt;!-- 单选按钮 --&gt;性别：&lt;input type="radio" name="xb" checked="checked" value="nan"&gt;男&lt;input type="radio" name="xb" value="nv" &gt;女 效果演示：性别：男 女 注意：实现单选效果一定要给控件设置相同的名称 属性： checked=”checked”：设置默认选中项 多选控件1234兴趣爱好：&lt;input type="checkbox" checked="checked"&gt;抽烟&lt;input type="checkbox" checked="checked"&gt;喝酒&lt;input type="checkbox" checked="checked"&gt;烫头 效果演示：兴趣爱好：抽烟喝酒烫头 属性： checked=”checked”：设置默认选中项 图片上传控件12头像：&lt;input type="file"&gt; 效果演示：头像： 表单提交按钮12&lt;!-- 表单提交按钮 --&gt;&lt;input type="submit" value="登录"&gt; 效果演示： 普通按钮12&lt;!-- 普通按钮 --&gt;&lt;input type="button" value="普通按钮"&gt; 效果演示： 注意：该按钮不能进行表单提交。通常和 js 代码配合使用。 重置按钮清空所有表单数据，恢复到初始状态12&lt;!-- 重置按钮 --&gt;&lt;input type="reset"&gt; 效果演示： 图片按钮12&lt;!-- 图片按钮 --&gt;&lt;input type="image" src="按钮.jpg"&gt; 注意：该控件也可以进行表单的提交。 select 控件在 HTML 中，要想制作下拉菜单，就需要使用select控件。 下拉列表123456789出生地：省：&lt;select multiple="multiple"&gt; &lt;option&gt;山东&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;option&gt;河南&lt;/option&gt; &lt;option&gt;河北&lt;/option&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt;&lt;/select&gt; 效果演示：出生地：省： 山东 山西 河南 河北 北京 属性： selected=”selected”：设置默认选中项 multiple=”multiple”：可以实现多选效果 下拉列表分组显示123456789101112131415市(区)：&lt;select id="name"&gt; &lt;optgroup label="北京市"&gt; &lt;option&gt;西城区 &lt;/option&gt; &lt;option&gt;东城区&lt;/option&gt; &lt;option&gt;海淀区&lt;/option&gt; &lt;option&gt;昌平区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="上海市"&gt; &lt;option&gt;黄浦区 &lt;/option&gt; &lt;option&gt;松江区&lt;/option&gt; &lt;option&gt;浦东新区&lt;/option&gt; &lt;option&gt;静安区&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 效果演示：市(区)： 西城区 东城区 海淀区 昌平区 黄浦区 松江区 浦东新区 静安区 textarea 控件如果需要输入大量的信息，就需要用到 &lt;textarea&gt;&lt;/textarea&gt; 标记。通过 textarea 控件可以轻松地创建多行文本输入框，其基本语法格式如下：123&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt; 文本内容&lt;/textarea&gt; 属性： cols：相当于宽度 rows：相当于高度 123自我介绍：&lt;textarea cols="20" rows="5"&gt;&lt;/textarea&gt; 效果演示：自我介绍： 组合表单fieldset 用于表单分组。语法：123&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt;&lt;/fieldset&gt; 举例：1234567&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt; 用户名：&lt;input type="text" maxlength="6" name="username" value="" &gt; &lt;br&gt; &lt;br&gt; 密码：&lt;input type="password" name="pwd" value="123"&gt;&lt;/fieldset&gt; 效果演示： 用户注册 用户名： 密码： 表单补充判断网址123&lt;!-- 判断网址 --&gt;&lt;input type="url"&gt;&lt;input type="submit"&gt; 效果演示： 判断邮箱123&lt;!-- 判断邮箱 --&gt;&lt;input type="email"&gt;&lt;input type="submit"&gt; 效果演示： 日期控件123&lt;!-- 日期控件 --&gt;&lt;input type="date"&gt;&lt;input type="submit"&gt; 效果演示： 时间控件123&lt;!-- 时间控件 --&gt;&lt;input type="time"&gt;&lt;input type="submit"&gt; 效果演示： 带有 spinner 控件的数字字段123&lt;!-- 带有 spinner 控件的数字字段 --&gt;&lt;input type="number"&gt;&lt;input type="submit"&gt; 属性： step：表示每次加减的值（即步长） 效果演示： 带有 slider 控件的数字字段123&lt;!-- 带有 slider 控件的数字字段 --&gt;&lt;input type="range"&gt;&lt;input type="submit"&gt; 属性： max：最大值 min：最小值 step：每次加减的值（即步长） 效果演示： 定义拾色器123&lt;!-- 定义拾色器 --&gt;&lt;input type="color"&gt;&lt;input type="submit"&gt; 效果演示： 标签语义化 标签语义化概念： 根据内容的结构化（内容语义化），选择合适的标签（代码语义化） 标签语义化意义： 1: 网页结构合理 2: 有利于 SEO :和搜索引擎建立良好沟通，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取； 3: 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）; 4: 便于团队开发和维护. 标签语义化（注意事项） 1：尽可能少的使用无语义的标签 div 和 span ； 2：在语义不明显时，既可以使用 div 或者 p 时，尽量用 p, 因为 p 在默认情况下有上下间距，对兼容特殊终端有利； 3：不要使用纯样式标签，如：b、font、u 等，改用 css 设置。 4：需要强调的文本，可以包含在 strong 或者 em 标签中。strong 默认样式是加粗（不要用b），em 是斜体（不用 i ）； 总结我的 html 基础学习是跟着传智播客2016年的视频课程学习的，基础就这些内容，特别整理下来以加深记忆。内容或多或少会与网络上的内容有些许出入。总的来说 html 很简单，很容易上手。但这只是基础，html + css + javascript 才能做出真正漂亮的网页。 千里之行，始于足下，接下来的路，加油！]]></content>
      <categories>
        <category>html+css+js</category>
      </categories>
      <tags>
        <tag>html+css+js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观建军90周年阅兵之感悟]]></title>
    <url>%2Fposts%2Fliving%2F2017-07-30-view-of-army-building-90th.html</url>
    <content type="text"><![CDATA[恰逢 中国人民解放军建军 90 周年 ，下一个百年会是什么样的盛况？十年后的今天，肯定特别隆重，中国军队更加现代化，中国的综合实力更加强胜。2017 年 7 月 30 日，一个小阅兵式，不比 2015 年的 9.3 阅兵，但也足以展示中国军队的强势！ 2017 年 7 月 30 日 9 时，在朱日和训练基地隆重举行了庆祝建军 90 周年阅兵式。中共中央总书记、国家主席、中央军委主席习近平检阅部队并发表重要讲话。 政治觉悟强、思想素质高的我专门观看了这场直播。看的真是个热血沸腾！尤其是国歌响起的时候，看到我们的军队气势如虹，中国已经不是以前的模样了！她那么年轻，又那么富有活力，最重要的是有一群铁骨铮铮的人的在守卫着她的每一寸土地和国民。 从 1927 到 2017 ，中国军队走过了漫长的岁月，中国军队日益强大。车牌 1927 和 2017 相互对接，是一种历史的传承。 《国歌》 国歌响起的刹那，热泪盈眶。每一个中国人都熟悉的一首歌，竟这样好听。习大大在主席台上也跟着音乐在哼唱着。 《检阅进行曲》 习大大身着迷彩登上车牌 2017 的野战车的时候，《检阅进行曲》响起，一排排列队整齐的军队，一辆辆现代化的作战车辆，一架架直升机、空中梯队，严阵以待，等待着党和人民的检阅。 《分列式进行曲》 这就是我们的军队，这是人民的军队。 时至今日，兔子们已经把种花家变成了蓝星最牛的堂口之一，他走过骨血硝烟，走过繁花似锦，曾跌入泥潭，也能踏上云端。 每一只兔子都有一个大国梦。今生不悔入华夏，来世还愿种花家。 『 幸福并感激着！ 』]]></content>
      <categories>
        <category>living</category>
      </categories>
      <tags>
        <tag>living</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 浏览器设置 XX-Net 的方法（Windows）]]></title>
    <url>%2Fposts%2FChrome%2F2017-07-27-method-setup-XX-Net-Chrome-Windows.html</url>
    <content type="text"><![CDATA[本文详细介绍如何在一台 Windows 电脑上架设起 Chrome + XX-Net 的上网渠道。XX-Net 对于需要翻墙的用户来说非常方便。尤其是配置了自己的私有 appid 后，浏览外网毫无压力。在整个部署过程中可能有部分网页需要翻墙才可以进入，可以暂时使用 Lantern 进行翻墙。Lantern 下载地址：http://or2dtuwv6.bkt.clouddn.com/lantern-installer.exe 下载安装 Chrome 浏览器 Chrome 下载地址：https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html这一步很简单，直接跳过。 获取和运行 XX-Net 打开链接，选择稳定版下载。https://github.com/XX-net/XX-Net/blob/master/code/default/download.md 下载完毕后解压缩文件夹，运行文件夹中 start.vbs 文件。 如果弹出管理员权限请求（用户账户控制），请允许。 首次运行可能会弹出防火墙警告，请允许访问。 设置代理方法一：简单方法 启动 XX-Net 后，右下角会出现托盘图标。右键单击托盘图标，点击“全局 PAC 智能代理”即可。 方法二：安装和使用代理切换插件 打开 XX-Net/SwitchyOmega 文件夹；打开 Chrome 浏览器的扩展程序页面 chrome://extensions 。把 SwitchyOmega.crx 文件拖放到浏览器扩展程序页面安装。如图: 此时。浏览器上方会出现对话框，点击添加扩展程序。 进入 SwitchOmega 页面，第一次进来，选择跳过教程； 点击界面左侧栏的导入/导出，选择从备份文件恢复： 点击从备份文件中恢复后，找到 XX-Net/SwitchyOmega/OmegaOptions.bak 文件，点击打开： 点击左侧栏“情景模式”下的 XX-Net自动切换； 下拉点击立即更新情景模式 点击 Chrome 右上角的 SwitchOmega，切换成 “XX-Net自动切换”； 到此，浏览器端设置代理也就完成了，还需最后一步，把 XX-Net 切换为“取消全局代理”，就可以畅游网络了。 但是此时用的是 公共 APPID，因为资源有限，使用上存在限制，建议部署私有 APPID。 配置个人 APPID登录 Google 账户 https://www.google.com/ncr (若无帐户，需注册) 创建 APPID 打开 https://console.cloud.google.com/start ，点击选择项目，然后点击创建项目： 输入项目名称后，会自动帮你匹配可用ID，然后左击创建(请细读此教程底部说明) 设置 APPID 的 App 引擎 点击激活 Google云端Shell，点击启动云端SHELL进入Shell； 在页面底部输入 gcloud config set project 项目ID,按下键盘的enter键； 然后输入 gcloud beta app create --region us-central ，再按一次enter； 当底部出现 Success! The app is now created. Please use &#39;gcloud app deploy&#39; to deploy your first app. 时，创建 appid 成功。此时可以重复前面两步，创建更多的 appid； 部署服务器端 打开 XX-Net 的设置页：http://127.0.0.1:8085 ，切换到部署服务端； 输入AppID（多个APPID中间使用 | 隔开），“Show Debug Log”选择为 On ，点击 开始部署 ； 弹出授权窗口，点击 Allow（允许），然后就会进行服务端的部署； 日志 里面显示如下信息，则说明部署完成； 部署完成后，切换到 配置 ，输入部署好的 APPID 后点击 保存。 切换到 状态 来确认部署的状态，如果一切正常，那么恭喜你，现在可以流畅的翻墙喽~~~ 说明 每个 AppID 每天1G流量，一般每个 Google 帐户最多12个 AppID； AppID 的数量只影响流量，不影响速度； 若部署过程中始终无法弹出窗口 , 建议使用ss部署服务端； 若部署一直失败，可以安装 Google Cloud SDK，gcloud init 设置代理，gcloud app deploy 上传 gae 文件夹，在 app.yaml 中不要指定 application 和 version。]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>XX-Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArcGIS Engine 地图操作基础——地图文档保存]]></title>
    <url>%2Fposts%2FArcGIS%2F2017-06-13-ArcGIS-Engine-map-basic-save-documents.html</url>
    <content type="text"><![CDATA[在对地图文档进行修改后，经常需要对其进行保存。地图文档的保存分为直接保存和另存为两种。这里的保存仅仅只是修改地图文档文件记录的信息，并不会对数据进行更改。保存地图文档的一般格式是 *.mxd 格式。 地图文档保存实例程序实现思路 (1) 地图文档的保存主要使用 IMapDocument 接口。首先使用 IMxdContents 接口读取已打开地图文档的内容，并使之替换 IMapDocument 接口的实例对象。 (2) 保存时使用 IMapDocument 接口的 Save 方法，函数原型为 public void Save(bool bUseRelativePaths, bool bCreateThumnbail) 参数 描述 bUseRelativePaths 是否保存为相对路径（区别于绝对路径） bCreateThumnbail 表示保存的地图在 ArcCatalog 中查看时是否显示缩略图 1234567891011121314151617181920212223242526272829303132333435363738394041424344//保存地图private void SaveMap_Click(object sender, EventArgs e)&#123; try &#123; string sMxdFileName = mainMapControl.DocumentFilename; IMapDocument pMapDocument = new MapDocumentClass(); if (sMxdFileName!=null &amp;&amp; mainMapControl.CheckMxFile(sMxdFileName)) &#123; if (pMapDocument.get_IsReadOnly(sMxdFileName)) &#123; MessageBox.Show("本地图文档是只读的，不能保存!"); pMapDocument.Close(); return; &#125; &#125; else &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = "请选择保存路径"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = "ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; sMxdFileName = pSaveFileDialog.FileName; &#125; else &#123; return; &#125; &#125; pMapDocument.New(sMxdFileName); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(pMapDocument.UsesRelativePaths, true); pMapDocument.Close(); MessageBox.Show("保存地图文档成功!"); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125;&#125; 地图文档另存为实例程序实现思路 (1) 地图文档的另存为与保存的方法类似，保存前需判断保存的路径里是否存在相同的文件； (2) 另存为需要用 IMapDocument 接口的 New 方法创建新的路径。 123456789101112131415161718192021222324252627282930//地图另存为private void btnSaveAsMap_Click(object sender, EventArgs e)&#123; try &#123; SaveFileDialog pSaveFileDialog = new SaveFileDialog(); pSaveFileDialog.Title = "另存为"; pSaveFileDialog.OverwritePrompt = true; pSaveFileDialog.Filter = "ArcMap文档（*.mxd）|*.mxd|ArcMap模板（*.mxt）|*.mxt"; pSaveFileDialog.RestoreDirectory = true; if (pSaveFileDialog.ShowDialog() == DialogResult.OK) &#123; string sFilePath = pSaveFileDialog.FileName; IMapDocument pMapDocument = new MapDocumentClass(); pMapDocument.New(sFilePath); pMapDocument.ReplaceContents(mainMapControl.Map as IMxdContents); pMapDocument.Save(true, true); pMapDocument.Close(); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; //也可以使用 ArcGIS Engine 中封装好的类库资源 ControlsSaveAsDocCommandClass 实现地图文档的另存为： //ICommand command = new ControlsSaveAsDocCommandClass(); //command.OnCreate(mainMapControl.Object); //command.OnClick();&#125;]]></content>
      <categories>
        <category>ArcGIS</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>AE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建个人博客（小白版图文教程）]]></title>
    <url>%2Fposts%2FHexo-Github%2F2017-06-09-Hexo-Github-build-blog-so-easy.html</url>
    <content type="text"><![CDATA[本人技术小白，折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了个人博客。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。有过经历，才知道好的教程的重要性。因而我将自己的经验分享出来~ 写在前面最近兴趣使然，想要搭建一个个人博客。每次看到别人拥有自己的个人主页都特别羡慕，一直想着自己有一个博客该有多好啊。就这样折腾了两天时间，看遍了网上各种各样杂乱的教程，走了很多弯路，终于成功搭建出来了。等到结束的那一刻，心里很是开心。回想这一整个步骤，其实并不难，很简单就能掌握。由于自己是技术小白，很多大神写的教程看了依旧操作错误。多么希望有人能手把手的教你每一步做什么。有过经历，才知道好的教程的重要性。因而我将自己建站的步骤详细记录下来，以供参考。希望后面想要建站的人不要走弯路了哦~ 搭建环境配置 Node.js 环境下载 Node.js 安装文件，根据自己电脑的位数，选择下载32位或者64位的：http://nodejs.cn/download/然后安装下载的文件，保持默认设置就好了，一路点 Next ，很快就安装完成了。接着检查一下 Node 是否安装好，打开运行窗口，输入 cmd ，打开命令行： 在命令行分别输入以下命令：12node -vnpm -v 如果出现下图界面，则说明 node 安装正确。可以进入下一步了。 配置 Git 环境去官网下载 Git 安装文件: https://git-scm.com/downloads 接着进行安装，如下图，在 Windows Explorer integration 这一项及下边的两项都打上勾： 然后一直 Next 就可以了，安装完成后同样检查一下 Git 是否正确安装。 Github账户的注册和代码库的创建Github帐号注册，打开链接：https://github.com/，申请一个 Github 帐号；注册好之后还需要确认邮箱，打开注册的邮箱，确认注册，然后进入下一步；点击页面右上角自己的头像，点击下拉菜单的New repository，创建一个新的代码库：代码库的名字最好与你的用户名相同，格式为 yourname.github.io ，比如我的用户名是 renkaitest，那我的代码库名即为 renkaitest.github.io创建成功后出现下图所示界面，点击右边的复制按钮，复制这个地址： 配置 Github pages随便找一个目录，右击鼠标，选择Git Bash Here，打开一个类似命令行的界面，输入以下代码：1$ git clone https://github.com/username/username.github.io clone 后面的链接即就是上一步复制的那个链接，比如我的就是下面的代码： 1$ git clone https://github.com/renkaitest/renkaitest.github.io 然后输入 cd 你的代码库名 ，例如 cd renkaitest.github.io ，也可以直接进入该目录下的一个名为 renkaitest.github.io 的文件夹。1$ cd renkaitest.github.io 然后输入： 1$ echo "Hello World" &gt; index.html 接着输入：12$ git add --all$ git commit -m "Initial commit" 这里会出现一个错误，是因为我们没有设置Git的 user name 和 email ，此时输入以下代码： 12$ git config --global user.email "541638321@qq.com"$ git config --global user.name "renkaitest" 注意：上面的 name 和 email 都要换成自己的邮箱和用户名 此时继续执行以下代码： 1$ git commit -m "Initial commit" 下面 push 到你的代码库，输入代码：1$ git push -u origin master 可能会弹出以下界面让你登录，使用 Github 帐号登录即可。 此时你的 Github Pages 已经配置好了，打开 yourname.github,io 这个网址就能看到你的博客了，yourname 替换成你自己的用户名。 Hexo安装找一个目录，我是在 d:\Hexo 目录下，鼠标右击打开 Git Bash Here，输入：1$ npm install hexo-cli -g 可能会看到一个 WARN，但是没关系的，进入下一步。输入：1$ npm install hexo --save 等一段时间，他安装完之后检查一下是否安装成功，输入： 1$ hexo -v 看到相关的版本信息则说明安装成功。 Hexo配置初始化 Hexo，首先需要找一个目录，这个目录即就是你的博客的所有文件存放的目录，最好路径不要太深，我选择的是 D:\Hexo\blog 。在这个路径下打开 Git Bash Here ，输入代码：1$ hexo init 然后输入：1$ npm stall 这里 npm 会自动帮你安装你需要的组件。继续输入：1$ hexo g 生成博客。输入：1$ hexo s 启动服务，会提示以下信息：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器打开 http://localhost:4000/ ，将会看到自己的 hexo 博客： 关联 Hexo 与 Github Page配置Git个人信息如果你之前已经配置好git个人信息，请跳过这一个步骤，直接来到步骤2设置Git的user name和email：（如果是第一次的话）12$ git config --global user.name "renkaitset"$ git config --global user.email "541638321@qq.com" 生成密钥1$ ssh-keygen -t rsa -C "541638321@qq.com" 输入代码后一直按回车就好了，不用自己定义目录，生成的 ssh 会存放在 C:\Users\用户名\.ssh 目录下，如果找不到 .ssh 目录，请在文件夹选项中显示隐藏的项目。 配置 SSH 密匙进入 Github 网页，点击右上角自己的头像，选择 Settings ：配置 SSH and GPG keys ，点击 New SSH key：用 txt 打开刚才生成的 Key，复制到下图所示区域，点击 Add SSH key： 配置 Deployment打开博客目录下的站点配置文件 _config.yml ，比如我的博客目录是 D:\Hexo\blog，找到该目录下的 _config.yml。打开他，在最末尾找到 Deployment ，然后按照如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 上面的 yourname 都要替换成自己的用户名，以我的为例：1234deploy: type: git repo: git@github.com:renkaitest/renkaitest.github.io.git branch: master 这样就配置好了，接下来就可以写博客了。 发布博文新建一篇博文，在博客存放的目录里面 Git Bash Here ，执行命令：1$ hexo new post "我的第一篇博文" 然后就会在电脑的目录下 D:\Hexo\blog\source\_posts 看到一个 我的第一篇博文.md 文件，使用 MarkDown 编辑这篇文章就可以了。文章编辑好后，运行生成、部署命令。但是此时还缺少一个扩展，因而不能部署，先要执行以下命令：1$ npm install hexo-deployer-git --save 如果没有执行这个命令，将会提醒： deloyer not found:git 现在开始执行：12$ hexo g // 生成$ hexo d // 部署 也可以将这两个命令一起执行：1$ hexo d -g //在部署前先生成 若出现如下图所示的信息 INFO Deploy done: git ，则表示部署成功，已经上传到你的代码库。此时访问你的地址 https://yourname.github.io ，将会看到刚才写的文章了。注：我的主题是自己换过的，可能与你的显示结果有所不同，做到这一步，你已经成功搭建了自己的博客。已经大功告成了！恭喜你~ 总结以后发布博文，就是以下的步骤： 写博文： 1$ hexo new post "博文名字" 生成博文： 1$ hexo g 部署博文： 1$ hexo d 由于网络原因，进入你的网页可能不会立即显示最新的信息。过几分钟就好了~]]></content>
      <categories>
        <category>Hexo+Github</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArcGIS Engine 地图操作基础——数据加载]]></title>
    <url>%2Fposts%2FArcGIS%2F2017-06-05-ArcGIS-Engine-map-basic-load-data.html</url>
    <content type="text"><![CDATA[数据加载是 ArcGIS Engine 中最基础的操作，AE 支持的数据广泛，包含矢量数据、栅格数据、CAD 数据、Excel数据等等，这些数据的加载有助于我们使用 AE 做进一步的数据处理与分析。 加载地图文档地图文档可以是一个ArcMap文档（*.mxd）或者ArcMap模版（*.mxt）或ArcReader文件（*.pmf）。 加载地图文档的方式有三种： 使用 IMapControl 接口的 LoadMxFile 方法加载； 通过 IMapDocument 接口加载; 使用 ArcGIS Engine 中封装好的类库资源 ControlsOpenDocCommandClass 加载。 LoadMxFile 方法加载地图文档文件1234567891011121314151617181920212223242526272829303132333435private void BtnLoadMxFile_Click(object sender, EventArgs e)&#123; //加载数据前如果有数据则清空 try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = "打开地图文档"; pOpenFileDialog.Filter = "ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf"; pOpenFileDialog.Multiselect = false; //不允许多个文件同时选择 pOpenFileDialog.RestoreDirectory = true; //存储打开的文件路径 if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == "") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; ClearAllData(); mainMapControl.LoadMxFile(pFileName); &#125; else &#123; MessageBox.Show(pFileName + "是无效的地图文档!", "信息提示"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show("打开地图文档失败" + ex.Message); &#125;&#125; 关于 ClearAllData 函数: 1234567891011121314151617private void ClearAllData()&#123; if (mainMapControl.Map != null &amp;&amp; mainMapControl.Map.LayerCount &gt; 0) &#123; //新建mainMapControl中Map IMap dataMap = new MapClass(); dataMap.Name = "Map"; mainMapControl.DocumentFilename = string.Empty; mainMapControl.Map = dataMap; //新建EagleEyeMapControl中Map IMap eagleEyeMap = new MapClass(); eagleEyeMap.Name = "eagleEyeMap"; EagleEyeMapControl.DocumentFilename = string.Empty; EagleEyeMapControl.Map = eagleEyeMap; &#125;&#125; IMapDocument 方法加载 Mxd 文档文件123456789101112131415161718192021222324252627282930313233343536373839private void BtnIMapDocument_Click(object sender, EventArgs e)&#123; try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = "打开地图文档"; pOpenFileDialog.Filter = "ArcMap文档(*.mxd)|*.mxd;|ArcMap模板(*.mxt)|*.mxt|发布地图文件(*.pmf)|*.pmf|所有地图格式(*.mxd;*.mxt;*.pmf)|*.mxd;*.mxt;*.pmf"; pOpenFileDialog.Multiselect = false; pOpenFileDialog.RestoreDirectory = true; if (pOpenFileDialog.ShowDialog() == DialogResult.OK) &#123; string pFileName = pOpenFileDialog.FileName; if (pFileName == "") &#123; return; &#125; if (mainMapControl.CheckMxFile(pFileName)) //检查地图文档有效性 &#123; //将数据载入pMapDocument并与Map控件关联 IMapDocument pMapDocument = new MapDocument();//using ESRI.ArcGIS.Carto; pMapDocument.Open(pFileName, ""); //获取Map中激活的地图文档 mainMapControl.Map = pMapDocument.ActiveView.FocusMap; mainMapControl.ActiveView.Refresh(); &#125; else &#123; MessageBox.Show(pFileName + "是无效的地图文档!", "信息提示"); return; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show("打开地图文档失败" + ex.Message); &#125;&#125; ControlsOpenDocCommandClass 加载地图123456private void BtncontrolsOpenDocCommandClass_Click(object sender, EventArgs e)&#123; ICommand command = new ControlsOpenDocCommandClass(); command.OnCreate(mainMapControl.Object); command.OnClick();&#125; 加载 Shapefile 数据加载 Shapefile 数据的方式有两种： 通过工作空间加载； 通过 MapControl 空间的 AddShapefile 方法加载 通过工作空间加载实例程序实现思路： (1) 创建 ShapefileWorkspaceFactory 实例 pWorkspaceFactory ，使用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 pFeatureWorkspace 中存储的基于 Shapefile 的工作区。 (2) 创建 FeatureLayer 的实例 pFeatureLayer ，并定义数据集。 (3) 使用 IMap 接口的 AddLayer 方法加载 pFeatureLayer 到当前地图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void AddShp_Click(object sender, EventArgs e)&#123; //ClearAllData(); try &#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = "打开Shape文件"; pOpenFileDialog.Filter = "Shape文件（*.shp）|*.shp"; pOpenFileDialog.ShowDialog(); ////获取文件路径,此即为第二种方法 //FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName); //string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); //mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 获取文件路径 IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; string pFullPath = pOpenFileDialog.FileName; if (pFullPath == "") return; int pIndex = pFullPath.LastIndexOf("\\"); //lastIndexOf是从字符串末尾开始检索，检索到子字符，则返回子字符在字符串中的位置，（位置从前向后数，最小位为0，也就是从第0位开始算起）未检测到则返回-1。 string pFilePath = pFullPath.Substring(0, pIndex); //文件路径 string pFileName = pFullPath.Substring(pIndex + 1); //文件名 /*substring(参数)是java中截取字符串的一个方法 有两种传参方式 一种是 public String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 另一种是 public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 */ //实例化ShapefileWorkspaceFactory工作空间，打开Shape文件 pWorkspaceFactory = new ShapefileWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //创建并实例化要素集 IFeatureClass pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName); pFeatureLayer = new FeatureLayer(); pFeatureLayer.FeatureClass = pFeatureClass; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName;//获取别名 ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer);//加载图层 mainMapControl.ActiveView.Refresh(); //同步鹰眼.可有可无 SynchronizeEagleEye(); &#125; catch (Exception ex) &#123; MessageBox.Show("图层加载失败！" + ex.Message); &#125;&#125; 通过 MapControl 空间的 AddShapefile 方法加载 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。 1234567891011121314private void AddShp2_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = "打开Shape文件"; pOpenFileDialog.Filter = "Shape文件（*.shp）|*.shp"; pOpenFileDialog.ShowDialog(); //获取文件路径 FileInfo pFileInfo = new FileInfo(pOpenFileDialog.FileName);//FileInfo需要using system.IO string pPath = pOpenFileDialog.FileName.Substring(0, pOpenFileDialog.FileName.Length - pFileInfo.Name.Length); mainMapControl.AddShapeFile(pPath, pFileInfo.Name); // 调用该方法需要传入两个参数，分别是文件路径和不带扩展名的文件名。&#125; 加载栅格数据实例程序实现思路： 在加载栅格文件时，需引用 ESRI.ArcGIS.DataSourcesRaster 命名空间。 (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得栅格文件的工作区； (2) 用 IRasterWorkspace 接口的 OpenRasterDataset 方法获得栅格文件的数据集，实例化栅格文件对象，并对栅格数据集是否具有金字塔进行判断（这里栅格文件如果不具有金字塔则创建金字塔，可以提高大数据量图像的显示效率）； (3) 创建 RasterLayer 类的实例 pRasterLayer ，并定义其数据集； (4) 使用 MapControl 控件的 AllLayer 方法将 pRasterLayer 添加至当前地图。 123456789101112131415161718192021222324252627282930313233343536373839private void AddRaster_Click(object sender, EventArgs e)&#123; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.CheckFileExists = true; pOpenFileDialog.Title = "打开Raster文件"; pOpenFileDialog.Filter = "栅格文件 (*.*)|*.bmp;*.tif;*.jpg;*.img|(*.bmp)|*.bmp|(*.tif)|*.tif|(*.jpg)|*.jpg|(*.img)|*.img"; pOpenFileDialog.ShowDialog(); string pRasterFileName = pOpenFileDialog.FileName; if (pRasterFileName == "") &#123; return; &#125; string pPath = System.IO.Path.GetDirectoryName(pRasterFileName); string pFileName = System.IO.Path.GetFileName(pRasterFileName); IWorkspaceFactory pWorkspaceFactory = new RasterWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(pPath, 0); IRasterWorkspace pRasterWorkspace = pWorkspace as IRasterWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pFileName); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRaster pRaster; pRaster = pRasterDataset.CreateDefaultRaster(); IRasterLayer pRasterLayer; pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromRaster(pRaster); mainMapControl.Map.AddLayer(pLayer);//加载shp文件时是这样弄得，经过尝试这样也是可以的，具体有什么区别不可知 //mainMapControl.AddLayer(pLayer, 0);//这是书上的源代码&#125; 加载 CAD 数据对于 ArcGIS Engine 来说，有两种不同的方式使用 CAD 数据：① 作为要素图层，以矢量数据来使用；② 作为地图背景，以栅格数据来使用。对于前者， ArcGIS Engine 使用与 FeatureLayer 一样的方法来管理，对于后者则采用 CadLayer 对象来管理。 CAD 文件作为矢量图层加载分图层加载实例程序实现思路： (1) CAD 图可以分为点、线、面、标注，它们可以分别被加载到 MapControl 中。与加载其他数据一样，首先定义一个工作空间，用 CadWorkspaceFactoryClass 实例化工作空间，并打开相应的工作空间； (2) 创建 FeatureLayer 的实例，定义数据集，使用 IMap 接口的 AddLayer 方法将要素图层添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435363738394041private void AddCADByLayer_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureClass pFeatureClass; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = "CAD(*.dwg)|*.dwg"; pOpenFileDialog.Title = "打开CAD数据文件"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == "") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf("\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pWorkspaceFactory = new CadWorkspaceFactory(); pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //加载CAD文件中的线文件 pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + ":polyline"); //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + ":polygon");//打开多边形 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + ":point");//打开点 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + ":multipatch");//打开多面体 //pFeatureClass = pFeatureWorkspace.OpenFeatureClass(pFileName + ":annotation");//打开标注是这样吗？自己尝试失败，打开的是点，什么鬼？搞不懂。。。 pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFileName; pFeatureLayer.FeatureClass = pFeatureClass; ClearAllData(); //新增删除数据 mainMapControl.Map.AddLayer(pFeatureLayer); mainMapControl.ActiveView.Refresh(); //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; 整幅图加载实例程序实现思路： 将 CAD 作为整幅图加载时，在得到相应的工作空间之后对 CAD 文件中的要素进行遍历，并判断是否为注记图层，如果是注记则需要使用 CadAnnotationLayer 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void AddWholeCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pWorkspaceFactory; IFeatureWorkspace pFeatureWorkspace; IFeatureLayer pFeatureLayer; IFeatureDataset pFeatureDataset; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = "CAD(*.dwg)|*.dwg"; pOpenFileDialog.Title = "打开CAD数据文件"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == "") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf("\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); //打开CAD数据集 pWorkspaceFactory = new CadWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesFile; pFeatureWorkspace = (IFeatureWorkspace)pWorkspaceFactory.OpenFromFile(pFilePath, 0); //打开一个要素集 pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pFileName); //IFeatureClassContainer可以管理IFeatureDataset中的每个要素类 IFeatureClassContainer pFeatClassContainer = (IFeatureClassContainer)pFeatureDataset; ClearAllData(); //新增删除数据 //对CAD文件中的要素进行遍历处理 for (int i = 0; i &lt; pFeatClassContainer.ClassCount; i++) &#123; IFeatureClass pFeatClass = pFeatClassContainer.get_Class(i); //如果是注记，则添加注记层 if (pFeatClass.FeatureType == esriFeatureType.esriFTCoverageAnnotation) &#123; pFeatureLayer = new CadAnnotationLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; else //如果是点、线、面则添加要素层 &#123; pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFeatClass.AliasName; pFeatureLayer.FeatureClass = pFeatClass; mainMapControl.Map.AddLayer(pFeatureLayer); &#125; mainMapControl.ActiveView.Refresh(); &#125; //同步鹰眼，可有可无 SynchronizeEagleEye();&#125; CAD 文件作为栅格图层加载实例程序实现思路： (1) 用 IWorkspaceFactory 接口的 OpenFromFile 方法获得 CAD 文件的工作区； (2) 用 ICadDrawingWorkspace 接口的 OpenCadDrawingDataset 方法获得 CAD 文件的数据集，并将其赋值给 CadLayerClass 类的实例对象 pCadLayer 的 CadDrawingDataset 属性； (3) 使用 IMap 接口的 AddLayer 方法将 pCadLayer 添加至当前地图。 1234567891011121314151617181920212223242526272829303132333435private void AddRasterByCAD_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pCadWorkspaceFactory; IWorkspace pWorkspace; ICadDrawingWorkspace pCadDrawingWorkspace; ICadDrawingDataset pCadDrawingDataset; ICadLayer pCadLayer; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = "CAD(*.dwg)|*.dwg"; pOpenFileDialog.Title = "打开CAD数据文件"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == "") &#123; return; &#125; //获取文件名和文件路径 int pIndex = pFullPath.LastIndexOf("\\"); string pFilePath = pFullPath.Substring(0, pIndex); string pFileName = pFullPath.Substring(pIndex + 1); pCadWorkspaceFactory = new CadWorkspaceFactoryClass(); pWorkspace = pCadWorkspaceFactory.OpenFromFile(pFilePath, 0); pCadDrawingWorkspace = (ICadDrawingWorkspace)pWorkspace; //获得CAD文件的数据集 pCadDrawingDataset = pCadDrawingWorkspace.OpenCadDrawingDataset(pFileName); pCadLayer = new CadLayerClass(); pCadLayer.CadDrawingDataset = pCadDrawingDataset; pCadLayer.Name = pFileName;//书中代码没有这一句，打开的结果是TOC面板里面没有文件的名字，故而自己添上了这一句 mainMapControl.Map.AddLayer(pCadLayer); mainMapControl.ActiveView.Refresh();&#125; 加载个人地理数据库个人地理数据库（Personal Geodatabase）使用 Micorosoft Access 文件（*.mdb）进行空间数据的存储与管理，它将不同的数据同一纳入 Access 文件中，便于数据的管理与迁移，容量限制为2GB。个人地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 创建 AccessWorkspaceFactory 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开 *.mdb 数据集的工作空间，对工作空间里面的数据进行加载。 1234567891011121314151617181920212223private void AddPersonGDB_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pAccessWorkspaceFactory; OpenFileDialog pOpenFileDialog = new OpenFileDialog(); pOpenFileDialog.Filter = "Personal Geodatabase(*.mdb)|*.mdb"; pOpenFileDialog.Title = "打开PersonGeodatabase文件"; pOpenFileDialog.ShowDialog(); string pFullPath = pOpenFileDialog.FileName; if (pFullPath == "") &#123; return; &#125; pAccessWorkspaceFactory = new AccessWorkspaceFactory(); //using ESRI.ArcGIS.DataSourcesGDB; //获取工作空间 IWorkspace pWorkspace = pAccessWorkspaceFactory.OpenFromFile(pFullPath, 0); ClearAllData(); //新增删除数据 //加载工作空间里的数据 AddAllDataset(pWorkspace, mainMapControl);&#125; 这里对加载工作空间中数据的方法进行了封装，自定义了 AddAllDataset 函数，以便对其他空间数据库（文件地理数据库、ArcSDE 空间数据库）加载时可直接调用。 以上代码主要介绍矢量和栅格数据的加载（其实不止这两种数据格式，加载其他类型的数据也是采用相同的方法，只是采用不同的工作空间而已）。 自定义函数 AddAllDataset 核心代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// 加载工作空间里面的要素和栅格数据/// &lt;/summary&gt;/// &lt;param name="pWorkspace"&gt;&lt;/param&gt;private void AddAllDataset(IWorkspace pWorkspace, AxMapControl mapControl)&#123; IEnumDataset pEnumDataset = pWorkspace.get_Datasets(ESRI.ArcGIS.Geodatabase.esriDatasetType.esriDTAny); pEnumDataset.Reset(); //将Enum数据集中的数据一个个读到DataSet中 IDataset pDataset = pEnumDataset.Next(); //判断数据集是否有数据 while (pDataset != null) &#123; if (pDataset is IFeatureDataset) //要素数据集 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureDataset pFeatureDataset = pFeatureWorkspace.OpenFeatureDataset(pDataset.Name); IEnumDataset pEnumDataset1 = pFeatureDataset.Subsets; pEnumDataset1.Reset(); IGroupLayer pGroupLayer = new GroupLayerClass(); pGroupLayer.Name = pFeatureDataset.Name; IDataset pDataset1 = pEnumDataset1.Next(); while (pDataset1 != null) &#123; if (pDataset1 is IFeatureClass) //要素类 &#123; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset1.Name); if (pFeatureLayer.FeatureClass != null) &#123; pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; pGroupLayer.Add(pFeatureLayer); mapControl.Map.AddLayer(pFeatureLayer); &#125; &#125; pDataset1 = pEnumDataset1.Next(); &#125; &#125; else if (pDataset is IFeatureClass) //要素类 &#123; IFeatureWorkspace pFeatureWorkspace = (IFeatureWorkspace)pWorkspace; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.FeatureClass = pFeatureWorkspace.OpenFeatureClass(pDataset.Name); pFeatureLayer.Name = pFeatureLayer.FeatureClass.AliasName; mapControl.Map.AddLayer(pFeatureLayer); &#125; else if (pDataset is IRasterDataset) //栅格数据集 &#123; IRasterWorkspaceEx pRasterWorkspace = (IRasterWorkspaceEx)pWorkspace; IRasterDataset pRasterDataset = pRasterWorkspace.OpenRasterDataset(pDataset.Name); //影像金字塔判断与创建 IRasterPyramid3 pRasPyrmid; pRasPyrmid = pRasterDataset as IRasterPyramid3; if (pRasPyrmid != null) &#123; if (!(pRasPyrmid.Present)) &#123; pRasPyrmid.Create(); //创建金字塔 &#125; &#125; IRasterLayer pRasterLayer = new RasterLayerClass(); pRasterLayer.CreateFromDataset(pRasterDataset); ILayer pLayer = pRasterLayer as ILayer; mapControl.AddLayer(pLayer, 0); &#125; pDataset = pEnumDataset.Next(); &#125; mapControl.ActiveView.Refresh(); //同步鹰眼 SynchronizeEagleEye();&#125; 加载文件地理数据库数据文件地理数据库（File Geodatabase）是以文件夹形式存储各种类型的 GIS 数据集，可以存储、查询和管理空间数据和非空间数据，支持的地理数据库的大小最大为 1 TB。文件地理数据库支持单用户编辑，不支持版本管理。实例程序实现思路： (1) 由于文件地理数据库是以文件夹的形式存在的，因此可以使用 FolderBrowserDialog 选择文件夹进行加载。首先创建 FileGDBWorkspaceFactoryClass 类的实例； (2) 用 IWorkspaceFactory 接口的 OpenFromFile 方法打开文件地理数据库的工作空间，对工作空间里面的数据进行加载。 12345678910111213141516171819202122#region 加载文件地理数据库数据private void AddFileDatabase_Click(object sender, EventArgs e)&#123; IWorkspaceFactory pFileGDBWorkspaceFactory; FolderBrowserDialog dlg = new FolderBrowserDialog(); if (dlg.ShowDialog() != DialogResult.OK) return; string pFullPath = dlg.SelectedPath; if (pFullPath == "") &#123; return; &#125; pFileGDBWorkspaceFactory = new FileGDBWorkspaceFactoryClass(); //using ESRI.ArcGIS.DataSourcesGDB; ClearAllData(); //新增删除数据 //获取工作空间 IWorkspace pWorkspace = pFileGDBWorkspaceFactory.OpenFromFile(pFullPath, 0); AddAllDataset(pWorkspace, mainMapControl);&#125;#endregion 加载 ArcSDE 空间数据库数据ArcSDE（Spatial Database Engine，空间搜索引擎）是在现有的关系型数据库上进行的空间扩展，它使空间数据能保存在关系数据库中（如 Oracle、SQLServer等）。ArcSDE 空间数据库的一个重要特点是支持多用户并发操作，并且可以通过版本来表现空间数据编辑的状态。 ArcSDE 的组成： ArcSDE 服务器管理进程负责维护 ArcSDE 和监听来自客户端的连接请求。ArcSDE 启动就是启动 ArcSDE 服务器管理进程，利用管理员账户管理 ArcSDE 与 RDBMS 的连接，处理客户端的连接请求。 专用服务器进程由 ArcSDE 服务器管理进程穿件，用于每一个特定的客户端应用程序与数据库的连接。 ArcSDE 客户端通过 ArcSDE 服务器管理进程和专用服务器进程建立和 RDBMS 的连接，实现对数据库的操作。 ArcSDE 提供了应用服务器连接和直接连接两种连接方式。当服务器性能较好时可采用应用服务器连接，否则采用直接连接。为了减轻服务器的压力，建议采用直接连接的方式进行连接。 两种连接方式的异同：直接连接就是通过 ArcSDE 访问数据表，并在本地完成对数据的各种操作（如空间分析、编辑等）；而应用服务器连接就是通过 ArcSDE 访问数据表后，在服务器端完成对数据的各种操作，再把操作结果返回客户端。 实例程序实现思路： (1) 创建 SDEWorksapceFactoryClass 类的实例； (2) 通过 SDE 连接的连接属性打开 SDE 数据库的工作空间，对工作空间里面的数据进行加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 这里以基于 Oracle 11g 的 ArcSDE 10.0 连接为例对两种连接方式进行说明。#region 加载 ArcSDE 数据库/// &lt;summary&gt;/// 服务器连接/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private void AddSDEByService_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; pWorkspace = arcSDEWorkspaceOpen("192.168.70.110", "esri_sde", "sde", "sde", "", "SDE.DEFAULT"); //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 直连/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private void AddSDEByDirect_Click(object sender, EventArgs e)&#123; IWorkspace pWorkspace; //如果工作空间不为空则进行加载 if (pWorkspace != null) &#123; AddAllDataset(pWorkspace, mainMapControl); &#125;&#125;/// &lt;summary&gt;/// 通过SDE连接打开SDE数据库/// &lt;/summary&gt;/// &lt;param name="server"&gt;服务器IP&lt;/param&gt;/// &lt;param name="instance"&gt;数据库实例，应用服务器连接为：5151或esri_sde，直连为sde:oracle11g:orcl(orcl为服务名)&lt;/param&gt;/// &lt;param name="user"&gt;SDE用户名&lt;/param&gt;/// &lt;param name="password"&gt;用户密码&lt;/param&gt;/// &lt;param name="database"&gt;数据库&lt;/param&gt;/// &lt;param name="version"&gt;SDE版本，缺省为"SDE.DEFAULT"&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private IWorkspace arcSDEWorkspaceOpen(string server, string instance, string user, string password, string database, string version)&#123; IWorkspace pWorkSpace = null; //创建和实例化数据集 IPropertySet pPropertySet = new PropertySetClass(); pPropertySet.SetProperty("SERVER", server); pPropertySet.SetProperty("INSTANCE", instance); pPropertySet.SetProperty("USER", user); pPropertySet.SetProperty("PASSWORD", password); pPropertySet.SetProperty("DATABASE", database); pPropertySet.SetProperty("VERSION", version); IWorkspaceFactory2 pWorkspaceFactory = new SdeWorkspaceFactoryClass(); try &#123; pWorkSpace = pWorkspaceFactory.Open(pPropertySet, 0); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; return pWorkSpace;&#125;#endregion 加载文本文件数据野外测量的数据通常为含有 X、Y 坐标的 Excel 文件或者文本文件。实例程序实现思路： (1) 根据 Excel 或者 *.txt 文件等获取点的坐标信息； (2) 根据点的坐标创建 Shapefile 图层； (3) 加载该 Shapefile 图层。 坐标信息的提取 (1) 创建一个点结构，进行点信息的存储。 123456struct CPoint&#123; public string Name; public double X; public double Y;&#125; (2) 创建并实例化一个 CPoint 类型的数组，将所有的点信息进行存储。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647List&lt;string&gt; pColumns = new List&lt;string&gt;();private List&lt;CPoint&gt; GetPoints(string surveyDataFullName)&#123; try &#123; List&lt;CPoint&gt; pList = new List&lt;CPoint&gt;(); char[] charArray = new char[] &#123; ',', ' ', '\t' &#125;; //常用的分隔符为逗号、空格、制表符 //文本信息读取 FileStream fs = new FileStream(surveyDataFullName, FileMode.Open); StreamReader sr = new StreamReader(fs, Encoding.Default); string strLine = sr.ReadLine(); if (strLine != null) &#123; string[] strArray = strLine.Split(charArray); if (strArray.Length &gt; 0) &#123; for (int i = 0; i &lt; strArray.Length; i++) &#123; pColumns.Add(strArray[i]); &#125; &#125; while ((strLine= sr.ReadLine())!=null) &#123; //点信息的读取 strArray = strLine.Split(charArray); CPoint pCPoint = new CPoint(); pCPoint.Name = strArray[0].Trim(); pCPoint.X = Convert.ToDouble(strArray[1]); pCPoint.Y = Convert.ToDouble(strArray[2]); pList.Add(pCPoint); &#125; &#125; else &#123; return null; &#125; sr.Close(); return pList; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); return null; &#125;&#125; 根据点坐标创建 Shapefile 图层 (1) 创建表的工作空间，通过 IFields、IFieldsEdit、IField 等接口创建属性字段，添加到要素集中。 (2) 根据获得的点坐标信息为属性字段赋值，进而得到图层的要素集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private IFeatureLayer CreateShpFromPoints(List&lt;CPoint&gt; cPointList, string filePath)&#123; int index = filePath.LastIndexOf('\\'); string folder = filePath.Substring(0, index);//路径切分得到文件夹名 string shapeName = filePath.Substring(index + 1); //路径切分得到文件名 IWorkspaceFactory pWSF = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pFWS = (IFeatureWorkspace)pWSF.OpenFromFile(folder, 0); IFields pFields = new FieldsClass(); IFieldsEdit pFieldsEdit; pFieldsEdit = (IFieldsEdit)pFields; IField pField = new FieldClass(); IFieldEdit pFieldEdit = (IFieldEdit)pField; pFieldEdit.Name_2 = "Shape"; pFieldEdit.Type_2 = esriFieldType.esriFieldTypeGeometry; IGeometryDef pGeometryDef = new GeometryDefClass(); IGeometryDefEdit pGDefEdit = (IGeometryDefEdit)pGeometryDef; pGDefEdit.GeometryType_2 = esriGeometryType.esriGeometryPoint; //定义坐标系 ISpatialReferenceFactory pSRF = new SpatialReferenceEnvironmentClass(); ISpatialReference pSpatialReference = pSRF.CreateGeographicCoordinateSystem((int)esriSRGeoCSType.esriSRGeoCS_Beijing1954); pGDefEdit.SpatialReference_2 = pSpatialReference; pFieldEdit.GeometryDef_2 = pGeometryDef; pFieldsEdit.AddField(pField); IFeatureClass pFeatureClass; pFeatureClass = pFWS.CreateFeatureClass(shapeName, pFields, null, null, esriFeatureType.esriFTSimple, "Shape", ""); IPoint pPoint = new PointClass(); for (int j = 0; j &lt; cPointList.Count; j++) &#123; pPoint.X = cPointList[j].X; pPoint.Y = cPointList[j].Y; IFeature pFeature = pFeatureClass.CreateFeature(); pFeature.Shape = pPoint; pFeature.Store(); &#125; IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = shapeName; pFeatureLayer.FeatureClass = pFeatureClass; return pFeatureLayer;&#125; Shapefile 图层的加载1234567891011121314151617private void btnCreate_Click(object sender, EventArgs e)&#123; if (ValidateTxtbox()) &#123; List&lt;CPoint&gt; pCPointList = GetPoints(txtSource.Text); if (pCPointList == null) &#123; MessageBox.Show("所选文件为空，请重新选择！"); &#125; else &#123; IFeatureLayer pFeatureLayer = CreateShpFromPoints(pCPointList, txtSave.Text); buddyMap.Map.AddLayer(pFeatureLayer); this.Close(); &#125; &#125;&#125; 总结根据上述 ArcGIS Engine 加载几种常用的数据源的方法，可以看出 ArcGIS Engine 加载空间数据一般具有以下五个步骤： 创建数据对应的工作空间工厂（WorkspaceFactory）； 使用 WorkspaceFactory 创建要加载数据的工作空间（Workspace）; 使用 Workspace 打开并得到图层的数据集 DataSet ; 将 DataSet 赋值给新建图层的数据源； 添加图层到 MapControl。]]></content>
      <categories>
        <category>ArcGIS</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>AE</tag>
      </tags>
  </entry>
</search>